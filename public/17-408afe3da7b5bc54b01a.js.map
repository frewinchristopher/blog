{"version":3,"sources":["webpack:///./node_modules/gatsby-link/index.js","webpack:///./node_modules/gatsby/node_modules/core-js/modules/es6.function.bind.js","webpack:///./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","webpack:///./node_modules/@babel/runtime/helpers/extends.js","webpack:///./node_modules/gatsby/node_modules/core-js/modules/_bind.js","webpack:///./node_modules/lodash/_nativeCreate.js","webpack:///./node_modules/lodash/_assocIndexOf.js","webpack:///./node_modules/lodash/_getMapData.js","webpack:///./node_modules/react-image-webp/dist/index.js","webpack:///./node_modules/lodash/isArray.js","webpack:///./node_modules/lodash/isSymbol.js","webpack:///./node_modules/lodash/_Symbol.js","webpack:///./node_modules/lodash/_root.js","webpack:///./node_modules/lodash/_baseGetTag.js","webpack:///./node_modules/lodash/_getNative.js","webpack:///./node_modules/lodash/isObject.js","webpack:///./node_modules/gatsby/node_modules/core-js/modules/es6.array.sort.js","webpack:///./node_modules/lodash/get.js","webpack:///./node_modules/lodash/_baseGet.js","webpack:///./node_modules/lodash/_castPath.js","webpack:///./node_modules/lodash/_isKey.js","webpack:///./node_modules/lodash/_freeGlobal.js","webpack:///./node_modules/lodash/_getRawTag.js","webpack:///./node_modules/lodash/_objectToString.js","webpack:///./node_modules/lodash/isObjectLike.js","webpack:///./node_modules/lodash/_stringToPath.js","webpack:///./node_modules/lodash/_memoizeCapped.js","webpack:///./node_modules/lodash/memoize.js","webpack:///./node_modules/lodash/_MapCache.js","webpack:///./node_modules/lodash/_mapCacheClear.js","webpack:///./node_modules/lodash/_Hash.js","webpack:///./node_modules/lodash/_hashClear.js","webpack:///./node_modules/lodash/_baseIsNative.js","webpack:///./node_modules/lodash/isFunction.js","webpack:///./node_modules/lodash/_isMasked.js","webpack:///./node_modules/lodash/_coreJsData.js","webpack:///./node_modules/lodash/_toSource.js","webpack:///./node_modules/lodash/_getValue.js","webpack:///./node_modules/lodash/_hashDelete.js","webpack:///./node_modules/lodash/_hashGet.js","webpack:///./node_modules/lodash/_hashHas.js","webpack:///./node_modules/lodash/_hashSet.js","webpack:///./node_modules/lodash/_ListCache.js","webpack:///./node_modules/lodash/_listCacheClear.js","webpack:///./node_modules/lodash/_listCacheDelete.js","webpack:///./node_modules/lodash/eq.js","webpack:///./node_modules/lodash/_listCacheGet.js","webpack:///./node_modules/lodash/_listCacheHas.js","webpack:///./node_modules/lodash/_listCacheSet.js","webpack:///./node_modules/lodash/_Map.js","webpack:///./node_modules/lodash/_mapCacheDelete.js","webpack:///./node_modules/lodash/_isKeyable.js","webpack:///./node_modules/lodash/_mapCacheGet.js","webpack:///./node_modules/lodash/_mapCacheHas.js","webpack:///./node_modules/lodash/_mapCacheSet.js","webpack:///./node_modules/lodash/toString.js","webpack:///./node_modules/lodash/_baseToString.js","webpack:///./node_modules/lodash/_arrayMap.js","webpack:///./node_modules/lodash/_toKey.js","webpack:///./node_modules/pts/dist/es2015/Util.js","webpack:///./node_modules/pts/dist/es2015/LinearAlgebra.js","webpack:///./node_modules/pts/dist/es2015/Op.js","webpack:///./node_modules/pts/dist/es2015/Num.js","webpack:///./node_modules/pts/dist/es2015/Pt.js","webpack:///./node_modules/pts/dist/es2015/UI.js","webpack:///./node_modules/pts/dist/es2015/Space.js","webpack:///./node_modules/pts/dist/es2015/Form.js","webpack:///./node_modules/pts/dist/es2015/Typography.js","webpack:///./node_modules/pts/dist/es2015/Canvas.js","webpack:///./node_modules/pts/dist/es2015/Create.js","webpack:///./node_modules/pts/dist/es2015/Color.js","webpack:///./node_modules/pts/dist/es2015/Dom.js","webpack:///./node_modules/pts/dist/es2015/Svg.js","webpack:///./node_modules/pts/dist/es2015/Physics.js","webpack:///./node_modules/pts/dist/es2015/_module.js"],"names":["_interopRequireDefault","__webpack_require__","exports","__esModule","withPrefix","navigateTo","replace","push","navigate","default","_objectWithoutPropertiesLoose2","_extends2","_inheritsLoose2","_assertThisInitialized2","_defineProperty2","_propTypes","_react","_router","_gatsby","path","normalizePath","NavLinkPropTypes","activeClassName","string","activeStyle","object","GatsbyLink","_React$Component","props","_this","call","this","_ref","isCurrent","className","filter","Boolean","join","style","IOSupported","window","IntersectionObserver","state","handleRef","bind","_proto","prototype","componentDidUpdate","prevProps","prevState","to","___loader","enqueue","parsePath","pathname","componentDidMount","ref","el","cb","io","_this2","innerRef","entries","forEach","entry","target","isIntersecting","intersectionRatio","unobserve","disconnect","observe","render","_this3","_this$props","_this$props$getProps","getProps","defaultGetProps","_onClick","onClick","_onMouseEnter","onMouseEnter","rest","prefixedTo","createElement","Link","e","hovering","button","defaultPrevented","metaKey","altKey","ctrlKey","shiftKey","preventDefault","Component","propTypes","func","isRequired","bool","_default","options","___navigate","console","warn","___push","___replace","$export","P","module","source","excluded","key","i","sourceKeys","Object","keys","length","indexOf","_extends","assign","arguments","hasOwnProperty","apply","aFunction","isObject","invoke","arraySlice","slice","factories","Function","that","fn","partArgs","bound","args","concat","F","len","n","construct","nativeCreate","getNative","eq","array","isKeyable","map","data","__data__","defineProperty","value","a","_typeof","Symbol","iterator","constructor","_createClass","b","c","d","enumerable","configurable","writable","_react2","Image","TypeError","_classCallCheck","ReferenceError","_possibleConstructorReturn","__proto__","getPrototypeOf","create","setPrototypeOf","_inherits","document","getContext","toDataURL","src","webp","alt","title","f","g","canUseWebP","isArray","Array","baseGetTag","isObjectLike","symbolTag","freeGlobal","freeSelf","self","root","getRawTag","objectToString","nullTag","undefinedTag","symToStringTag","toStringTag","undefined","baseIsNative","getValue","type","toObject","fails","$sort","sort","test","comparefn","baseGet","defaultValue","result","castPath","toKey","index","isKey","stringToPath","toString","isSymbol","reIsDeepProp","reIsPlainProp","global","objectProto","nativeObjectToString","isOwn","tag","unmasked","memoizeCapped","rePropName","reEscapeChar","charCodeAt","match","number","quote","subString","memoize","MAX_MEMOIZE_SIZE","cache","size","clear","MapCache","FUNC_ERROR_TEXT","resolver","memoized","has","get","set","Cache","mapCacheClear","mapCacheDelete","mapCacheGet","mapCacheHas","mapCacheSet","Hash","ListCache","Map","hash","hashClear","hashDelete","hashGet","hashHas","hashSet","isFunction","isMasked","toSource","reIsHostCtor","funcProto","funcToString","reIsNative","RegExp","asyncTag","funcTag","genTag","proxyTag","uid","coreJsData","maskSrcKey","exec","IE_PROTO","HASH_UNDEFINED","listCacheClear","listCacheDelete","listCacheGet","listCacheHas","listCacheSet","assocIndexOf","splice","pop","other","getMapData","baseToString","arrayMap","INFINITY","symbolProto","symbolToString","iteratee","Const","xy","yz","xz","xyz","horizontal","vertical","identical","right","bottom_right","bottom","bottom_left","left","top_left","top","top_right","epsilon","max","Number","MAX_VALUE","min","MIN_VALUE","pi","Math","PI","two_pi","half_pi","quarter_pi","one_degree","rad_to_deg","deg_to_rad","gravity","newton","gaussian","Util_Util","[object Object]","lv","_warnLevel","pos","ArrayBuffer","isView","p","message","defaultReturn","warnLevel","Error","range","start","floor","random","pts","stride","loopBack","st","chunks","flattenAsGroup","arr","Pt_Group","op","k","lenB","arrays","z","callback","step","temp","LinearAlgebra_Vec","Pt_Pt","sqrt","dot","magnitude","m","divide","abs","ceil","round","s","LinearAlgebra_Mat","isNum","$add","transposed","elementwise","ai","alen","$multiply","transpose","make","bi","blen","useLongest","ps","reduce","zipSlice","zip","pt","x","y","cosA","sinA","tanX","tanY","sx","sy","at","scale2DMatrix","rotate2DMatrix","shear2DMatrix","p1","p2","intercept","Op_Line","yi","ang2","atan","slope","cos","sin","_errorLength","obj","param","_errorOutofBound","anchor","angle","toAngle","xi","line","p3","threshold","$subtract","$cross","equals","magnitudeSq","asProjection","proj","$project","perpendicularFromPt","la","lb","pa","pb","y1","px","py","intersectRay2D","Num_Geom","withinBound","ray","lineOrRay","poly","sourceIsRay","intersectLineWithRay2D","intersectLine2D","next","lines1","lines2","isRay","group","lenk","_ip","gridPt","t","subtract","intersectGridWithRay2D","gg","rect","box","boundingBox","fromPtArray","Op_Rectangle","hasIntersectRect2D","intersectLines2D","sides","num","interpolate","cropAsCircle","ls","unit","multiply","fromCenter","sideIdx","graphic","atTail","perpendicular","add","$min","$max","topLeft","widthOrSize","height","fromTopLeft","center","half","within","Op_Circle","fromRect","enclose","maxValue","minValue","p0","corners","rects","merged","flatten","_center","ratio","asRows","mid","Num_Num","lerp","rect1","rect2","resetBoundingBox","r","radius","disc","discSqrt","t1","t2","circle","dv","dr2","dr","ar","br","ar2","br2","clone","h","ang","inc","Op_Triangle","toTriangle","fromCircle","Op_Polygon","midpoints","opp","oppositeSide","altitude","bisector","incenter","area","perimeter","total","md","medial","circumcenter","centroid","idx","closePath","sp","split","lines","gs","adjacentSides","mag","segments","det","sorted","dq","bot","hull","originIndex","_near","_item","unitAxis","poly1","poly2","projectAxis","ln","lineAt","info","which","dist","normal","edge","vertex","minDist","MAX_SAFE_INTEGER","axis","_axisOverlap","plen","b1","b2","c1","c2","smallest","lp","ins","intersectPolygon2D","polys","boxes","unshift","val","sum","currA","currB","targetA","targetB","normalizeValue","boundValue","radian","minPt","maxPt","average","ptOrIndex","direction","method","boundPt1","boundPt2","bounds","da","db","$cross2D","scale","scs","lenP","rotateAt2DMatrix","$take","transform2D","shearAt2DMatrix","tanx","tan","tany","mat","reflectAt2DMatrix","Float64Array","table","rad","boundAngle","toDegree","UIShape","PtBaseArray","Float32Array","super","getArgs","dimensions","randomize","fill","id","_id","w","anchorFromPt","change","params","fns","_ops","toArray","cross2D","cross","atan2","boundRadian","rotate2D","shear2D","reflect2D","p4","q1","q2","q3","q4","list","from","chunkSize","count","pts_per_segment","clamp","chunk","tc","moveBy","dim","desc","ptFn","forEachPt","Bound","_size","_topLeft","_bottomRight","_inited","init","width","_updateSize","_updateCenter","_updatePosFromTop","_updatePosFromCenter","bottomRight","depth","inited","UIPointerActions","up","down","move","drag","drop","over","out","Space_Space","_time","prev","diff","end","players","playerCount","_animID","_pause","_refresh","_pointer","_isReady","_playing","player","animate","pid","animateID","resize","time","requestAnimationFrame","play","playItems","err","cancelAnimationFrame","toggle","duration","stop","context","_renderFunc","customRendering","isPlaying","outerBound","innerBound","Space_MultiTouchSpace","_pressed","_dragged","_hasMouse","_hasTouch","pointer","evt","_canvas","addEventListener","removeEventListener","_bind","bindCanvas","_mouseDown","_mouseUp","_mouseOver","_mouseOut","_mouseMove","unbindCanvas","_touchMove","ts","item","pageX","pageY","MouseEvent","v","action","changedTouches","touch","_mouseAction","Form_Form","_ready","ready","required","VisualForm","_filled","_stroked","_font","Font","filled","stroked","currentFont","groups","shape","stroke","linejoin","linecap","point","_multiple","face","weight","lineHeight","Typography_Typography","samples","distribution","avg","str","tail","trim","substr","byHeight","nh","defaultSize","Canvas_CanvasSpace","elem","_pixelScale","_autoResize","_bgcolor","_offscreen","_initialResize","_selector","Element","querySelector","nodeName","toLowerCase","_container","_createElement","appendChild","parentElement","body","setTimeout","_ctx","setAttribute","_resizeHandler","dispatchEvent","Event","opt","bgcolor","autoResize","retina","r1","devicePixelRatio","r2","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","offscreen","_offCanvas","_offCtx","auto","translate","playOnce","getBoundingClientRect","fromBoundingRect","pageXOffset","pageYOffset","background","bg","pixelScale","hasOffscreen","offscreenCtx","offscreenCanvas","Canvas_CanvasForm","element","parent","ctx","lastColor","fillStyle","fillRect","clearRect","save","restore","space","_style","strokeStyle","lineWidth","lineJoin","lineCap","_space","font","off","clearOffscreen","offset","drawImage","sizeOrFont","family","_estimateTextWidth","fontWidthEstimate","estimate","textWidthEstimator","measureText","truncate","getTextWidth","textAlign","_paint","beginPath","arc","startAngle","endAngle","cc","halfsize","x1","x2","y2","moveTo","lineTo","square","polygon","img","orig","original","image","txt","maxWidth","fillText","text","verticalAlign","overrideBaseline","textBaseline","_textTruncate","_textAlign","crop","lstep","nextLine","sub","buffer","newln","dt","lastIndexOf","lsize","lbox","lpad","alignment","baseline","Create_Create","subpoints","columns","rows","orientation","$divide","dx","dy","seed","np","Create_Noise","initNoise","Create_Delaunay","grad3","permTable","perm","_n","j","n00","n01","n10","n11","_fade","tx","_mesh","triangleOnly","indices","_superTriangle","opened","_circum","closed","tris","edges","circum","triangle","_dedupe","o","_cache","vs","neighborPts","cs","sortEdges","dmax","tri","_triangle","circumcircle","Color_Color","_mode","_isNorm","hex","alpha","substring","hexVal","parseInt","toMode","mode","ranges","rgb","rgba","convert","fname","toUpperCase","l","u","normalized","toNorm","mapToRange","normalize","format","_hex","normalizedInput","normalizedOutput","$normalize","hsl","q","sc","hsb","XYZtoLAB","RGBtoXYZ","lab","XYZtoRGB","LABtoXYZ","LABtoLCH","RGBtoLAB","lch","LABtoRGB","LCHtoLAB","XYZtoLUV","luv","LUVtoXYZ","pow","D65","cy","nnn","refU","refV","L","cubeY","toRadian","Dom_DOMSpace","_css","appendTo","refresh","styles","innerHTML","backgroundColor","update","HTMLSpace","Dom_HTMLForm","name","autoClass","querySelectorAll","scopeID","parentNode","removeChild","remove","removeAll","groupID","groupCount","currentID","currentClass","border-color","color","border-width","border-radius","border-style","position","fontSize","fontFamily","styleTo","group_id","nextID","updateScope","domID","setAttr","htmlElement","getID","class","rectStyle","_checkSize","textContent","Svg_SVGSpace","svgElement","Svg_SVGForm","viewBox","xmlns","version","createElementNS","stroke-width","stroke-linejoin","stroke-linecap","cx","largeArc","sweep","_poly","points","fromArray","pointer-events","Physics_World","friction","_lastTime","_gravity","_friction","_damping","_particles","_bodies","_names","_bound","fromGroup","damping","bodyCount","particleCount","ms","_updateParticles","_updateBodies","_drawParticles","_drawBodies","Physics_Body","stiff","precise","m1","mass","m2","mm","delta","distSq","changed","previous","prevDt","addForce","verlet","integrate","boundConstraint","collide","klen","bk","processBody","mlen","processParticle","processEdges","Physics_Particle","_mass","_radius","_force","_prev","_lock","force","_body","lock","_lockPt","lastDt","lt","damp","dp","np1","np2","f1","f2","dm1","dm2","_cs","_stiff","_locks","autoLink","autoMass","linkAll","index1","index2","link","nd","n2","edgeConstraint","hit","hasIntersectPolygon","cv","eg","lambda","m0","mr0","mr1","hasIntersectCircle","__webpack_exports__"],"mappings":"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","file":"17-408afe3da7b5bc54b01a.js","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nexports.__esModule = true;\nexports.withPrefix = withPrefix;\nexports.navigateTo = exports.replace = exports.push = exports.navigate = exports.default = void 0;\n\nvar _objectWithoutPropertiesLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutPropertiesLoose\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _inheritsLoose2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inheritsLoose\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _router = require(\"@reach/router\");\n\nvar _gatsby = require(\"gatsby\");\n\n/*global __PATH_PREFIX__ */\nfunction withPrefix(path) {\n  return normalizePath(__PATH_PREFIX__ + \"/\" + path);\n}\n\nfunction normalizePath(path) {\n  return path.replace(/\\/+/g, \"/\");\n}\n\nvar NavLinkPropTypes = {\n  activeClassName: _propTypes.default.string,\n  activeStyle: _propTypes.default.object // Set up IntersectionObserver\n\n};\n\nvar handleIntersection = function handleIntersection(el, cb) {\n  var io = new window.IntersectionObserver(function (entries) {\n    entries.forEach(function (entry) {\n      if (el === entry.target) {\n        // Check if element is within viewport, remove listener, destroy observer, and run link callback.\n        // MSEdge doesn't currently support isIntersecting, so also test for  an intersectionRatio > 0\n        if (entry.isIntersecting || entry.intersectionRatio > 0) {\n          io.unobserve(el);\n          io.disconnect();\n          cb();\n        }\n      }\n    });\n  }); // Add element to the observer\n\n  io.observe(el);\n};\n\nvar GatsbyLink =\n/*#__PURE__*/\nfunction (_React$Component) {\n  (0, _inheritsLoose2.default)(GatsbyLink, _React$Component);\n\n  function GatsbyLink(props) {\n    var _this;\n\n    _this = _React$Component.call(this) || this; // Default to no support for IntersectionObserver\n\n    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), \"defaultGetProps\", function (_ref) {\n      var isCurrent = _ref.isCurrent;\n\n      if (isCurrent) {\n        return {\n          className: [_this.props.className, _this.props.activeClassName].filter(Boolean).join(\" \"),\n          style: (0, _extends2.default)({}, _this.props.style, _this.props.activeStyle)\n        };\n      }\n\n      return null;\n    });\n    var IOSupported = false;\n\n    if (typeof window !== \"undefined\" && window.IntersectionObserver) {\n      IOSupported = true;\n    }\n\n    _this.state = {\n      IOSupported: IOSupported\n    };\n    _this.handleRef = _this.handleRef.bind((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)));\n    return _this;\n  }\n\n  var _proto = GatsbyLink.prototype;\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    // Preserve non IO functionality if no support\n    if (this.props.to !== prevProps.to && !this.state.IOSupported) {\n      ___loader.enqueue((0, _gatsby.parsePath)(this.props.to).pathname);\n    }\n  };\n\n  _proto.componentDidMount = function componentDidMount() {\n    // Preserve non IO functionality if no support\n    if (!this.state.IOSupported) {\n      ___loader.enqueue((0, _gatsby.parsePath)(this.props.to).pathname);\n    }\n  };\n\n  _proto.handleRef = function handleRef(ref) {\n    var _this2 = this;\n\n    this.props.innerRef && this.props.innerRef(ref);\n\n    if (this.state.IOSupported && ref) {\n      // If IO supported and element reference found, setup Observer functionality\n      handleIntersection(ref, function () {\n        ___loader.enqueue((0, _gatsby.parsePath)(_this2.props.to).pathname);\n      });\n    }\n  };\n\n  _proto.render = function render() {\n    var _this3 = this;\n\n    var _this$props = this.props,\n        to = _this$props.to,\n        _this$props$getProps = _this$props.getProps,\n        getProps = _this$props$getProps === void 0 ? this.defaultGetProps : _this$props$getProps,\n        _onClick = _this$props.onClick,\n        _onMouseEnter = _this$props.onMouseEnter,\n        $activeClassName = _this$props.activeClassName,\n        $activeStyle = _this$props.activeStyle,\n        $ref = _this$props.ref,\n        $innerRef = _this$props.innerRef,\n        state = _this$props.state,\n        replace = _this$props.replace,\n        rest = (0, _objectWithoutPropertiesLoose2.default)(_this$props, [\"to\", \"getProps\", \"onClick\", \"onMouseEnter\", \"activeClassName\", \"activeStyle\", \"ref\", \"innerRef\", \"state\", \"replace\"]);\n    var prefixedTo = withPrefix(to);\n    return _react.default.createElement(_router.Link, (0, _extends2.default)({\n      to: prefixedTo,\n      state: state,\n      getProps: getProps,\n      innerRef: this.handleRef,\n      onMouseEnter: function onMouseEnter(e) {\n        // eslint-disable-line\n        _onMouseEnter && _onMouseEnter(e);\n\n        ___loader.hovering((0, _gatsby.parsePath)(to).pathname);\n      },\n      onClick: function onClick(e) {\n        // eslint-disable-line\n        _onClick && _onClick(e);\n\n        if (e.button === 0 && // ignore right clicks\n        !_this3.props.target && // let browser handle \"target=_blank\"\n        !e.defaultPrevented && // onClick prevented default\n        !e.metaKey && // ignore clicks with modifier keys...\n        !e.altKey && !e.ctrlKey && !e.shiftKey) {\n          e.preventDefault(); // Make sure the necessary scripts and data are\n          // loaded before continuing.\n\n          navigate(to, {\n            state: state,\n            replace: replace\n          });\n        }\n\n        return true;\n      }\n    }, rest));\n  };\n\n  return GatsbyLink;\n}(_react.default.Component);\n\nGatsbyLink.propTypes = (0, _extends2.default)({}, NavLinkPropTypes, {\n  innerRef: _propTypes.default.func,\n  onClick: _propTypes.default.func,\n  to: _propTypes.default.string.isRequired,\n  replace: _propTypes.default.bool\n});\nvar _default = GatsbyLink;\nexports.default = _default;\n\nvar navigate = function navigate(to, options) {\n  window.___navigate(withPrefix(to), options);\n};\n\nexports.navigate = navigate;\n\nvar push = function push(to) {\n  console.warn(\"The \\\"push\\\" method is now deprecated and will be removed in Gatsby v3. Please use \\\"navigate\\\" instead.\");\n\n  window.___push(withPrefix(to));\n};\n\nexports.push = push;\n\nvar replace = function replace(to) {\n  console.warn(\"The \\\"replace\\\" method is now deprecated and will be removed in Gatsby v3. Please use \\\"navigate\\\" instead.\");\n\n  window.___replace(withPrefix(to));\n}; // TODO: Remove navigateTo for Gatsby v3\n\n\nexports.replace = replace;\n\nvar navigateTo = function navigateTo(to) {\n  console.warn(\"The \\\"navigateTo\\\" method is now deprecated and will be removed in Gatsby v3. Please use \\\"navigate\\\" instead.\");\n  return push(to);\n};\n\nexports.navigateTo = navigateTo;","// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)\nvar $export = require('./_export');\n\n$export($export.P, 'Function', { bind: require('./_bind') });\n","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;","function _extends() {\n  module.exports = _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nmodule.exports = _extends;","'use strict';\nvar aFunction = require('./_a-function');\nvar isObject = require('./_is-object');\nvar invoke = require('./_invoke');\nvar arraySlice = [].slice;\nvar factories = {};\n\nvar construct = function (F, len, args) {\n  if (!(len in factories)) {\n    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';\n    // eslint-disable-next-line no-new-func\n    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');\n  } return factories[len](F, args);\n};\n\nmodule.exports = Function.bind || function bind(that /* , ...args */) {\n  var fn = aFunction(this);\n  var partArgs = arraySlice.call(arguments, 1);\n  var bound = function (/* args... */) {\n    var args = partArgs.concat(arraySlice.call(arguments));\n    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n  };\n  if (isObject(fn.prototype)) bound.prototype = fn.prototype;\n  return bound;\n};\n","var getNative = require('./_getNative');\n\n/* Built-in method references that are verified to be native. */\nvar nativeCreate = getNative(Object, 'create');\n\nmodule.exports = nativeCreate;\n","var eq = require('./eq');\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\nmodule.exports = assocIndexOf;\n","var isKeyable = require('./_isKeyable');\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\nmodule.exports = getMapData;\n","\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0});var _typeof=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&\"function\"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?\"symbol\":typeof a},_createClass=function(){function a(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,\"value\"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}return function(b,c,d){return c&&a(b.prototype,c),d&&a(b,d),b}}(),_react=require(\"react\"),_react2=_interopRequireDefault(_react);function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError(\"Cannot call a class as a function\")}function _possibleConstructorReturn(a,b){if(!a)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return b&&(\"object\"==typeof b||\"function\"==typeof b)?b:a}function _inherits(a,b){if(\"function\"!=typeof b&&null!==b)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof b);a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,enumerable:!1,writable:!0,configurable:!0}}),b&&(Object.setPrototypeOf?Object.setPrototypeOf(a,b):a.__proto__=b)}var Image=function(a){function b(){return _classCallCheck(this,b),_possibleConstructorReturn(this,(b.__proto__||Object.getPrototypeOf(b)).apply(this,arguments))}return _inherits(b,a),_createClass(b,[{key:\"canUseWebP\",value:function(){var a=\"object\"===(\"undefined\"==typeof document?\"undefined\":_typeof(document))?document.createElement(\"canvas\"):{};return!!(a.getContext&&a.getContext(\"2d\"))&&0===a.toDataURL(\"image/webp\").indexOf(\"data:image/webp\")}},{key:\"render\",value:function(){var a=this.props,b=a.src,c=a.webp,d=a.alt,e=a.title,f=a.style,g=a.className,h=this.canUseWebP(),i=b;return!0===h&&(i=c),_react2.default.createElement(\"img\",{src:i,alt:d,title:e,style:f,className:g})}}]),b}(_react.Component);exports.default=Image;","/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\nmodule.exports = isArray;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var baseIsNative = require('./_baseIsNative'),\n    getValue = require('./_getValue');\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","'use strict';\nvar $export = require('./_export');\nvar aFunction = require('./_a-function');\nvar toObject = require('./_to-object');\nvar fails = require('./_fails');\nvar $sort = [].sort;\nvar test = [1, 2, 3];\n\n$export($export.P + $export.F * (fails(function () {\n  // IE8-\n  test.sort(undefined);\n}) || !fails(function () {\n  // V8 bug\n  test.sort(null);\n  // Old WebKit\n}) || !require('./_strict-method')($sort)), 'Array', {\n  // 22.1.3.25 Array.prototype.sort(comparefn)\n  sort: function sort(comparefn) {\n    return comparefn === undefined\n      ? $sort.call(toObject(this))\n      : $sort.call(toObject(this), aFunction(comparefn));\n  }\n});\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","var isArray = require('./isArray'),\n    isKey = require('./_isKey'),\n    stringToPath = require('./_stringToPath'),\n    toString = require('./toString');\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\nmodule.exports = castPath;\n","var isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/;\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\nmodule.exports = isKey;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n","var memoizeCapped = require('./_memoizeCapped');\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\nmodule.exports = stringToPath;\n","var memoize = require('./memoize');\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\nmodule.exports = memoizeCapped;\n","var MapCache = require('./_MapCache');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\nmodule.exports = memoize;\n","var mapCacheClear = require('./_mapCacheClear'),\n    mapCacheDelete = require('./_mapCacheDelete'),\n    mapCacheGet = require('./_mapCacheGet'),\n    mapCacheHas = require('./_mapCacheHas'),\n    mapCacheSet = require('./_mapCacheSet');\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\nmodule.exports = MapCache;\n","var Hash = require('./_Hash'),\n    ListCache = require('./_ListCache'),\n    Map = require('./_Map');\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\nmodule.exports = mapCacheClear;\n","var hashClear = require('./_hashClear'),\n    hashDelete = require('./_hashDelete'),\n    hashGet = require('./_hashGet'),\n    hashHas = require('./_hashHas'),\n    hashSet = require('./_hashSet');\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\nmodule.exports = Hash;\n","var nativeCreate = require('./_nativeCreate');\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\nmodule.exports = hashClear;\n","var isFunction = require('./isFunction'),\n    isMasked = require('./_isMasked'),\n    isObject = require('./isObject'),\n    toSource = require('./_toSource');\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\nmodule.exports = baseIsNative;\n","var baseGetTag = require('./_baseGetTag'),\n    isObject = require('./isObject');\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\nmodule.exports = isFunction;\n","var coreJsData = require('./_coreJsData');\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\nmodule.exports = isMasked;\n","var root = require('./_root');\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\nmodule.exports = coreJsData;\n","/** Used for built-in method references. */\nvar funcProto = Function.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\nmodule.exports = toSource;\n","/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\nmodule.exports = getValue;\n","/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = hashDelete;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\nmodule.exports = hashGet;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\nmodule.exports = hashHas;\n","var nativeCreate = require('./_nativeCreate');\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\nmodule.exports = hashSet;\n","var listCacheClear = require('./_listCacheClear'),\n    listCacheDelete = require('./_listCacheDelete'),\n    listCacheGet = require('./_listCacheGet'),\n    listCacheHas = require('./_listCacheHas'),\n    listCacheSet = require('./_listCacheSet');\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\nmodule.exports = ListCache;\n","/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\nmodule.exports = listCacheClear;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype;\n\n/** Built-in value references. */\nvar splice = arrayProto.splice;\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\nmodule.exports = listCacheDelete;\n","/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\nmodule.exports = eq;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\nmodule.exports = listCacheGet;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\nmodule.exports = listCacheHas;\n","var assocIndexOf = require('./_assocIndexOf');\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\nmodule.exports = listCacheSet;\n","var getNative = require('./_getNative'),\n    root = require('./_root');\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map');\n\nmodule.exports = Map;\n","var getMapData = require('./_getMapData');\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\nmodule.exports = mapCacheDelete;\n","/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\nmodule.exports = isKeyable;\n","var getMapData = require('./_getMapData');\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\nmodule.exports = mapCacheGet;\n","var getMapData = require('./_getMapData');\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\nmodule.exports = mapCacheHas;\n","var getMapData = require('./_getMapData');\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\nmodule.exports = mapCacheSet;\n","var baseToString = require('./_baseToString');\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\nmodule.exports = toString;\n","var Symbol = require('./_Symbol'),\n    arrayMap = require('./_arrayMap'),\n    isArray = require('./isArray'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = baseToString;\n","/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\nmodule.exports = arrayMap;\n","var isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\nmodule.exports = toKey;\n","import { Group } from \"./Pt\";\nexport const Const = {\n    xy: \"xy\",\n    yz: \"yz\",\n    xz: \"xz\",\n    xyz: \"xyz\",\n    horizontal: 0,\n    vertical: 1,\n    identical: 0,\n    right: 4,\n    bottom_right: 5,\n    bottom: 6,\n    bottom_left: 7,\n    left: 8,\n    top_left: 1,\n    top: 2,\n    top_right: 3,\n    epsilon: 0.0001,\n    max: Number.MAX_VALUE,\n    min: Number.MIN_VALUE,\n    pi: Math.PI,\n    two_pi: 6.283185307179586,\n    half_pi: 1.5707963267948966,\n    quarter_pi: 0.7853981633974483,\n    one_degree: 0.017453292519943295,\n    rad_to_deg: 57.29577951308232,\n    deg_to_rad: 0.017453292519943295,\n    gravity: 9.81,\n    newton: 0.10197,\n    gaussian: 0.3989422804014327\n};\nexport class Util {\n    static warnLevel(lv) {\n        if (lv) {\n            Util._warnLevel = lv;\n        }\n        return Util._warnLevel;\n    }\n    static getArgs(args) {\n        if (args.length < 1)\n            return [];\n        let pos = [];\n        let isArray = Array.isArray(args[0]) || ArrayBuffer.isView(args[0]);\n        if (typeof args[0] === 'number') {\n            pos = Array.prototype.slice.call(args);\n        }\n        else if (typeof args[0] === 'object' && !isArray) {\n            let a = [\"x\", \"y\", \"z\", \"w\"];\n            let p = args[0];\n            for (let i = 0; i < a.length; i++) {\n                if ((p.length && i >= p.length) || !(a[i] in p))\n                    break;\n                pos.push(p[a[i]]);\n            }\n        }\n        else if (isArray) {\n            pos = [].slice.call(args[0]);\n        }\n        return pos;\n    }\n    static warn(message = \"error\", defaultReturn = undefined) {\n        if (Util.warnLevel() == \"error\") {\n            throw new Error(message);\n        }\n        else if (Util.warnLevel() == \"warn\") {\n            console.warn(message);\n        }\n        return defaultReturn;\n    }\n    static randomInt(range, start = 0) {\n        return Math.floor(Math.random() * range) + start;\n    }\n    static split(pts, size, stride, loopBack = false) {\n        let st = stride || size;\n        let chunks = [];\n        for (let i = 0; i < pts.length; i++) {\n            if (i * st + size > pts.length) {\n                if (loopBack) {\n                    let g = pts.slice(i * st);\n                    g = g.concat(pts.slice(0, (i * st + size) % size));\n                    chunks.push(g);\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                chunks.push(pts.slice(i * st, i * st + size));\n            }\n        }\n        return chunks;\n    }\n    static flatten(pts, flattenAsGroup = true) {\n        let arr = (flattenAsGroup) ? new Group() : new Array();\n        return arr.concat.apply(arr, pts);\n    }\n    static combine(a, b, op) {\n        let result = [];\n        for (let i = 0, len = a.length; i < len; i++) {\n            for (let k = 0, lenB = b.length; k < lenB; k++) {\n                result.push(op(a[i], b[k]));\n            }\n        }\n        return result;\n    }\n    static zip(arrays) {\n        let z = [];\n        for (let i = 0, len = arrays[0].length; i < len; i++) {\n            let p = [];\n            for (let k = 0; k < arrays.length; k++) {\n                p.push(arrays[k][i]);\n            }\n            z.push(p);\n        }\n        return z;\n    }\n    static stepper(max, min = 0, stride = 1, callback) {\n        let c = min;\n        return function () {\n            c += stride;\n            if (c >= max) {\n                c = min + (c - max);\n            }\n            if (callback)\n                callback(c);\n            return c;\n        };\n    }\n    static forRange(fn, range, start = 0, step = 1) {\n        let temp = [];\n        for (let i = start, len = range; i < len; i += step) {\n            temp[i] = fn(i);\n        }\n        return temp;\n    }\n}\nUtil._warnLevel = \"mute\";\n//# sourceMappingURL=Util.js.map","import { Pt, Group } from \"./Pt\";\nimport { Line } from \"./Op\";\nexport class Vec {\n    static add(a, b) {\n        if (typeof b == \"number\") {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] += b;\n        }\n        else {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] += b[i] || 0;\n        }\n        return a;\n    }\n    static subtract(a, b) {\n        if (typeof b == \"number\") {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] -= b;\n        }\n        else {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] -= b[i] || 0;\n        }\n        return a;\n    }\n    static multiply(a, b) {\n        if (typeof b == \"number\") {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] *= b;\n        }\n        else {\n            if (a.length != b.length) {\n                throw new Error(`Cannot do element-wise multiply since the array lengths don't match: ${a.toString()} multiply-with ${b.toString()}`);\n            }\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] *= b[i];\n        }\n        return a;\n    }\n    static divide(a, b) {\n        if (typeof b == \"number\") {\n            if (b === 0)\n                throw new Error(\"Cannot divide by zero\");\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] /= b;\n        }\n        else {\n            if (a.length != b.length) {\n                throw new Error(`Cannot do element-wise divide since the array lengths don't match. ${a.toString()} divide-by ${b.toString()}`);\n            }\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] /= b[i];\n        }\n        return a;\n    }\n    static dot(a, b) {\n        if (a.length != b.length)\n            throw new Error(\"Array lengths don't match\");\n        let d = 0;\n        for (let i = 0, len = a.length; i < len; i++) {\n            d += a[i] * b[i];\n        }\n        return d;\n    }\n    static cross2D(a, b) {\n        return a[0] * b[1] - a[1] * b[0];\n    }\n    static cross(a, b) {\n        return new Pt((a[1] * b[2] - a[2] * b[1]), (a[2] * b[0] - a[0] * b[2]), (a[0] * b[1] - a[1] * b[0]));\n    }\n    static magnitude(a) {\n        return Math.sqrt(Vec.dot(a, a));\n    }\n    static unit(a, magnitude = undefined) {\n        let m = (magnitude === undefined) ? Vec.magnitude(a) : magnitude;\n        if (m === 0)\n            throw new Error(\"Cannot calculate unit vector because magnitude is 0\");\n        return Vec.divide(a, m);\n    }\n    static abs(a) {\n        return Vec.map(a, Math.abs);\n    }\n    static floor(a) {\n        return Vec.map(a, Math.floor);\n    }\n    static ceil(a) {\n        return Vec.map(a, Math.ceil);\n    }\n    static round(a) {\n        return Vec.map(a, Math.round);\n    }\n    static max(a) {\n        let m = Number.MIN_VALUE;\n        let index = 0;\n        for (let i = 0, len = a.length; i < len; i++) {\n            m = Math.max(m, a[i]);\n            if (m === a[i])\n                index = i;\n        }\n        return { value: m, index: index };\n    }\n    static min(a) {\n        let m = Number.MAX_VALUE;\n        let index = 0;\n        for (let i = 0, len = a.length; i < len; i++) {\n            m = Math.min(m, a[i]);\n            if (m === a[i])\n                index = i;\n        }\n        return { value: m, index: index };\n    }\n    static sum(a) {\n        let s = 0;\n        for (let i = 0, len = a.length; i < len; i++)\n            s += a[i];\n        return s;\n    }\n    static map(a, fn) {\n        for (let i = 0, len = a.length; i < len; i++) {\n            a[i] = fn(a[i], i, a);\n        }\n        return a;\n    }\n}\nexport class Mat {\n    static add(a, b) {\n        if (typeof b != \"number\") {\n            if (a[0].length != b[0].length)\n                throw new Error(\"Cannot add matrix if rows' and columns' size don't match.\");\n            if (a.length != b.length)\n                throw new Error(\"Cannot add matrix if rows' and columns' size don't match.\");\n        }\n        let g = new Group();\n        let isNum = typeof b == \"number\";\n        for (let i = 0, len = a.length; i < len; i++) {\n            g.push(a[i].$add((isNum) ? b : b[i]));\n        }\n        return g;\n    }\n    static multiply(a, b, transposed = false, elementwise = false) {\n        let g = new Group();\n        if (typeof b != \"number\") {\n            if (elementwise) {\n                if (a.length != b.length)\n                    throw new Error(\"Cannot multiply matrix element-wise because the matrices' sizes don't match.\");\n                for (let ai = 0, alen = a.length; ai < alen; ai++) {\n                    g.push(a[ai].$multiply(b[ai]));\n                }\n            }\n            else {\n                if (!transposed && a[0].length != b.length)\n                    throw new Error(\"Cannot multiply matrix if rows in matrix-a don't match columns in matrix-b.\");\n                if (transposed && a[0].length != b[0].length)\n                    throw new Error(\"Cannot multiply matrix if transposed and the columns in both matrices don't match.\");\n                if (!transposed)\n                    b = Mat.transpose(b);\n                for (let ai = 0, alen = a.length; ai < alen; ai++) {\n                    let p = Pt.make(b.length, 0);\n                    for (let bi = 0, blen = b.length; bi < blen; bi++) {\n                        p[bi] = Vec.dot(a[ai], b[bi]);\n                    }\n                    g.push(p);\n                }\n            }\n        }\n        else {\n            for (let ai = 0, alen = a.length; ai < alen; ai++) {\n                g.push(a[ai].$multiply(b));\n            }\n        }\n        return g;\n    }\n    static zipSlice(g, index, defaultValue = false) {\n        let z = [];\n        for (let i = 0, len = g.length; i < len; i++) {\n            if (g[i].length - 1 < index && defaultValue === false)\n                throw `Index ${index} is out of bounds`;\n            z.push(g[i][index] || defaultValue);\n        }\n        return new Pt(z);\n    }\n    static zip(g, defaultValue = false, useLongest = false) {\n        let ps = new Group();\n        let len = (useLongest) ? g.reduce((a, b) => Math.max(a, b.length), 0) : g[0].length;\n        for (let i = 0; i < len; i++) {\n            ps.push(Mat.zipSlice(g, i, defaultValue));\n        }\n        return ps;\n    }\n    static transpose(g, defaultValue = false, useLongest = false) {\n        return Mat.zip(g, defaultValue, useLongest);\n    }\n    static transform2D(pt, m) {\n        let x = pt[0] * m[0][0] + pt[1] * m[1][0] + m[2][0];\n        let y = pt[0] * m[0][1] + pt[1] * m[1][1] + m[2][1];\n        return new Pt(x, y);\n    }\n    static scale2DMatrix(x, y) {\n        return new Group(new Pt(x, 0, 0), new Pt(0, y, 0), new Pt(0, 0, 1));\n    }\n    static rotate2DMatrix(cosA, sinA) {\n        return new Group(new Pt(cosA, sinA, 0), new Pt(-sinA, cosA, 0), new Pt(0, 0, 1));\n    }\n    static shear2DMatrix(tanX, tanY) {\n        return new Group(new Pt(1, tanX, 0), new Pt(tanY, 1, 0), new Pt(0, 0, 1));\n    }\n    static translate2DMatrix(x, y) {\n        return new Group(new Pt(1, 0, 0), new Pt(0, 1, 0), new Pt(x, y, 1));\n    }\n    static scaleAt2DMatrix(sx, sy, at) {\n        let m = Mat.scale2DMatrix(sx, sy);\n        m[2][0] = -at[0] * sx + at[0];\n        m[2][1] = -at[1] * sy + at[1];\n        return m;\n    }\n    static rotateAt2DMatrix(cosA, sinA, at) {\n        let m = Mat.rotate2DMatrix(cosA, sinA);\n        m[2][0] = at[0] * (1 - cosA) + at[1] * sinA;\n        m[2][1] = at[1] * (1 - cosA) - at[0] * sinA;\n        return m;\n    }\n    static shearAt2DMatrix(tanX, tanY, at) {\n        let m = Mat.shear2DMatrix(tanX, tanY);\n        m[2][0] = -at[1] * tanY;\n        m[2][1] = -at[0] * tanX;\n        return m;\n    }\n    static reflectAt2DMatrix(p1, p2) {\n        let intercept = Line.intercept(p1, p2);\n        if (intercept == undefined) {\n            return [\n                new Pt([-1, 0, 0]),\n                new Pt([0, 1, 0]),\n                new Pt([p1[0] + p2[0], 0, 1])\n            ];\n        }\n        else {\n            let yi = intercept.yi;\n            let ang2 = Math.atan(intercept.slope) * 2;\n            let cosA = Math.cos(ang2);\n            let sinA = Math.sin(ang2);\n            return [\n                new Pt([cosA, sinA, 0]),\n                new Pt([sinA, -cosA, 0]),\n                new Pt([-yi * sinA, yi + yi * cosA, 1])\n            ];\n        }\n    }\n}\n//# sourceMappingURL=LinearAlgebra.js.map","import { Util } from \"./Util\";\nimport { Geom, Num } from \"./Num\";\nimport { Pt, Group } from \"./Pt\";\nimport { Mat } from \"./LinearAlgebra\";\nlet _errorLength = (obj, param = \"expected\") => Util.warn(\"Group's length is less than \" + param, obj);\nlet _errorOutofBound = (obj, param = \"\") => Util.warn(`Index ${param} is out of bound in Group`, obj);\nexport class Line {\n    static fromAngle(anchor, angle, magnitude) {\n        let g = new Group(new Pt(anchor), new Pt(anchor));\n        g[1].toAngle(angle, magnitude, true);\n        return g;\n    }\n    static slope(p1, p2) {\n        return (p2[0] - p1[0] === 0) ? undefined : (p2[1] - p1[1]) / (p2[0] - p1[0]);\n    }\n    static intercept(p1, p2) {\n        if (p2[0] - p1[0] === 0) {\n            return undefined;\n        }\n        else {\n            let m = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n            let c = p1[1] - m * p1[0];\n            return { slope: m, yi: c, xi: (m === 0) ? undefined : -c / m };\n        }\n    }\n    static sideOfPt2D(line, pt) {\n        return (line[1][0] - line[0][0]) * (pt[1] - line[0][1]) - (pt[0] - line[0][0]) * (line[1][1] - line[0][1]);\n    }\n    static collinear(p1, p2, p3, threshold = 0.01) {\n        let a = new Pt(0, 0, 0).to(p1).$subtract(p2);\n        let b = new Pt(0, 0, 0).to(p1).$subtract(p3);\n        return a.$cross(b).divide(1000).equals(new Pt(0, 0, 0), threshold);\n    }\n    static magnitude(line) {\n        return (line.length >= 2) ? line[1].$subtract(line[0]).magnitude() : 0;\n    }\n    static magnitudeSq(line) {\n        return (line.length >= 2) ? line[1].$subtract(line[0]).magnitudeSq() : 0;\n    }\n    static perpendicularFromPt(line, pt, asProjection = false) {\n        if (line[0].equals(line[1]))\n            return undefined;\n        let a = line[0].$subtract(line[1]);\n        let b = line[1].$subtract(pt);\n        let proj = b.$subtract(a.$project(b));\n        return (asProjection) ? proj : proj.$add(pt);\n    }\n    static distanceFromPt(line, pt) {\n        return Line.perpendicularFromPt(line, pt, true).magnitude();\n    }\n    static intersectRay2D(la, lb) {\n        let a = Line.intercept(la[0], la[1]);\n        let b = Line.intercept(lb[0], lb[1]);\n        let pa = la[0];\n        let pb = lb[0];\n        if (a == undefined) {\n            if (b == undefined)\n                return undefined;\n            let y1 = -b.slope * (pb[0] - pa[0]) + pb[1];\n            return new Pt(pa[0], y1);\n        }\n        else {\n            if (b == undefined) {\n                let y1 = -a.slope * (pa[0] - pb[0]) + pa[1];\n                return new Pt(pb[0], y1);\n            }\n            else if (b.slope != a.slope) {\n                let px = (a.slope * pa[0] - b.slope * pb[0] + pb[1] - pa[1]) / (a.slope - b.slope);\n                let py = a.slope * (px - pa[0]) + pa[1];\n                return new Pt(px, py);\n            }\n            else {\n                if (a.yi == b.yi) {\n                    return new Pt(pa[0], pa[1]);\n                }\n                else {\n                    return undefined;\n                }\n            }\n        }\n    }\n    static intersectLine2D(la, lb) {\n        let pt = Line.intersectRay2D(la, lb);\n        return (pt && Geom.withinBound(pt, la[0], la[1]) && Geom.withinBound(pt, lb[0], lb[1])) ? pt : undefined;\n    }\n    static intersectLineWithRay2D(line, ray) {\n        let pt = Line.intersectRay2D(line, ray);\n        return (pt && Geom.withinBound(pt, line[0], line[1])) ? pt : undefined;\n    }\n    static intersectPolygon2D(lineOrRay, poly, sourceIsRay = false) {\n        let fn = sourceIsRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n        let pts = new Group();\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let next = (i === len - 1) ? 0 : i + 1;\n            let d = fn([poly[i], poly[next]], lineOrRay);\n            if (d)\n                pts.push(d);\n        }\n        return (pts.length > 0) ? pts : undefined;\n    }\n    static intersectLines2D(lines1, lines2, isRay = false) {\n        let group = new Group();\n        let fn = isRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n        for (let i = 0, len = lines1.length; i < len; i++) {\n            for (let k = 0, lenk = lines2.length; k < lenk; k++) {\n                let _ip = fn(lines1[i], lines2[k]);\n                if (_ip)\n                    group.push(_ip);\n            }\n        }\n        return group;\n    }\n    static intersectGridWithRay2D(ray, gridPt) {\n        let t = Line.intercept(new Pt(ray[0]).subtract(gridPt), new Pt(ray[1]).subtract(gridPt));\n        let g = new Group();\n        if (t && t.xi)\n            g.push(new Pt(gridPt[0] + t.xi, gridPt[1]));\n        if (t && t.yi)\n            g.push(new Pt(gridPt[0], gridPt[1] + t.yi));\n        return g;\n    }\n    static intersectGridWithLine2D(line, gridPt) {\n        let g = Line.intersectGridWithRay2D(line, gridPt);\n        let gg = new Group();\n        for (let i = 0, len = g.length; i < len; i++) {\n            if (Geom.withinBound(g[i], line[0], line[1]))\n                gg.push(g[i]);\n        }\n        return gg;\n    }\n    static intersectRect2D(line, rect) {\n        let box = Geom.boundingBox(Group.fromPtArray(line));\n        if (!Rectangle.hasIntersectRect2D(box, rect))\n            return new Group();\n        return Line.intersectLines2D([line], Rectangle.sides(rect));\n    }\n    static subpoints(line, num) {\n        let pts = new Group();\n        for (let i = 1; i <= num; i++) {\n            pts.push(Geom.interpolate(line[0], line[1], i / (num + 1)));\n        }\n        return pts;\n    }\n    static crop(line, size, index = 0, cropAsCircle = true) {\n        let tdx = (index === 0) ? 1 : 0;\n        let ls = line[tdx].$subtract(line[index]);\n        if (ls[0] === 0 || size[0] === 0)\n            return line[index];\n        if (cropAsCircle) {\n            let d = ls.unit().multiply(size[1]);\n            return line[index].$add(d);\n        }\n        else {\n            let rect = Rectangle.fromCenter(line[index], size);\n            let sides = Rectangle.sides(rect);\n            let sideIdx = 0;\n            if (Math.abs(ls[1] / ls[0]) > Math.abs(size[1] / size[0])) {\n                sideIdx = (ls[1] < 0) ? 0 : 2;\n            }\n            else {\n                sideIdx = (ls[0] < 0) ? 3 : 1;\n            }\n            return Line.intersectRay2D(sides[sideIdx], line);\n        }\n    }\n    static marker(line, size, graphic = (\"arrow\" || \"line\"), atTail = true) {\n        let h = atTail ? 0 : 1;\n        let t = atTail ? 1 : 0;\n        let unit = line[h].$subtract(line[t]);\n        if (unit.magnitudeSq() === 0)\n            return new Group();\n        unit.unit();\n        let ps = Geom.perpendicular(unit).multiply(size[0]).add(line[t]);\n        if (graphic == \"arrow\") {\n            ps.add(unit.$multiply(size[1]));\n            return new Group(line[t], ps[0], ps[1]);\n        }\n        else {\n            return new Group(ps[0], ps[1]);\n        }\n    }\n    static toRect(line) {\n        return new Group(line[0].$min(line[1]), line[0].$max(line[1]));\n    }\n}\nexport class Rectangle {\n    static from(topLeft, widthOrSize, height) {\n        return Rectangle.fromTopLeft(topLeft, widthOrSize, height);\n    }\n    static fromTopLeft(topLeft, widthOrSize, height) {\n        let size = (typeof widthOrSize == \"number\") ? [widthOrSize, (height || widthOrSize)] : widthOrSize;\n        return new Group(new Pt(topLeft), new Pt(topLeft).add(size));\n    }\n    static fromCenter(center, widthOrSize, height) {\n        let half = (typeof widthOrSize == \"number\") ? [widthOrSize / 2, (height || widthOrSize) / 2] : new Pt(widthOrSize).divide(2);\n        return new Group(new Pt(center).subtract(half), new Pt(center).add(half));\n    }\n    static toCircle(pts, within = true) {\n        return Circle.fromRect(pts, within);\n    }\n    static toSquare(pts, enclose = false) {\n        let s = Rectangle.size(pts);\n        let m = (enclose) ? s.maxValue().value : s.minValue().value;\n        return Rectangle.fromCenter(Rectangle.center(pts), m, m);\n    }\n    static size(pts) {\n        return pts[0].$max(pts[1]).subtract(pts[0].$min(pts[1]));\n    }\n    static center(pts) {\n        let min = pts[0].$min(pts[1]);\n        let max = pts[0].$max(pts[1]);\n        return min.add(max.$subtract(min).divide(2));\n    }\n    static corners(rect) {\n        let p0 = rect[0].$min(rect[1]);\n        let p2 = rect[0].$max(rect[1]);\n        return new Group(p0, new Pt(p2.x, p0.y), p2, new Pt(p0.x, p2.y));\n    }\n    static sides(rect) {\n        let [p0, p1, p2, p3] = Rectangle.corners(rect);\n        return [\n            new Group(p0, p1), new Group(p1, p2),\n            new Group(p2, p3), new Group(p3, p0)\n        ];\n    }\n    static boundingBox(rects) {\n        let merged = Util.flatten(rects, false);\n        let min = Pt.make(2, Number.MAX_VALUE);\n        let max = Pt.make(2, Number.MIN_VALUE);\n        for (let i = 0, len = merged.length; i < len; i++) {\n            for (let k = 0; k < 2; k++) {\n                min[k] = Math.min(min[k], merged[i][k]);\n                max[k] = Math.max(max[k], merged[i][k]);\n            }\n        }\n        return new Group(min, max);\n    }\n    static polygon(rect) {\n        return Rectangle.corners(rect);\n    }\n    static quadrants(rect, center) {\n        let corners = Rectangle.corners(rect);\n        let _center = (center != undefined) ? new Pt(center) : Rectangle.center(rect);\n        return corners.map((c) => new Group(c, _center).boundingBox());\n    }\n    static halves(rect, ratio = 0.5, asRows = false) {\n        let min = rect[0].$min(rect[1]);\n        let max = rect[0].$max(rect[1]);\n        let mid = (asRows) ? Num.lerp(min[1], max[1], ratio) : Num.lerp(min[0], max[0], ratio);\n        return (asRows)\n            ? [new Group(min, new Pt(max[0], mid)), new Group(new Pt(min[0], mid), max)]\n            : [new Group(min, new Pt(mid, max[1])), new Group(new Pt(mid, min[1]), max)];\n    }\n    static withinBound(rect, pt) {\n        return Geom.withinBound(pt, rect[0], rect[1]);\n    }\n    static hasIntersectRect2D(rect1, rect2, resetBoundingBox = false) {\n        if (resetBoundingBox) {\n            rect1 = Geom.boundingBox(rect1);\n            rect2 = Geom.boundingBox(rect2);\n        }\n        if (rect1[0][0] > rect2[1][0] || rect2[0][0] > rect1[1][0])\n            return false;\n        if (rect1[0][1] > rect2[1][1] || rect2[0][1] > rect1[1][1])\n            return false;\n        return true;\n    }\n    static intersectRect2D(rect1, rect2) {\n        if (!Rectangle.hasIntersectRect2D(rect1, rect2))\n            return new Group();\n        return Line.intersectLines2D(Rectangle.sides(rect1), Rectangle.sides(rect2));\n    }\n}\nexport class Circle {\n    static fromRect(pts, enclose = false) {\n        let r = 0;\n        let min = r = Rectangle.size(pts).minValue().value / 2;\n        if (enclose) {\n            let max = Rectangle.size(pts).maxValue().value / 2;\n            r = Math.sqrt(min * min + max * max);\n        }\n        else {\n            r = min;\n        }\n        return new Group(Rectangle.center(pts), new Pt(r, r));\n    }\n    static fromCenter(pt, radius) {\n        return new Group(new Pt(pt), new Pt(radius, radius));\n    }\n    static withinBound(pts, pt, threshold = 0) {\n        let d = pts[0].$subtract(pt);\n        return d.dot(d) + threshold < pts[1].x * pts[1].x;\n    }\n    static intersectRay2D(pts, ray) {\n        let d = ray[0].$subtract(ray[1]);\n        let f = pts[0].$subtract(ray[0]);\n        let a = d.dot(d);\n        let b = f.dot(d);\n        let c = f.dot(f) - pts[1].x * pts[1].x;\n        let p = b / a;\n        let q = c / a;\n        let disc = p * p - q;\n        if (disc < 0) {\n            return new Group();\n        }\n        else {\n            let discSqrt = Math.sqrt(disc);\n            let t1 = -p + discSqrt;\n            let p1 = ray[0].$subtract(d.$multiply(t1));\n            if (disc === 0)\n                return new Group(p1);\n            let t2 = -p - discSqrt;\n            let p2 = ray[0].$subtract(d.$multiply(t2));\n            return new Group(p1, p2);\n        }\n    }\n    static intersectLine2D(pts, line) {\n        let ps = Circle.intersectRay2D(pts, line);\n        let g = new Group();\n        if (ps.length > 0) {\n            for (let i = 0, len = ps.length; i < len; i++) {\n                if (Rectangle.withinBound(line, ps[i]))\n                    g.push(ps[i]);\n            }\n        }\n        return g;\n    }\n    static intersectCircle2D(pts, circle) {\n        let dv = circle[0].$subtract(pts[0]);\n        let dr2 = dv.magnitudeSq();\n        let dr = Math.sqrt(dr2);\n        let ar = pts[1].x;\n        let br = circle[1].x;\n        let ar2 = ar * ar;\n        let br2 = br * br;\n        if (dr > ar + br) {\n            return new Group();\n        }\n        else if (dr < Math.abs(ar - br)) {\n            return new Group(pts[0].clone());\n        }\n        else {\n            let a = (ar2 - br2 + dr2) / (2 * dr);\n            let h = Math.sqrt(ar2 - a * a);\n            let p = dv.$multiply(a / dr).add(pts[0]);\n            return new Group(new Pt(p.x + h * dv.y / dr, p.y - h * dv.x / dr), new Pt(p.x - h * dv.y / dr, p.y + h * dv.x / dr));\n        }\n    }\n    static intersectRect2D(pts, rect) {\n        let sides = Rectangle.sides(rect);\n        let g = [];\n        for (let i = 0, len = sides.length; i < len; i++) {\n            let ps = Circle.intersectLine2D(pts, sides[i]);\n            if (ps.length > 0)\n                g.push(ps);\n        }\n        return Util.flatten(g);\n    }\n    static toRect(pts, within = false) {\n        let r = pts[1][0];\n        if (within) {\n            let half = Math.sqrt(r * r) / 2;\n            return new Group(pts[0].$subtract(half), pts[0].$add(half));\n        }\n        else {\n            return new Group(pts[0].$subtract(r), pts[0].$add(r));\n        }\n    }\n    static toTriangle(pts, within = true) {\n        if (within) {\n            let ang = -Math.PI / 2;\n            let inc = Math.PI * 2 / 3;\n            let g = new Group();\n            for (let i = 0; i < 3; i++) {\n                g.push(pts[0].clone().toAngle(ang, pts[1][0], true));\n                ang += inc;\n            }\n            return g;\n        }\n        else {\n            return Triangle.fromCenter(pts[0], pts[1][0]);\n        }\n    }\n}\nexport class Triangle {\n    static fromRect(rect) {\n        let top = rect[0].$add(rect[1]).divide(2);\n        top.y = rect[0][1];\n        let left = rect[1].clone();\n        left.x = rect[0][0];\n        return new Group(top, rect[1].clone(), left);\n    }\n    static fromCircle(circle) {\n        return Circle.toTriangle(circle, true);\n    }\n    static fromCenter(pt, size) {\n        return Triangle.fromCircle(Circle.fromCenter(pt, size));\n    }\n    static medial(pts) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        return Polygon.midpoints(pts, true);\n    }\n    static oppositeSide(pts, index) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        if (index === 0) {\n            return Group.fromPtArray([pts[1], pts[2]]);\n        }\n        else if (index === 1) {\n            return Group.fromPtArray([pts[0], pts[2]]);\n        }\n        else {\n            return Group.fromPtArray([pts[0], pts[1]]);\n        }\n    }\n    static altitude(pts, index) {\n        let opp = Triangle.oppositeSide(pts, index);\n        if (opp.length > 1) {\n            return new Group(pts[index], Line.perpendicularFromPt(opp, pts[index]));\n        }\n        else {\n            return new Group();\n        }\n    }\n    static orthocenter(pts) {\n        if (pts.length < 3)\n            return _errorLength(undefined, 3);\n        let a = Triangle.altitude(pts, 0);\n        let b = Triangle.altitude(pts, 1);\n        return Line.intersectRay2D(a, b);\n    }\n    static incenter(pts) {\n        if (pts.length < 3)\n            return _errorLength(undefined, 3);\n        let a = Polygon.bisector(pts, 0).add(pts[0]);\n        let b = Polygon.bisector(pts, 1).add(pts[1]);\n        return Line.intersectRay2D(new Group(pts[0], a), new Group(pts[1], b));\n    }\n    static incircle(pts, center) {\n        let c = (center) ? center : Triangle.incenter(pts);\n        let area = Polygon.area(pts);\n        let perim = Polygon.perimeter(pts, true);\n        let r = 2 * area / perim.total;\n        return Circle.fromCenter(c, r);\n    }\n    static circumcenter(pts) {\n        let md = Triangle.medial(pts);\n        let a = [md[0], Geom.perpendicular(pts[0].$subtract(md[0])).p1.$add(md[0])];\n        let b = [md[1], Geom.perpendicular(pts[1].$subtract(md[1])).p1.$add(md[1])];\n        return Line.intersectRay2D(a, b);\n    }\n    static circumcircle(pts, center) {\n        let c = (center) ? center : Triangle.circumcenter(pts);\n        let r = pts[0].$subtract(c).magnitude();\n        return Circle.fromCenter(c, r);\n    }\n}\nexport class Polygon {\n    static centroid(pts) {\n        return Geom.centroid(pts);\n    }\n    static rectangle(center, widthOrSize, height) {\n        return Rectangle.corners(Rectangle.fromCenter(center, widthOrSize, height));\n    }\n    static fromCenter(center, radius, sides) {\n        let g = new Group();\n        for (let i = 0; i < sides; i++) {\n            let ang = Math.PI * 2 * i / sides;\n            g.push(new Pt(Math.cos(ang) * radius, Math.sin(ang) * radius).add(center));\n        }\n        return g;\n    }\n    static lineAt(pts, idx) {\n        if (idx < 0 || idx >= pts.length)\n            throw new Error(\"index out of the Polygon's range\");\n        return new Group(pts[idx], (idx === pts.length - 1) ? pts[0] : pts[idx + 1]);\n    }\n    static lines(pts, closePath = true) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        let sp = Util.split(pts, 2, 1);\n        if (closePath)\n            sp.push(new Group(pts[pts.length - 1], pts[0]));\n        return sp.map((g) => g);\n    }\n    static midpoints(pts, closePath = false, t = 0.5) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        let sides = Polygon.lines(pts, closePath);\n        let mids = sides.map((s) => Geom.interpolate(s[0], s[1], t));\n        return mids;\n    }\n    static adjacentSides(pts, index, closePath = false) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        if (index < 0 || index >= pts.length)\n            return _errorOutofBound(new Group(), index);\n        let gs = [];\n        let left = index - 1;\n        if (closePath && left < 0)\n            left = pts.length - 1;\n        if (left >= 0)\n            gs.push(new Group(pts[index], pts[left]));\n        let right = index + 1;\n        if (closePath && right > pts.length - 1)\n            right = 0;\n        if (right <= pts.length - 1)\n            gs.push(new Group(pts[index], pts[right]));\n        return gs;\n    }\n    static bisector(pts, index) {\n        let sides = Polygon.adjacentSides(pts, index, true);\n        if (sides.length >= 2) {\n            let a = sides[0][1].$subtract(sides[0][0]).unit();\n            let b = sides[1][1].$subtract(sides[1][0]).unit();\n            return a.add(b).divide(2);\n        }\n        else {\n            return undefined;\n        }\n    }\n    static perimeter(pts, closePath = false) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        let lines = Polygon.lines(pts, closePath);\n        let mag = 0;\n        let p = Pt.make(lines.length, 0);\n        for (let i = 0, len = lines.length; i < len; i++) {\n            let m = Line.magnitude(lines[i]);\n            mag += m;\n            p[i] = m;\n        }\n        return {\n            total: mag,\n            segments: p\n        };\n    }\n    static area(pts) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        let det = (a, b) => a[0] * b[1] - a[1] * b[0];\n        let area = 0;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (i < pts.length - 1) {\n                area += det(pts[i], pts[i + 1]);\n            }\n            else {\n                area += det(pts[i], pts[0]);\n            }\n        }\n        return Math.abs(area / 2);\n    }\n    static convexHull(pts, sorted = false) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        if (!sorted) {\n            pts = pts.slice();\n            pts.sort((a, b) => a[0] - b[0]);\n        }\n        let left = (a, b, c) => {\n            return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]) > 0;\n        };\n        let dq = [];\n        let bot = pts.length - 2;\n        let top = bot + 3;\n        dq[bot] = pts[2];\n        dq[top] = pts[2];\n        if (left(pts[0], pts[1], pts[2])) {\n            dq[bot + 1] = pts[0];\n            dq[bot + 2] = pts[1];\n        }\n        else {\n            dq[bot + 1] = pts[1];\n            dq[bot + 2] = pts[0];\n        }\n        for (let i = 3, len = pts.length; i < len; i++) {\n            let pt = pts[i];\n            if (left(dq[bot], dq[bot + 1], pt) && left(dq[top - 1], dq[top], pt)) {\n                continue;\n            }\n            while (!left(dq[bot], dq[bot + 1], pt)) {\n                bot += 1;\n            }\n            bot -= 1;\n            dq[bot] = pt;\n            while (!left(dq[top - 1], dq[top], pt)) {\n                top -= 1;\n            }\n            top += 1;\n            dq[top] = pt;\n        }\n        let hull = new Group();\n        for (let h = 0; h < (top - bot); h++) {\n            hull.push(dq[bot + h]);\n        }\n        return hull;\n    }\n    static network(pts, originIndex = 0) {\n        let g = [];\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (i != originIndex)\n                g.push(new Group(pts[originIndex], pts[i]));\n        }\n        return g;\n    }\n    static nearestPt(pts, pt) {\n        let _near = Number.MAX_VALUE;\n        let _item = -1;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let d = pts[i].$subtract(pt).magnitudeSq();\n            if (d < _near) {\n                _near = d;\n                _item = i;\n            }\n        }\n        return _item;\n    }\n    static projectAxis(poly, unitAxis) {\n        let dot = unitAxis.dot(poly[0]);\n        let d = new Pt(dot, dot);\n        for (let n = 1, len = poly.length; n < len; n++) {\n            dot = unitAxis.dot(poly[n]);\n            d = new Pt(Math.min(dot, d[0]), Math.max(dot, d[1]));\n        }\n        return d;\n    }\n    static _axisOverlap(poly1, poly2, unitAxis) {\n        let pa = Polygon.projectAxis(poly1, unitAxis);\n        let pb = Polygon.projectAxis(poly2, unitAxis);\n        return (pa[0] < pb[0]) ? pb[0] - pa[1] : pa[0] - pb[1];\n    }\n    static hasIntersectPoint(poly, pt) {\n        let c = false;\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let ln = Polygon.lineAt(poly, i);\n            if (((ln[0][1] > pt[1]) != (ln[1][1] > pt[1])) &&\n                (pt[0] < (ln[1][0] - ln[0][0]) * (pt[1] - ln[0][1]) / (ln[1][1] - ln[0][1]) + ln[0][0])) {\n                c = !c;\n            }\n        }\n        return c;\n    }\n    static hasIntersectCircle(poly, circle) {\n        let info = {\n            which: -1,\n            dist: 0,\n            normal: null,\n            edge: null,\n            vertex: null,\n        };\n        let c = circle[0];\n        let r = circle[1][0];\n        let minDist = Number.MAX_SAFE_INTEGER;\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let edge = Polygon.lineAt(poly, i);\n            let axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n            let poly2 = new Group(c.$add(axis.$multiply(r)), c.$subtract(axis.$multiply(r)));\n            let dist = Polygon._axisOverlap(poly, poly2, axis);\n            if (dist > 0) {\n                return null;\n            }\n            else if (Math.abs(dist) < minDist) {\n                let check = Rectangle.withinBound(edge, Line.perpendicularFromPt(edge, c)) || Circle.intersectLine2D(circle, edge).length > 0;\n                if (check) {\n                    info.edge = edge;\n                    info.normal = axis;\n                    minDist = Math.abs(dist);\n                    info.which = i;\n                }\n            }\n        }\n        if (!info.edge)\n            return null;\n        let dir = c.$subtract(Polygon.centroid(poly)).dot(info.normal);\n        if (dir < 0)\n            info.normal.multiply(-1);\n        info.dist = minDist;\n        info.vertex = c;\n        return info;\n    }\n    static hasIntersectPolygon(poly1, poly2) {\n        let info = {\n            which: -1,\n            dist: 0,\n            normal: new Pt(),\n            edge: new Group(),\n            vertex: new Pt()\n        };\n        let minDist = Number.MAX_SAFE_INTEGER;\n        for (let i = 0, plen = (poly1.length + poly2.length); i < plen; i++) {\n            let edge = (i < poly1.length) ? Polygon.lineAt(poly1, i) : Polygon.lineAt(poly2, i - poly1.length);\n            let axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n            let dist = Polygon._axisOverlap(poly1, poly2, axis);\n            if (dist > 0) {\n                return null;\n            }\n            else if (Math.abs(dist) < minDist) {\n                info.edge = edge;\n                info.normal = axis;\n                minDist = Math.abs(dist);\n                info.which = (i < poly1.length) ? 0 : 1;\n            }\n        }\n        info.dist = minDist;\n        let b1 = (info.which === 0) ? poly2 : poly1;\n        let b2 = (info.which === 0) ? poly1 : poly2;\n        let c1 = Polygon.centroid(b1);\n        let c2 = Polygon.centroid(b2);\n        let dir = c1.$subtract(c2).dot(info.normal);\n        if (dir < 0)\n            info.normal.multiply(-1);\n        let smallest = Number.MAX_SAFE_INTEGER;\n        for (let i = 0, len = b1.length; i < len; i++) {\n            let d = info.normal.dot(b1[i].$subtract(c2));\n            if (d < smallest) {\n                smallest = d;\n                info.vertex = b1[i];\n            }\n        }\n        return info;\n    }\n    static intersectPolygon2D(poly1, poly2) {\n        let lp = Polygon.lines(poly1);\n        let g = [];\n        for (let i = 0, len = lp.length; i < len; i++) {\n            let ins = Line.intersectPolygon2D(lp[i], poly2, false);\n            if (ins)\n                g.push(ins);\n        }\n        return Util.flatten(g, true);\n    }\n    static toRects(polys) {\n        let boxes = polys.map((g) => Geom.boundingBox(g));\n        let merged = Util.flatten(boxes, false);\n        boxes.unshift(Geom.boundingBox(merged));\n        return boxes;\n    }\n}\nexport class Curve {\n    static getSteps(steps) {\n        let ts = new Group();\n        for (let i = 0; i <= steps; i++) {\n            let t = i / steps;\n            ts.push(new Pt(t * t * t, t * t, t, 1));\n        }\n        return ts;\n    }\n    static controlPoints(pts, index = 0, copyStart = false) {\n        if (index > pts.length - 1)\n            return new Group();\n        let _index = (i) => (i < pts.length - 1) ? i : pts.length - 1;\n        let p0 = pts[index];\n        index = (copyStart) ? index : index + 1;\n        return new Group(p0, pts[_index(index++)], pts[_index(index++)], pts[_index(index++)]);\n    }\n    static _calcPt(ctrls, params) {\n        let x = ctrls.reduce((a, c, i) => a + c.x * params[i], 0);\n        let y = ctrls.reduce((a, c, i) => a + c.y * params[i], 0);\n        if (ctrls[0].length > 2) {\n            let z = ctrls.reduce((a, c, i) => a + c.z * params[i], 0);\n            return new Pt(x, y, z);\n        }\n        return new Pt(x, y);\n    }\n    static catmullRom(pts, steps = 10) {\n        if (pts.length < 2)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let c = Curve.controlPoints(pts, 0, true);\n        for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.catmullRomStep(ts[i], c));\n        }\n        let k = 0;\n        while (k < pts.length - 2) {\n            let cp = Curve.controlPoints(pts, k);\n            if (cp.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.catmullRomStep(ts[i], cp));\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    static catmullRomStep(step, ctrls) {\n        let m = new Group(new Pt(-0.5, 1, -0.5, 0), new Pt(1.5, -2.5, 0, 1), new Pt(-1.5, 2, 0.5, 0), new Pt(0.5, -0.5, 0, 0));\n        return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n    static cardinal(pts, steps = 10, tension = 0.5) {\n        if (pts.length < 2)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let c = Curve.controlPoints(pts, 0, true);\n        for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.cardinalStep(ts[i], c, tension));\n        }\n        let k = 0;\n        while (k < pts.length - 2) {\n            let cp = Curve.controlPoints(pts, k);\n            if (cp.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.cardinalStep(ts[i], cp, tension));\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    static cardinalStep(step, ctrls, tension = 0.5) {\n        let m = new Group(new Pt(-1, 2, -1, 0), new Pt(-1, 1, 0, 0), new Pt(1, -2, 1, 0), new Pt(1, -1, 0, 0));\n        let h = Mat.multiply([step], m, true)[0].multiply(tension);\n        let h2 = (2 * step[0] - 3 * step[1] + 1);\n        let h3 = -2 * step[0] + 3 * step[1];\n        let pt = Curve._calcPt(ctrls, h);\n        pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n        pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n        if (pt.length > 2)\n            pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n        return pt;\n    }\n    static bezier(pts, steps = 10) {\n        if (pts.length < 4)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let k = 0;\n        while (k < pts.length - 3) {\n            let c = Curve.controlPoints(pts, k);\n            if (c.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.bezierStep(ts[i], c));\n                }\n                k += 3;\n            }\n        }\n        return ps;\n    }\n    static bezierStep(step, ctrls) {\n        let m = new Group(new Pt(-1, 3, -3, 1), new Pt(3, -6, 3, 0), new Pt(-3, 3, 0, 0), new Pt(1, 0, 0, 0));\n        return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n    static bspline(pts, steps = 10, tension = 1) {\n        if (pts.length < 2)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let k = 0;\n        while (k < pts.length - 3) {\n            let c = Curve.controlPoints(pts, k);\n            if (c.length > 0) {\n                if (tension !== 1) {\n                    for (let i = 0; i <= steps; i++) {\n                        ps.push(Curve.bsplineTensionStep(ts[i], c, tension));\n                    }\n                }\n                else {\n                    for (let i = 0; i <= steps; i++) {\n                        ps.push(Curve.bsplineStep(ts[i], c));\n                    }\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    static bsplineStep(step, ctrls) {\n        let m = new Group(new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt(0.5, -1, 0, 0.6666666666666666), new Pt(-0.5, 0.5, 0.5, 0.16666666666666666), new Pt(0.16666666666666666, 0, 0, 0));\n        return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n    static bsplineTensionStep(step, ctrls, tension = 1) {\n        let m = new Group(new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt(-1.5, 2, 0, -0.3333333333333333), new Pt(1.5, -2.5, 0.5, 0.16666666666666666), new Pt(0.16666666666666666, 0, 0, 0));\n        let h = Mat.multiply([step], m, true)[0].multiply(tension);\n        let h2 = (2 * step[0] - 3 * step[1] + 1);\n        let h3 = -2 * step[0] + 3 * step[1];\n        let pt = Curve._calcPt(ctrls, h);\n        pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n        pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n        if (pt.length > 2)\n            pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n        return pt;\n    }\n}\n//# sourceMappingURL=Op.js.map","import { Const } from \"./Util\";\nimport { Curve } from \"./Op\";\nimport { Pt, Group } from \"./Pt\";\nimport { Vec, Mat } from \"./LinearAlgebra\";\nexport class Num {\n    static equals(a, b, threshold = 0.00001) {\n        return Math.abs(a - b) < threshold;\n    }\n    static lerp(a, b, t) {\n        return (1 - t) * a + t * b;\n    }\n    static clamp(val, min, max) {\n        return Math.max(min, Math.min(max, val));\n    }\n    static boundValue(val, min, max) {\n        let len = Math.abs(max - min);\n        let a = val % len;\n        if (a > max)\n            a -= len;\n        else if (a < min)\n            a += len;\n        return a;\n    }\n    static within(p, a, b) {\n        return p >= Math.min(a, b) && p <= Math.max(a, b);\n    }\n    static randomRange(a, b = 0) {\n        let r = (a > b) ? (a - b) : (b - a);\n        return a + Math.random() * r;\n    }\n    static normalizeValue(n, a, b) {\n        let min = Math.min(a, b);\n        let max = Math.max(a, b);\n        return (n - min) / (max - min);\n    }\n    static sum(pts) {\n        let c = new Pt(pts[0]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            Vec.add(c, pts[i]);\n        }\n        return c;\n    }\n    static average(pts) {\n        return Num.sum(pts).divide(pts.length);\n    }\n    static cycle(t) {\n        return (Math.sin(Math.PI * 2 * t) + 1) / 2;\n    }\n    static mapToRange(n, currA, currB, targetA, targetB) {\n        if (currA == currB)\n            throw new Error(\"[currMin, currMax] must define a range that is not zero\");\n        let min = Math.min(targetA, targetB);\n        let max = Math.max(targetA, targetB);\n        return Num.normalizeValue(n, currA, currB) * (max - min) + min;\n    }\n}\nexport class Geom {\n    static boundAngle(angle) {\n        return Num.boundValue(angle, 0, 360);\n    }\n    static boundRadian(radian) {\n        return Num.boundValue(radian, 0, Const.two_pi);\n    }\n    static toRadian(angle) {\n        return angle * Const.deg_to_rad;\n    }\n    static toDegree(radian) {\n        return radian * Const.rad_to_deg;\n    }\n    static boundingBox(pts) {\n        let minPt = pts.reduce((a, p) => a.$min(p));\n        let maxPt = pts.reduce((a, p) => a.$max(p));\n        return new Group(minPt, maxPt);\n    }\n    static centroid(pts) {\n        return Num.average(pts);\n    }\n    static anchor(pts, ptOrIndex = 0, direction = \"to\") {\n        let method = (direction == \"to\") ? \"subtract\" : \"add\";\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (typeof ptOrIndex == \"number\") {\n                if (ptOrIndex !== i)\n                    pts[i][method](pts[ptOrIndex]);\n            }\n            else {\n                pts[i][method](ptOrIndex);\n            }\n        }\n    }\n    static interpolate(a, b, t = 0.5) {\n        let len = Math.min(a.length, b.length);\n        let d = Pt.make(len);\n        for (let i = 0; i < len; i++) {\n            d[i] = a[i] * (1 - t) + b[i] * t;\n        }\n        return d;\n    }\n    static perpendicular(pt, axis = Const.xy) {\n        let y = axis[1];\n        let x = axis[0];\n        let p = new Pt(pt);\n        let pa = new Pt(p);\n        pa[x] = -p[y];\n        pa[y] = p[x];\n        let pb = new Pt(p);\n        pb[x] = p[y];\n        pb[y] = -p[x];\n        return new Group(pa, pb);\n    }\n    static isPerpendicular(p1, p2) {\n        return new Pt(p1).dot(p2) === 0;\n    }\n    static withinBound(pt, boundPt1, boundPt2) {\n        for (let i = 0, len = Math.min(pt.length, boundPt1.length, boundPt2.length); i < len; i++) {\n            if (!Num.within(pt[i], boundPt1[i], boundPt2[i]))\n                return false;\n        }\n        return true;\n    }\n    static sortEdges(pts) {\n        let bounds = Geom.boundingBox(pts);\n        let center = bounds[1].add(bounds[0]).divide(2);\n        let fn = (a, b) => {\n            if (a.length < 2 || b.length < 2)\n                throw new Error(\"Pt dimension cannot be less than 2\");\n            let da = a.$subtract(center);\n            let db = b.$subtract(center);\n            if (da[0] >= 0 && db[0] < 0)\n                return 1;\n            if (da[0] < 0 && db[0] >= 0)\n                return -1;\n            if (da[0] == 0 && db[0] == 0) {\n                if (da[1] >= 0 || db[1] >= 0)\n                    return (da[1] > db[1]) ? 1 : -1;\n                return (db[1] > da[1]) ? 1 : -1;\n            }\n            let det = da.$cross2D(db);\n            if (det < 0)\n                return 1;\n            if (det > 0)\n                return -1;\n            return (da[0] * da[0] + da[1] * da[1] > db[0] * db[0] + db[1] * db[1]) ? 1 : -1;\n        };\n        return pts.sort(fn);\n    }\n    static scale(ps, scale, anchor) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let scs = (typeof scale == \"number\") ? Pt.make(pts[0].length, scale) : scale;\n        if (!anchor)\n            anchor = Pt.make(pts[0].length, 0);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = pts[i];\n            for (let k = 0, lenP = p.length; k < lenP; k++) {\n                p[k] = (anchor && anchor[k]) ? anchor[k] + (p[k] - anchor[k]) * scs[k] : p[k] * scs[k];\n            }\n        }\n        return Geom;\n    }\n    static rotate2D(ps, angle, anchor, axis) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let fn = (anchor) ? Mat.rotateAt2DMatrix : Mat.rotate2DMatrix;\n        if (!anchor)\n            anchor = Pt.make(pts[0].length, 0);\n        let cos = Math.cos(angle);\n        let sin = Math.sin(angle);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = (axis) ? pts[i].$take(axis) : pts[i];\n            p.to(Mat.transform2D(p, fn(cos, sin, anchor)));\n        }\n        return Geom;\n    }\n    static shear2D(ps, scale, anchor, axis) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let s = (typeof scale == \"number\") ? [scale, scale] : scale;\n        if (!anchor)\n            anchor = Pt.make(pts[0].length, 0);\n        let fn = (anchor) ? Mat.shearAt2DMatrix : Mat.shear2DMatrix;\n        let tanx = Math.tan(s[0]);\n        let tany = Math.tan(s[1]);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = (axis) ? pts[i].$take(axis) : pts[i];\n            p.to(Mat.transform2D(p, fn(tanx, tany, anchor)));\n        }\n        return Geom;\n    }\n    static reflect2D(ps, line, axis) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let mat = Mat.reflectAt2DMatrix(line[0], line[1]);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = (axis) ? pts[i].$take(axis) : pts[i];\n            p.to(Mat.transform2D(p, mat));\n        }\n        return Geom;\n    }\n    static cosTable() {\n        let cos = new Float64Array(360);\n        for (let i = 0; i < 360; i++)\n            cos[i] = Math.cos(i * Math.PI / 180);\n        let find = (rad) => cos[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\n        return { table: cos, cos: find };\n    }\n    static sinTable() {\n        let sin = new Float64Array(360);\n        for (let i = 0; i < 360; i++)\n            sin[i] = Math.sin(i * Math.PI / 180);\n        let find = (rad) => sin[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\n        return { table: sin, sin: find };\n    }\n}\nexport class Shaping {\n    static linear(t, c = 1) {\n        return c * t;\n    }\n    static quadraticIn(t, c = 1) {\n        return c * t * t;\n    }\n    static quadraticOut(t, c = 1) {\n        return -c * t * (t - 2);\n    }\n    static quadraticInOut(t, c = 1) {\n        let dt = t * 2;\n        return (t < 0.5) ? c / 2 * t * t * 4 : -c / 2 * ((dt - 1) * (dt - 3) - 1);\n    }\n    static cubicIn(t, c = 1) {\n        return c * t * t * t;\n    }\n    static cubicOut(t, c = 1) {\n        let dt = t - 1;\n        return c * (dt * dt * dt + 1);\n    }\n    static cubicInOut(t, c = 1) {\n        let dt = t * 2;\n        return (t < 0.5) ? c / 2 * dt * dt * dt : c / 2 * ((dt - 2) * (dt - 2) * (dt - 2) + 2);\n    }\n    static exponentialIn(t, c = 1, p = 0.25) {\n        return c * Math.pow(t, 1 / p);\n    }\n    static exponentialOut(t, c = 1, p = 0.25) {\n        return c * Math.pow(t, p);\n    }\n    static sineIn(t, c = 1) {\n        return -c * Math.cos(t * Const.half_pi) + c;\n    }\n    static sineOut(t, c = 1) {\n        return c * Math.sin(t * Const.half_pi);\n    }\n    static sineInOut(t, c = 1) {\n        return -c / 2 * (Math.cos(Math.PI * t) - 1);\n    }\n    static cosineApprox(t, c = 1) {\n        let t2 = t * t;\n        let t4 = t2 * t2;\n        let t6 = t4 * t2;\n        return c * (4 * t6 / 9 - 17 * t4 / 9 + 22 * t2 / 9);\n    }\n    static circularIn(t, c = 1) {\n        return -c * (Math.sqrt(1 - t * t) - 1);\n    }\n    static circularOut(t, c = 1) {\n        let dt = t - 1;\n        return c * Math.sqrt(1 - dt * dt);\n    }\n    static circularInOut(t, c = 1) {\n        let dt = t * 2;\n        return (t < 0.5) ? -c / 2 * (Math.sqrt(1 - dt * dt) - 1) : c / 2 * (Math.sqrt(1 - (dt - 2) * (dt - 2)) + 1);\n    }\n    static elasticIn(t, c = 1, p = 0.7) {\n        let dt = t - 1;\n        let s = (p / Const.two_pi) * 1.5707963267948966;\n        return c * (-Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p));\n    }\n    static elasticOut(t, c = 1, p = 0.7) {\n        let s = (p / Const.two_pi) * 1.5707963267948966;\n        return c * (Math.pow(2, -10 * t) * Math.sin((t - s) * Const.two_pi / p)) + c;\n    }\n    static elasticInOut(t, c = 1, p = 0.6) {\n        let dt = t * 2;\n        let s = (p / Const.two_pi) * 1.5707963267948966;\n        if (t < 0.5) {\n            dt -= 1;\n            return c * (-0.5 * (Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p)));\n        }\n        else {\n            dt -= 1;\n            return c * (0.5 * (Math.pow(2, -10 * dt) * Math.sin((dt - s) * Const.two_pi / p))) + c;\n        }\n    }\n    static bounceIn(t, c = 1) {\n        return c - Shaping.bounceOut((1 - t), c);\n    }\n    static bounceOut(t, c = 1) {\n        if (t < (1 / 2.75)) {\n            return c * (7.5625 * t * t);\n        }\n        else if (t < (2 / 2.75)) {\n            t -= 1.5 / 2.75;\n            return c * (7.5625 * t * t + 0.75);\n        }\n        else if (t < (2.5 / 2.75)) {\n            t -= 2.25 / 2.75;\n            return c * (7.5625 * t * t + 0.9375);\n        }\n        else {\n            t -= 2.625 / 2.75;\n            return c * (7.5625 * t * t + 0.984375);\n        }\n    }\n    static bounceInOut(t, c = 1) {\n        return (t < 0.5) ? Shaping.bounceIn(t * 2, c) / 2 : Shaping.bounceOut(t * 2 - 1, c) / 2 + c / 2;\n    }\n    static sigmoid(t, c = 1, p = 10) {\n        let d = p * (t - 0.5);\n        return c / (1 + Math.exp(-d));\n    }\n    static logSigmoid(t, c = 1, p = 0.7) {\n        p = Math.max(Const.epsilon, Math.min(1 - Const.epsilon, p));\n        p = 1 / (1 - p);\n        let A = 1 / (1 + Math.exp(((t - 0.5) * p * -2)));\n        let B = 1 / (1 + Math.exp(p));\n        let C = 1 / (1 + Math.exp(-p));\n        return c * (A - B) / (C - B);\n    }\n    static seat(t, c = 1, p = 0.5) {\n        if ((t < 0.5)) {\n            return c * (Math.pow(2 * t, 1 - p)) / 2;\n        }\n        else {\n            return c * (1 - (Math.pow(2 * (1 - t), 1 - p)) / 2);\n        }\n    }\n    static quadraticBezier(t, c = 1, p = [0.05, 0.95]) {\n        let a = (typeof p != \"number\") ? p[0] : p;\n        let b = (typeof p != \"number\") ? p[1] : 0.5;\n        let om2a = 1 - 2 * a;\n        if (om2a === 0) {\n            om2a = Const.epsilon;\n        }\n        let d = (Math.sqrt(a * a + om2a * t) - a) / om2a;\n        return c * ((1 - 2 * b) * (d * d) + (2 * b) * d);\n    }\n    static cubicBezier(t, c = 1, p1 = [0.1, 0.7], p2 = [0.9, 0.2]) {\n        let curve = new Group(new Pt(0, 0), new Pt(p1), new Pt(p2), new Pt(1, 1));\n        return c * Curve.bezierStep(new Pt(t * t * t, t * t, t, 1), Curve.controlPoints(curve)).y;\n    }\n    static quadraticTarget(t, c = 1, p1 = [0.2, 0.35]) {\n        let a = Math.min(1 - Const.epsilon, Math.max(Const.epsilon, p1[0]));\n        let b = Math.min(1, Math.max(0, p1[1]));\n        let A = (1 - b) / (1 - a) - (b / a);\n        let B = (A * (a * a) - b) / a;\n        let y = A * (t * t) - B * t;\n        return c * Math.min(1, Math.max(0, y));\n    }\n    static cliff(t, c = 1, p = 0.5) {\n        return (t > p) ? c : 0;\n    }\n    static step(fn, steps, t, c, ...args) {\n        let s = 1 / steps;\n        let tt = Math.floor(t / s) * s;\n        return fn(tt, c, ...args);\n    }\n}\nexport class Range {\n    constructor(g) {\n        this._dims = 0;\n        this._source = Group.fromPtArray(g);\n        this.calc();\n    }\n    get max() { return this._max.clone(); }\n    get min() { return this._min.clone(); }\n    get magnitude() { return this._mag.clone(); }\n    calc() {\n        if (!this._source)\n            return;\n        let dims = this._source[0].length;\n        this._dims = dims;\n        let max = new Pt(dims);\n        let min = new Pt(dims);\n        let mag = new Pt(dims);\n        for (let i = 0; i < dims; i++) {\n            max[i] = Const.min;\n            min[i] = Const.max;\n            mag[i] = 0;\n            let s = this._source.zipSlice(i);\n            for (let k = 0, len = s.length; k < len; k++) {\n                max[i] = Math.max(max[i], s[k]);\n                min[i] = Math.min(min[i], s[k]);\n                mag[i] = max[i] - min[i];\n            }\n        }\n        this._max = max;\n        this._min = min;\n        this._mag = mag;\n        return this;\n    }\n    mapTo(min, max, exclude) {\n        let target = new Group();\n        for (let i = 0, len = this._source.length; i < len; i++) {\n            let g = this._source[i];\n            let n = new Pt(this._dims);\n            for (let k = 0; k < this._dims; k++) {\n                n[k] = (exclude && exclude[k]) ? g[k] : Num.mapToRange(g[k], this._min[k], this._max[k], min, max);\n            }\n            target.push(n);\n        }\n        return target;\n    }\n    append(g, update = true) {\n        if (g[0].length !== this._dims)\n            throw new Error(`Dimensions don't match. ${this._dims} dimensions in Range and ${g[0].length} provided in parameter. `);\n        this._source = this._source.concat(g);\n        if (update)\n            this.calc();\n        return this;\n    }\n    ticks(count) {\n        let g = new Group();\n        for (let i = 0; i <= count; i++) {\n            let p = new Pt(this._dims);\n            for (let k = 0, len = this._max.length; k < len; k++) {\n                p[k] = Num.lerp(this._min[k], this._max[k], i / count);\n            }\n            g.push(p);\n        }\n        return g;\n    }\n}\n//# sourceMappingURL=Num.js.map","import { Util, Const } from \"./Util\";\nimport { Geom, Num } from \"./Num\";\nimport { Vec, Mat } from \"./LinearAlgebra\";\nexport var PtBaseArray = Float32Array;\nexport class Pt extends PtBaseArray {\n    constructor(...args) {\n        if (args.length === 1 && typeof args[0] == \"number\") {\n            super(args[0]);\n        }\n        else {\n            super((args.length > 0) ? Util.getArgs(args) : [0, 0]);\n        }\n    }\n    static make(dimensions, defaultValue = 0, randomize = false) {\n        let p = new PtBaseArray(dimensions);\n        if (defaultValue)\n            p.fill(defaultValue);\n        if (randomize) {\n            for (let i = 0, len = p.length; i < len; i++) {\n                p[i] = p[i] * Math.random();\n            }\n        }\n        return new Pt(p);\n    }\n    get id() { return this._id; }\n    set id(s) { this._id = s; }\n    get x() { return this[0]; }\n    set x(n) { this[0] = n; }\n    get y() { return this[1]; }\n    set y(n) { this[1] = n; }\n    get z() { return this[2]; }\n    set z(n) { this[2] = n; }\n    get w() { return this[3]; }\n    set w(n) { this[3] = n; }\n    clone() {\n        return new Pt(this);\n    }\n    equals(p, threshold = 0.000001) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            if (Math.abs(this[i] - p[i]) > threshold)\n                return false;\n        }\n        return true;\n    }\n    to(...args) {\n        let p = Util.getArgs(args);\n        for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n            this[i] = p[i];\n        }\n        return this;\n    }\n    $to(...args) {\n        return this.clone().to(...args);\n    }\n    toAngle(radian, magnitude, anchorFromPt = false) {\n        let m = (magnitude != undefined) ? magnitude : this.magnitude();\n        let change = [Math.cos(radian) * m, Math.sin(radian) * m];\n        return (anchorFromPt) ? this.add(change) : this.to(change);\n    }\n    op(fn) {\n        let self = this;\n        return (...params) => {\n            return fn(self, ...params);\n        };\n    }\n    ops(fns) {\n        let _ops = [];\n        for (let i = 0, len = fns.length; i < len; i++) {\n            _ops.push(this.op(fns[i]));\n        }\n        return _ops;\n    }\n    $take(axis) {\n        let p = [];\n        for (let i = 0, len = axis.length; i < len; i++) {\n            p.push(this[axis[i]] || 0);\n        }\n        return new Pt(p);\n    }\n    $concat(...args) {\n        return new Pt(this.toArray().concat(Util.getArgs(args)));\n    }\n    add(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? Vec.add(this, args[0]) : Vec.add(this, Util.getArgs(args));\n        return this;\n    }\n    $add(...args) { return this.clone().add(...args); }\n    subtract(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? Vec.subtract(this, args[0]) : Vec.subtract(this, Util.getArgs(args));\n        return this;\n    }\n    $subtract(...args) { return this.clone().subtract(...args); }\n    multiply(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? Vec.multiply(this, args[0]) : Vec.multiply(this, Util.getArgs(args));\n        return this;\n    }\n    $multiply(...args) { return this.clone().multiply(...args); }\n    divide(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? Vec.divide(this, args[0]) : Vec.divide(this, Util.getArgs(args));\n        return this;\n    }\n    $divide(...args) { return this.clone().divide(...args); }\n    magnitudeSq() { return Vec.dot(this, this); }\n    magnitude() { return Vec.magnitude(this); }\n    unit(magnitude = undefined) {\n        Vec.unit(this, magnitude);\n        return this;\n    }\n    $unit(magnitude = undefined) { return this.clone().unit(magnitude); }\n    dot(...args) { return Vec.dot(this, Util.getArgs(args)); }\n    $cross2D(...args) { return Vec.cross2D(this, Util.getArgs(args)); }\n    $cross(...args) { return Vec.cross(this, Util.getArgs(args)); }\n    $project(...args) {\n        return this.$multiply(this.dot(...args) / this.magnitudeSq());\n    }\n    projectScalar(...args) {\n        return this.dot(...args) / this.magnitude();\n    }\n    abs() {\n        Vec.abs(this);\n        return this;\n    }\n    $abs() {\n        return this.clone().abs();\n    }\n    floor() {\n        Vec.floor(this);\n        return this;\n    }\n    $floor() {\n        return this.clone().floor();\n    }\n    ceil() {\n        Vec.ceil(this);\n        return this;\n    }\n    $ceil() {\n        return this.clone().ceil();\n    }\n    round() {\n        Vec.round(this);\n        return this;\n    }\n    $round() {\n        return this.clone().round();\n    }\n    minValue() {\n        return Vec.min(this);\n    }\n    maxValue() {\n        return Vec.max(this);\n    }\n    $min(...args) {\n        let p = Util.getArgs(args);\n        let m = this.clone();\n        for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n            m[i] = Math.min(this[i], p[i]);\n        }\n        return m;\n    }\n    $max(...args) {\n        let p = Util.getArgs(args);\n        let m = this.clone();\n        for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n            m[i] = Math.max(this[i], p[i]);\n        }\n        return m;\n    }\n    angle(axis = Const.xy) {\n        return Math.atan2(this[axis[1]], this[axis[0]]);\n    }\n    angleBetween(p, axis = Const.xy) {\n        return Geom.boundRadian(this.angle(axis)) - Geom.boundRadian(p.angle(axis));\n    }\n    scale(scale, anchor) {\n        Geom.scale(this, scale, anchor || Pt.make(this.length, 0));\n        return this;\n    }\n    rotate2D(angle, anchor, axis) {\n        Geom.rotate2D(this, angle, anchor || Pt.make(this.length, 0), axis);\n        return this;\n    }\n    shear2D(scale, anchor, axis) {\n        Geom.shear2D(this, scale, anchor || Pt.make(this.length, 0), axis);\n        return this;\n    }\n    reflect2D(line, axis) {\n        Geom.reflect2D(this, line, axis);\n        return this;\n    }\n    toString() {\n        return `Pt(${this.join(\", \")})`;\n    }\n    toArray() {\n        return [].slice.call(this);\n    }\n}\nexport class Group extends Array {\n    constructor(...args) {\n        super(...args);\n    }\n    get id() { return this._id; }\n    set id(s) { this._id = s; }\n    get p1() { return this[0]; }\n    get p2() { return this[1]; }\n    get p3() { return this[2]; }\n    get p4() { return this[3]; }\n    get q1() { return this[this.length - 1]; }\n    get q2() { return this[this.length - 2]; }\n    get q3() { return this[this.length - 3]; }\n    get q4() { return this[this.length - 4]; }\n    clone() {\n        let group = new Group();\n        for (let i = 0, len = this.length; i < len; i++) {\n            group.push(this[i].clone());\n        }\n        return group;\n    }\n    static fromArray(list) {\n        let g = new Group();\n        for (let i = 0, len = list.length; i < len; i++) {\n            let p = (list[i] instanceof Pt) ? list[i] : new Pt(list[i]);\n            g.push(p);\n        }\n        return g;\n    }\n    static fromPtArray(list) {\n        return Group.from(list);\n    }\n    split(chunkSize, stride, loopBack = false) {\n        let sp = Util.split(this, chunkSize, stride, loopBack);\n        return sp;\n    }\n    insert(pts, index = 0) {\n        Group.prototype.splice.apply(this, [index, 0, ...pts]);\n        return this;\n    }\n    remove(index = 0, count = 1) {\n        let param = (index < 0) ? [index * -1 - 1, count] : [index, count];\n        return Group.prototype.splice.apply(this, param);\n    }\n    segments(pts_per_segment = 2, stride = 1, loopBack = false) {\n        return this.split(pts_per_segment, stride, loopBack);\n    }\n    lines() { return this.segments(2, 1); }\n    centroid() {\n        return Geom.centroid(this);\n    }\n    boundingBox() {\n        return Geom.boundingBox(this);\n    }\n    anchorTo(ptOrIndex = 0) { Geom.anchor(this, ptOrIndex, \"to\"); }\n    anchorFrom(ptOrIndex = 0) { Geom.anchor(this, ptOrIndex, \"from\"); }\n    op(fn) {\n        let self = this;\n        return (...params) => {\n            return fn(self, ...params);\n        };\n    }\n    ops(fns) {\n        let _ops = [];\n        for (let i = 0, len = fns.length; i < len; i++) {\n            _ops.push(this.op(fns[i]));\n        }\n        return _ops;\n    }\n    interpolate(t) {\n        t = Num.clamp(t, 0, 1);\n        let chunk = this.length - 1;\n        let tc = 1 / (this.length - 1);\n        let idx = Math.floor(t / tc);\n        return Geom.interpolate(this[idx], this[Math.min(this.length - 1, idx + 1)], (t - idx * tc) * chunk);\n    }\n    moveBy(...args) {\n        return this.add(...args);\n    }\n    moveTo(...args) {\n        let d = new Pt(Util.getArgs(args)).subtract(this[0]);\n        this.moveBy(d);\n        return this;\n    }\n    scale(scale, anchor) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Geom.scale(this[i], scale, anchor || this[0]);\n        }\n        return this;\n    }\n    rotate2D(angle, anchor, axis) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Geom.rotate2D(this[i], angle, anchor || this[0], axis);\n        }\n        return this;\n    }\n    shear2D(scale, anchor, axis) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Geom.shear2D(this[i], scale, anchor || this[0], axis);\n        }\n        return this;\n    }\n    reflect2D(line, axis) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Geom.reflect2D(this[i], line, axis);\n        }\n        return this;\n    }\n    sortByDimension(dim, desc = false) {\n        return this.sort((a, b) => (desc) ? b[dim] - a[dim] : a[dim] - b[dim]);\n    }\n    forEachPt(ptFn, ...args) {\n        if (!this[0][ptFn]) {\n            Util.warn(`${ptFn} is not a function of Pt`);\n            return this;\n        }\n        for (let i = 0, len = this.length; i < len; i++) {\n            this[i] = this[i][ptFn](...args);\n        }\n        return this;\n    }\n    add(...args) {\n        return this.forEachPt(\"add\", ...args);\n    }\n    subtract(...args) {\n        return this.forEachPt(\"subtract\", ...args);\n    }\n    multiply(...args) {\n        return this.forEachPt(\"multiply\", ...args);\n    }\n    divide(...args) {\n        return this.forEachPt(\"divide\", ...args);\n    }\n    $matrixAdd(g) {\n        return Mat.add(this, g);\n    }\n    $matrixMultiply(g, transposed = false, elementwise = false) {\n        return Mat.multiply(this, g, transposed, elementwise);\n    }\n    zipSlice(index, defaultValue = false) {\n        return Mat.zipSlice(this, index, defaultValue);\n    }\n    $zip(defaultValue = undefined, useLongest = false) {\n        return Mat.zip(this, defaultValue, useLongest);\n    }\n    toString() {\n        return \"Group[ \" + this.reduce((p, c) => p + c.toString() + \" \", \"\") + \" ]\";\n    }\n}\nexport class Bound extends Group {\n    constructor(...args) {\n        super(...args);\n        this._center = new Pt();\n        this._size = new Pt();\n        this._topLeft = new Pt();\n        this._bottomRight = new Pt();\n        this._inited = false;\n        this.init();\n    }\n    static fromBoundingRect(rect) {\n        let b = new Bound(new Pt(rect.left || 0, rect.top || 0), new Pt(rect.right || 0, rect.bottom || 0));\n        if (rect.width && rect.height)\n            b.size = new Pt(rect.width, rect.height);\n        return b;\n    }\n    static fromGroup(g) {\n        if (g.length < 2)\n            throw new Error(\"Cannot create a Bound from a group that has less than 2 Pt\");\n        return new Bound(g[0], g[g.length - 1]);\n    }\n    init() {\n        if (this.p1) {\n            this._size = this.p1.clone();\n            this._inited = true;\n        }\n        if (this.p1 && this.p2) {\n            let a = this.p1;\n            let b = this.p2;\n            this.topLeft = a.$min(b);\n            this._bottomRight = a.$max(b);\n            this._updateSize();\n            this._inited = true;\n        }\n    }\n    clone() {\n        return new Bound(this._topLeft.clone(), this._bottomRight.clone());\n    }\n    _updateSize() {\n        this._size = this._bottomRight.$subtract(this._topLeft).abs();\n        this._updateCenter();\n    }\n    _updateCenter() {\n        this._center = this._size.$multiply(0.5).add(this._topLeft);\n    }\n    _updatePosFromTop() {\n        this._bottomRight = this._topLeft.$add(this._size);\n        this._updateCenter();\n    }\n    _updatePosFromBottom() {\n        this._topLeft = this._bottomRight.$subtract(this._size);\n        this._updateCenter();\n    }\n    _updatePosFromCenter() {\n        let half = this._size.$multiply(0.5);\n        this._topLeft = this._center.$subtract(half);\n        this._bottomRight = this._center.$add(half);\n    }\n    get size() { return new Pt(this._size); }\n    set size(p) {\n        this._size = new Pt(p);\n        this._updatePosFromTop();\n    }\n    get center() { return new Pt(this._center); }\n    set center(p) {\n        this._center = new Pt(p);\n        this._updatePosFromCenter();\n    }\n    get topLeft() { return new Pt(this._topLeft); }\n    set topLeft(p) {\n        this._topLeft = new Pt(p);\n        this[0] = this._topLeft;\n        this._updateSize();\n    }\n    get bottomRight() { return new Pt(this._bottomRight); }\n    set bottomRight(p) {\n        this._bottomRight = new Pt(p);\n        this[1] = this._bottomRight;\n        this._updateSize();\n    }\n    get width() { return (this._size.length > 0) ? this._size.x : 0; }\n    set width(w) {\n        this._size.x = w;\n        this._updatePosFromTop();\n    }\n    get height() { return (this._size.length > 1) ? this._size.y : 0; }\n    set height(h) {\n        this._size.y = h;\n        this._updatePosFromTop();\n    }\n    get depth() { return (this._size.length > 2) ? this._size.z : 0; }\n    set depth(d) {\n        this._size.z = d;\n        this._updatePosFromTop();\n    }\n    get x() { return this.topLeft.x; }\n    get y() { return this.topLeft.y; }\n    get z() { return this.topLeft.z; }\n    get inited() { return this._inited; }\n    update() {\n        this._topLeft = this[0];\n        this._bottomRight = this[1];\n        this._updateSize();\n        return this;\n    }\n}\n//# sourceMappingURL=Pt.js.map","import { Rectangle, Circle } from \"./Op\";\nexport var UIShape;\n(function (UIShape) {\n    UIShape[UIShape[\"Rectangle\"] = 0] = \"Rectangle\";\n    UIShape[UIShape[\"Circle\"] = 1] = \"Circle\";\n    UIShape[UIShape[\"Polygon\"] = 2] = \"Polygon\";\n    UIShape[UIShape[\"Polyline\"] = 3] = \"Polyline\";\n    UIShape[UIShape[\"Line\"] = 4] = \"Line\";\n})(UIShape || (UIShape = {}));\nexport const UIPointerActions = {\n    up: \"up\", down: \"down\", move: \"move\", drag: \"drag\", drop: \"drop\", over: \"over\", out: \"out\"\n};\nexport class UI {\n    constructor(group, shape, states, id) {\n        this.group = group;\n        this.shape = shape;\n        this._id = id;\n        this._states = states;\n        this._actions = {};\n    }\n    get id() { return this._id; }\n    set id(d) { this._id = d; }\n    state(key) {\n        return this._states[key] || false;\n    }\n    on(key, fn) {\n        this._actions[key] = fn;\n        return this;\n    }\n    off(key) {\n        delete this._actions[key];\n        return this;\n    }\n    listen(key, p) {\n        if (this._actions[key] !== undefined) {\n            if (this._trigger(p)) {\n                this._actions[key](p, this, key);\n                return true;\n            }\n        }\n        return false;\n    }\n    render(fn) {\n        fn(this.group, this._states);\n    }\n    _trigger(p) {\n        let fn = null;\n        if (this.shape === UIShape.Rectangle) {\n            fn = Rectangle.withinBound;\n        }\n        else if (this.shape === UIShape.Circle) {\n            fn = Circle.withinBound;\n        }\n        else if (this.shape === UIShape.Polygon) {\n            fn = Rectangle.withinBound;\n        }\n        else {\n            return false;\n        }\n        return fn(this.group, p);\n    }\n}\nexport class UIButton extends UI {\n    constructor(group, shape, states, id) {\n        super(group, shape, states, id);\n        this._clicks = 0;\n    }\n    get clicks() { return this._clicks; }\n    onClick(fn) {\n        this._clicks++;\n        this.on(UIPointerActions.up, fn);\n    }\n    onHover(over, out) {\n        this.on(UIPointerActions.over, over);\n        this.on(UIPointerActions.out, out);\n    }\n}\n//# sourceMappingURL=UI.js.map","import { Pt, Bound } from \"./Pt\";\nimport { UIPointerActions as UIA } from \"./UI\";\nexport class Space {\n    constructor() {\n        this.id = \"space\";\n        this.bound = new Bound();\n        this._time = { prev: 0, diff: 0, end: -1 };\n        this.players = {};\n        this.playerCount = 0;\n        this._animID = -1;\n        this._pause = false;\n        this._refresh = undefined;\n        this._pointer = new Pt();\n        this._isReady = false;\n        this._playing = false;\n    }\n    refresh(b) {\n        this._refresh = b;\n        return this;\n    }\n    add(p) {\n        let player = (typeof p == \"function\") ? { animate: p } : p;\n        let k = this.playerCount++;\n        let pid = this.id + k;\n        this.players[pid] = player;\n        player.animateID = pid;\n        if (player.resize && this.bound.inited)\n            player.resize(this.bound);\n        if (this._refresh === undefined)\n            this._refresh = true;\n        return this;\n    }\n    remove(player) {\n        delete this.players[player.animateID];\n        return this;\n    }\n    removeAll() {\n        this.players = {};\n        return this;\n    }\n    play(time = 0) {\n        this._animID = requestAnimationFrame(this.play.bind(this));\n        if (this._pause)\n            return this;\n        this._time.diff = time - this._time.prev;\n        this._time.prev = time;\n        try {\n            this.playItems(time);\n        }\n        catch (err) {\n            cancelAnimationFrame(this._animID);\n            this._playing = false;\n            throw err;\n        }\n        return this;\n    }\n    replay() {\n        this._time.end = -1;\n        this.play();\n    }\n    playItems(time) {\n        this._playing = true;\n        if (this._refresh)\n            this.clear();\n        if (this._isReady) {\n            for (let k in this.players) {\n                if (this.players[k].animate)\n                    this.players[k].animate(time, this._time.diff, this);\n            }\n        }\n        if (this._time.end >= 0 && time > this._time.end) {\n            cancelAnimationFrame(this._animID);\n            this._playing = false;\n        }\n    }\n    pause(toggle = false) {\n        this._pause = (toggle) ? !this._pause : true;\n        return this;\n    }\n    resume() {\n        this._pause = false;\n        return this;\n    }\n    stop(t = 0) {\n        this._time.end = t;\n        return this;\n    }\n    playOnce(duration = 5000) {\n        this.play();\n        this.stop(duration);\n        return this;\n    }\n    render(context) {\n        if (this._renderFunc)\n            this._renderFunc(context, this);\n        return this;\n    }\n    set customRendering(f) { this._renderFunc = f; }\n    get customRendering() { return this._renderFunc; }\n    get isPlaying() { return this._playing; }\n    get outerBound() { return this.bound.clone(); }\n    get innerBound() { return new Bound(Pt.make(this.size.length, 0), this.size.clone()); }\n    get size() { return this.bound.size.clone(); }\n    get center() { return this.size.divide(2); }\n    get width() { return this.bound.width; }\n    get height() { return this.bound.height; }\n}\nexport class MultiTouchSpace extends Space {\n    constructor() {\n        super(...arguments);\n        this._pressed = false;\n        this._dragged = false;\n        this._hasMouse = false;\n        this._hasTouch = false;\n    }\n    get pointer() {\n        let p = this._pointer.clone();\n        p.id = this._pointer.id;\n        return p;\n    }\n    bindCanvas(evt, callback) {\n        this._canvas.addEventListener(evt, callback);\n    }\n    unbindCanvas(evt, callback) {\n        this._canvas.removeEventListener(evt, callback);\n    }\n    bindMouse(_bind = true) {\n        if (_bind) {\n            this.bindCanvas(\"mousedown\", this._mouseDown.bind(this));\n            this.bindCanvas(\"mouseup\", this._mouseUp.bind(this));\n            this.bindCanvas(\"mouseover\", this._mouseOver.bind(this));\n            this.bindCanvas(\"mouseout\", this._mouseOut.bind(this));\n            this.bindCanvas(\"mousemove\", this._mouseMove.bind(this));\n            this._hasMouse = true;\n        }\n        else {\n            this.unbindCanvas(\"mousedown\", this._mouseDown.bind(this));\n            this.unbindCanvas(\"mouseup\", this._mouseUp.bind(this));\n            this.unbindCanvas(\"mouseover\", this._mouseOver.bind(this));\n            this.unbindCanvas(\"mouseout\", this._mouseOut.bind(this));\n            this.unbindCanvas(\"mousemove\", this._mouseMove.bind(this));\n            this._hasMouse = false;\n        }\n        return this;\n    }\n    bindTouch(_bind = true) {\n        if (_bind) {\n            this.bindCanvas(\"touchstart\", this._mouseDown.bind(this));\n            this.bindCanvas(\"touchend\", this._mouseUp.bind(this));\n            this.bindCanvas(\"touchmove\", this._touchMove.bind(this));\n            this.bindCanvas(\"touchcancel\", this._mouseOut.bind(this));\n            this._hasTouch = true;\n        }\n        else {\n            this.unbindCanvas(\"touchstart\", this._mouseDown.bind(this));\n            this.unbindCanvas(\"touchend\", this._mouseUp.bind(this));\n            this.unbindCanvas(\"touchmove\", this._touchMove.bind(this));\n            this.unbindCanvas(\"touchcancel\", this._mouseOut.bind(this));\n            this._hasTouch = false;\n        }\n        return this;\n    }\n    touchesToPoints(evt, which = \"touches\") {\n        if (!evt || !evt[which])\n            return [];\n        let ts = [];\n        for (var i = 0; i < evt[which].length; i++) {\n            let t = evt[which].item(i);\n            ts.push(new Pt(t.pageX - this.bound.topLeft.x, t.pageY - this.bound.topLeft.y));\n        }\n        return ts;\n    }\n    _mouseAction(type, evt) {\n        let px = 0, py = 0;\n        if (evt instanceof MouseEvent) {\n            for (let k in this.players) {\n                if (this.players.hasOwnProperty(k)) {\n                    let v = this.players[k];\n                    px = evt.pageX - this.outerBound.x;\n                    py = evt.pageY - this.outerBound.y;\n                    if (v.action)\n                        v.action(type, px, py, evt);\n                }\n            }\n        }\n        else {\n            for (let k in this.players) {\n                if (this.players.hasOwnProperty(k)) {\n                    let v = this.players[k];\n                    let c = evt.changedTouches && evt.changedTouches.length > 0;\n                    let touch = evt.changedTouches.item(0);\n                    px = (c) ? touch.pageX - this.outerBound.x : 0;\n                    py = (c) ? touch.pageY - this.outerBound.y : 0;\n                    if (v.action)\n                        v.action(type, px, py, evt);\n                }\n            }\n        }\n        if (type) {\n            this._pointer.to(px, py);\n            this._pointer.id = type;\n        }\n    }\n    _mouseDown(evt) {\n        this._mouseAction(UIA.down, evt);\n        this._pressed = true;\n        return false;\n    }\n    _mouseUp(evt) {\n        this._mouseAction(UIA.up, evt);\n        if (this._dragged)\n            this._mouseAction(UIA.down, evt);\n        this._pressed = false;\n        this._dragged = false;\n        return false;\n    }\n    _mouseMove(evt) {\n        this._mouseAction(UIA.move, evt);\n        if (this._pressed) {\n            this._dragged = true;\n            this._mouseAction(UIA.drag, evt);\n        }\n        return false;\n    }\n    _mouseOver(evt) {\n        this._mouseAction(UIA.over, evt);\n        return false;\n    }\n    _mouseOut(evt) {\n        this._mouseAction(UIA.out, evt);\n        if (this._dragged)\n            this._mouseAction(UIA.drop, evt);\n        this._dragged = false;\n        return false;\n    }\n    _touchMove(evt) {\n        this._mouseMove(evt);\n        evt.preventDefault();\n        return false;\n    }\n}\n//# sourceMappingURL=Space.js.map","import { Util } from \"./Util\";\nexport class Form {\n    constructor() {\n        this._ready = false;\n    }\n    get ready() { return this._ready; }\n    static _checkSize(pts, required = 2) {\n        if (pts.length < required) {\n            Util.warn(\"Requires 2 or more Pts in this Group.\");\n            return false;\n        }\n        return true;\n    }\n}\nexport class VisualForm extends Form {\n    constructor() {\n        super(...arguments);\n        this._filled = true;\n        this._stroked = true;\n        this._font = new Font(14, \"sans-serif\");\n    }\n    get filled() { return this._filled; }\n    set filled(b) { this._filled = b; }\n    get stroked() { return this._stroked; }\n    set stroked(b) { this._stroked = b; }\n    get currentFont() { return this._font; }\n    _multiple(groups, shape, ...rest) {\n        if (!groups)\n            return this;\n        for (let i = 0, len = groups.length; i < len; i++) {\n            this[shape](groups[i], ...rest);\n        }\n        return this;\n    }\n    fill(c) {\n        return this;\n    }\n    fillOnly(c) {\n        this.stroke(false);\n        return this.fill(c);\n    }\n    stroke(c, width, linejoin, linecap) {\n        return this;\n    }\n    strokeOnly(c, width, linejoin, linecap) {\n        this.fill(false);\n        return this.stroke(c, width, linejoin, linecap);\n    }\n    points(pts, radius, shape) {\n        if (!pts)\n            return;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            this.point(pts[i], radius, shape);\n        }\n        return this;\n    }\n    circles(groups) {\n        return this._multiple(groups, \"circle\");\n    }\n    squares(groups) {\n        return this._multiple(groups, \"square\");\n    }\n    lines(groups) {\n        return this._multiple(groups, \"line\");\n    }\n    polygons(groups) {\n        return this._multiple(groups, \"polygon\");\n    }\n    rects(groups) {\n        return this._multiple(groups, \"rect\");\n    }\n}\nexport class Font {\n    constructor(size = 12, face = \"sans-serif\", weight = \"\", style = \"\", lineHeight = 1.5) {\n        this.size = size;\n        this.face = face;\n        this.style = style;\n        this.weight = weight;\n        this.lineHeight = lineHeight;\n    }\n    get value() { return `${this.style} ${this.weight} ${this.size}px/${this.lineHeight} ${this.face}`; }\n    toString() { return this.value; }\n}\n//# sourceMappingURL=Form.js.map","import { Pt } from \"./Pt\";\nexport class Typography {\n    static textWidthEstimator(fn, samples = [\"M\", \"n\", \".\"], distribution = [0.06, 0.8, 0.14]) {\n        let m = samples.map(fn);\n        let avg = new Pt(distribution).dot(m);\n        return (str) => str.length * avg;\n    }\n    static truncate(fn, str, width, tail = \"\") {\n        let trim = Math.floor(str.length * Math.min(1, width / fn(str)));\n        if (trim < str.length) {\n            trim = Math.max(0, trim - tail.length);\n            return [str.substr(0, trim) + tail, trim];\n        }\n        else {\n            return [str, str.length];\n        }\n    }\n    static fontSizeToBox(box, ratio = 1, byHeight = true) {\n        let i = byHeight ? 1 : 0;\n        let h = (box[1][i] - box[0][i]);\n        let f = ratio * h;\n        return function (b) {\n            let nh = (b[1][i] - b[0][i]) / h;\n            return f * nh;\n        };\n    }\n    static fontSizeToThreshold(threshold, direction = 0) {\n        return function (defaultSize, val) {\n            let d = defaultSize * val / threshold;\n            if (direction < 0)\n                return Math.min(d, defaultSize);\n            if (direction > 0)\n                return Math.max(d, defaultSize);\n            return d;\n        };\n    }\n}\n//# sourceMappingURL=Typography.js.map","import { MultiTouchSpace } from './Space';\nimport { VisualForm, Font } from \"./Form\";\nimport { Pt, Group, Bound } from \"./Pt\";\nimport { Const } from \"./Util\";\nimport { Typography as Typo } from \"./Typography\";\nimport { Rectangle } from './Op';\nexport class CanvasSpace extends MultiTouchSpace {\n    constructor(elem, callback) {\n        super();\n        this._pixelScale = 1;\n        this._autoResize = true;\n        this._bgcolor = \"#e1e9f0\";\n        this._offscreen = false;\n        this._initialResize = false;\n        var _selector = null;\n        var _existed = false;\n        this.id = \"pt\";\n        if (elem instanceof Element) {\n            _selector = elem;\n            this.id = \"pts_existing_space\";\n        }\n        else {\n            let id = elem;\n            id = (elem[0] === \"#\" || elem[0] === \".\") ? elem : \"#\" + elem;\n            _selector = document.querySelector(id);\n            _existed = true;\n            this.id = id.substr(1);\n        }\n        if (!_selector) {\n            this._container = this._createElement(\"div\", this.id + \"_container\");\n            this._canvas = this._createElement(\"canvas\", this.id);\n            this._container.appendChild(this._canvas);\n            document.body.appendChild(this._container);\n            _existed = false;\n        }\n        else if (_selector.nodeName.toLowerCase() != \"canvas\") {\n            this._container = _selector;\n            this._canvas = this._createElement(\"canvas\", this.id + \"_canvas\");\n            this._container.appendChild(this._canvas);\n            this._initialResize = true;\n        }\n        else {\n            this._canvas = _selector;\n            this._container = _selector.parentElement;\n            this._autoResize = false;\n        }\n        setTimeout(this._ready.bind(this, callback), 100);\n        this._ctx = this._canvas.getContext('2d');\n    }\n    _createElement(elem = \"div\", id) {\n        let d = document.createElement(elem);\n        d.setAttribute(\"id\", id);\n        return d;\n    }\n    _ready(callback) {\n        if (!this._container)\n            throw new Error(`Cannot initiate #${this.id} element`);\n        this._isReady = true;\n        this._resizeHandler(null);\n        this.clear(this._bgcolor);\n        this._canvas.dispatchEvent(new Event(\"ready\"));\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                if (this.players[k].start)\n                    this.players[k].start(this.bound.clone(), this);\n            }\n        }\n        this._pointer = this.center;\n        this._initialResize = false;\n        if (callback)\n            callback(this.bound, this._canvas);\n    }\n    setup(opt) {\n        if (opt.bgcolor)\n            this._bgcolor = opt.bgcolor;\n        this.autoResize = (opt.resize != undefined) ? opt.resize : false;\n        if (opt.retina !== false) {\n            let r1 = window.devicePixelRatio || 1;\n            let r2 = this._ctx.webkitBackingStorePixelRatio || this._ctx.mozBackingStorePixelRatio || this._ctx.msBackingStorePixelRatio || this._ctx.oBackingStorePixelRatio || this._ctx.backingStorePixelRatio || 1;\n            this._pixelScale = Math.max(1, r1 / r2);\n        }\n        if (opt.offscreen) {\n            this._offscreen = true;\n            this._offCanvas = this._createElement(\"canvas\", this.id + \"_offscreen\");\n            this._offCtx = this._offCanvas.getContext('2d');\n        }\n        else {\n            this._offscreen = false;\n        }\n        return this;\n    }\n    set autoResize(auto) {\n        this._autoResize = auto;\n        if (auto) {\n            window.addEventListener('resize', this._resizeHandler.bind(this));\n        }\n        else {\n            window.removeEventListener('resize', this._resizeHandler.bind(this));\n        }\n    }\n    get autoResize() { return this._autoResize; }\n    resize(b, evt) {\n        this.bound = b;\n        this._canvas.width = this.bound.size.x * this._pixelScale;\n        this._canvas.height = this.bound.size.y * this._pixelScale;\n        this._canvas.style.width = Math.floor(this.bound.size.x) + \"px\";\n        this._canvas.style.height = Math.floor(this.bound.size.y) + \"px\";\n        if (this._offscreen) {\n            this._offCanvas.width = this.bound.size.x * this._pixelScale;\n            this._offCanvas.height = this.bound.size.y * this._pixelScale;\n        }\n        if (this._pixelScale != 1) {\n            this._ctx.scale(this._pixelScale, this._pixelScale);\n            this._ctx.translate(0.5, 0.5);\n            if (this._offscreen) {\n                this._offCtx.scale(this._pixelScale, this._pixelScale);\n                this._offCtx.translate(0.5, 0.5);\n            }\n        }\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                let p = this.players[k];\n                if (p.resize)\n                    p.resize(this.bound, evt);\n            }\n        }\n        this.render(this._ctx);\n        if (evt && !this.isPlaying)\n            this.playOnce(0);\n        return this;\n    }\n    _resizeHandler(evt) {\n        let b = (this._autoResize || this._initialResize) ? this._container.getBoundingClientRect() : this._canvas.getBoundingClientRect();\n        if (b) {\n            let box = Bound.fromBoundingRect(b);\n            box.center = box.center.add(window.pageXOffset, window.pageYOffset);\n            this.resize(box, evt);\n        }\n    }\n    set background(bg) { this._bgcolor = bg; }\n    get background() { return this._bgcolor; }\n    get pixelScale() {\n        return this._pixelScale;\n    }\n    get hasOffscreen() {\n        return this._offscreen;\n    }\n    get offscreenCtx() { return this._offCtx; }\n    get offscreenCanvas() { return this._offCanvas; }\n    getForm() { return new CanvasForm(this); }\n    get element() {\n        return this._canvas;\n    }\n    get parent() {\n        return this._container;\n    }\n    get ready() {\n        return this._isReady;\n    }\n    get ctx() { return this._ctx; }\n    clear(bg) {\n        if (bg)\n            this._bgcolor = bg;\n        let lastColor = this._ctx.fillStyle;\n        if (this._bgcolor && this._bgcolor != \"transparent\") {\n            this._ctx.fillStyle = this._bgcolor;\n            this._ctx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n        }\n        else {\n            this._ctx.clearRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n        }\n        this._ctx.fillStyle = lastColor;\n        return this;\n    }\n    clearOffscreen(bg) {\n        if (this._offscreen) {\n            if (bg) {\n                this._offCtx.fillStyle = bg;\n                this._offCtx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n            }\n            else {\n                this._offCtx.clearRect(-1, -1, this._offCanvas.width + 1, this._offCanvas.height + 1);\n            }\n        }\n        return this;\n    }\n    playItems(time) {\n        if (this._isReady) {\n            this._ctx.save();\n            if (this._offscreen)\n                this._offCtx.save();\n            super.playItems(time);\n            this._ctx.restore();\n            if (this._offscreen)\n                this._offCtx.restore();\n            this.render(this._ctx);\n        }\n    }\n}\nexport class CanvasForm extends VisualForm {\n    constructor(space) {\n        super();\n        this._style = {\n            fillStyle: \"#f03\", strokeStyle: \"#fff\",\n            lineWidth: 1, lineJoin: \"bevel\", lineCap: \"butt\",\n        };\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx = this._space.ctx;\n                this._ctx.fillStyle = this._style.fillStyle;\n                this._ctx.strokeStyle = this._style.strokeStyle;\n                this._ctx.lineJoin = \"bevel\";\n                this._ctx.font = this._font.value;\n                this._ready = true;\n            } });\n    }\n    get space() { return this._space; }\n    useOffscreen(off = true, clear = false) {\n        if (clear)\n            this._space.clearOffscreen((typeof clear == \"string\") ? clear : null);\n        this._ctx = (this._space.hasOffscreen && off) ? this._space.offscreenCtx : this._space.ctx;\n        return this;\n    }\n    renderOffscreen(offset = [0, 0]) {\n        if (this._space.hasOffscreen) {\n            this._space.ctx.drawImage(this._space.offscreenCanvas, offset[0], offset[1], this._space.width, this._space.height);\n        }\n    }\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.filled = c;\n        }\n        else {\n            this.filled = true;\n            this._style.fillStyle = c;\n            this._ctx.fillStyle = c;\n        }\n        return this;\n    }\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.stroked = c;\n        }\n        else {\n            this.stroked = true;\n            this._style.strokeStyle = c;\n            this._ctx.strokeStyle = c;\n            if (width) {\n                this._ctx.lineWidth = width;\n                this._style.lineWidth = width;\n            }\n            if (linejoin) {\n                this._ctx.lineJoin = linejoin;\n                this._style.lineJoin = linejoin;\n            }\n            if (linecap) {\n                this._ctx.lineCap = linecap;\n                this._style.lineCap = linecap;\n            }\n        }\n        return this;\n    }\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n            this._ctx.font = this._font.value;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        if (this._estimateTextWidth)\n            this.fontWidthEstimate(true);\n        return this;\n    }\n    fontWidthEstimate(estimate = true) {\n        this._estimateTextWidth = (estimate) ? Typo.textWidthEstimator(((c) => this._ctx.measureText(c).width)) : undefined;\n        return this;\n    }\n    getTextWidth(c) {\n        return (!this._estimateTextWidth) ? this._ctx.measureText(c + \" .\").width : this._estimateTextWidth(c);\n    }\n    _textTruncate(str, width, tail = \"\") {\n        return Typo.truncate(this.getTextWidth.bind(this), str, width, tail);\n    }\n    _textAlign(box, vertical, offset, center) {\n        if (!center)\n            center = Rectangle.center(box);\n        var px = box[0][0];\n        if (this._ctx.textAlign == \"end\" || this._ctx.textAlign == \"right\") {\n            px = box[1][0];\n        }\n        else if (this._ctx.textAlign == \"center\" || this._ctx.textAlign == \"middle\") {\n            px = center[0];\n        }\n        var py = center[1];\n        if (vertical == \"top\" || vertical == \"start\") {\n            py = box[0][1];\n        }\n        else if (vertical == \"end\" || vertical == \"bottom\") {\n            py = box[1][1];\n        }\n        return (offset) ? new Pt(px + offset[0], py + offset[1]) : new Pt(px, py);\n    }\n    reset() {\n        for (let k in this._style) {\n            if (this._style.hasOwnProperty(k)) {\n                this._ctx[k] = this._style[k];\n            }\n        }\n        this._font = new Font();\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    _paint() {\n        if (this._filled)\n            this._ctx.fill();\n        if (this._stroked)\n            this._ctx.stroke();\n    }\n    point(p, radius = 5, shape = \"square\") {\n        if (!p)\n            return;\n        if (!CanvasForm[shape])\n            throw new Error(`${shape} is not a static function of CanvasForm`);\n        CanvasForm[shape](this._ctx, p, radius);\n        this._paint();\n        return this;\n    }\n    static circle(ctx, pt, radius = 10) {\n        if (!pt)\n            return;\n        ctx.beginPath();\n        ctx.arc(pt[0], pt[1], radius, 0, Const.two_pi, false);\n        ctx.closePath();\n    }\n    circle(pts) {\n        CanvasForm.circle(this._ctx, pts[0], pts[1][0]);\n        this._paint();\n        return this;\n    }\n    static arc(ctx, pt, radius, startAngle, endAngle, cc) {\n        if (!pt)\n            return;\n        ctx.beginPath();\n        ctx.arc(pt[0], pt[1], radius, startAngle, endAngle, cc);\n    }\n    arc(pt, radius, startAngle, endAngle, cc) {\n        CanvasForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n        this._paint();\n        return this;\n    }\n    static square(ctx, pt, halfsize) {\n        if (!pt)\n            return;\n        let x1 = pt[0] - halfsize;\n        let y1 = pt[1] - halfsize;\n        let x2 = pt[0] + halfsize;\n        let y2 = pt[1] + halfsize;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x1, y2);\n        ctx.lineTo(x2, y2);\n        ctx.lineTo(x2, y1);\n        ctx.closePath();\n    }\n    square(pt, halfsize) {\n        CanvasForm.square(this._ctx, pt, halfsize);\n        this._paint();\n        return this;\n    }\n    static line(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            if (pts[i])\n                ctx.lineTo(pts[i][0], pts[i][1]);\n        }\n    }\n    line(pts) {\n        CanvasForm.line(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    static polygon(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            if (pts[i])\n                ctx.lineTo(pts[i][0], pts[i][1]);\n        }\n        ctx.closePath();\n    }\n    polygon(pts) {\n        CanvasForm.polygon(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    static rect(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        ctx.lineTo(pts[0][0], pts[1][1]);\n        ctx.lineTo(pts[1][0], pts[1][1]);\n        ctx.lineTo(pts[1][0], pts[0][1]);\n        ctx.closePath();\n    }\n    rect(pts) {\n        CanvasForm.rect(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    static image(ctx, img, target = new Pt(), orig) {\n        if (typeof target[0] === \"number\") {\n            ctx.drawImage(img, target[0], target[1]);\n        }\n        else {\n            let t = target;\n            if (orig) {\n                ctx.drawImage(img, orig[0][0], orig[0][1], orig[1][0] - orig[0][0], orig[1][1] - orig[0][1], t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]);\n            }\n            else {\n                ctx.drawImage(img, t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]);\n            }\n        }\n    }\n    image(img, target, original) {\n        CanvasForm.image(this._ctx, img, target, original);\n        return this;\n    }\n    static text(ctx, pt, txt, maxWidth) {\n        if (!pt)\n            return;\n        ctx.fillText(txt, pt[0], pt[1], maxWidth);\n    }\n    text(pt, txt, maxWidth) {\n        CanvasForm.text(this._ctx, pt, txt, maxWidth);\n        return this;\n    }\n    textBox(box, txt, verticalAlign = \"middle\", tail = \"\", overrideBaseline = true) {\n        if (overrideBaseline)\n            this._ctx.textBaseline = verticalAlign;\n        let size = Rectangle.size(box);\n        let t = this._textTruncate(txt, size[0], tail);\n        this.text(this._textAlign(box, verticalAlign), t[0]);\n        return this;\n    }\n    paragraphBox(box, txt, lineHeight = 1.2, verticalAlign = \"top\", crop = true) {\n        let size = Rectangle.size(box);\n        this._ctx.textBaseline = \"top\";\n        let lstep = this._font.size * lineHeight;\n        let nextLine = (sub, buffer = [], cc = 0) => {\n            if (!sub)\n                return buffer;\n            if (crop && cc * lstep > size[1] - lstep * 2)\n                return buffer;\n            if (cc > 10000)\n                throw new Error(\"max recursion reached (10000)\");\n            let t = this._textTruncate(sub, size[0], \"\");\n            let newln = t[0].indexOf(\"\\n\");\n            if (newln >= 0) {\n                buffer.push(t[0].substr(0, newln));\n                return nextLine(sub.substr(newln + 1), buffer, cc + 1);\n            }\n            let dt = t[0].lastIndexOf(\" \") + 1;\n            if (dt <= 0 || t[1] === sub.length)\n                dt = undefined;\n            let line = t[0].substr(0, dt);\n            buffer.push(line);\n            return (t[1] <= 0 || t[1] === sub.length) ? buffer : nextLine(sub.substr((dt || t[1])), buffer, cc + 1);\n        };\n        let lines = nextLine(txt);\n        let lsize = lines.length * lstep;\n        let lbox = box;\n        if (verticalAlign == \"middle\" || verticalAlign == \"center\") {\n            let lpad = (size[1] - lsize) / 2;\n            if (crop)\n                lpad = Math.max(0, lpad);\n            lbox = new Group(box[0].$add(0, lpad), box[1].$subtract(0, lpad));\n        }\n        else if (verticalAlign == \"bottom\") {\n            lbox = new Group(box[0].$add(0, size[1] - lsize), box[1]);\n        }\n        else {\n            lbox = new Group(box[0], box[0].$add(size[0], lsize));\n        }\n        let center = Rectangle.center(lbox);\n        for (let i = 0, len = lines.length; i < len; i++) {\n            this.text(this._textAlign(lbox, \"top\", [0, i * lstep], center), lines[i]);\n        }\n        return this;\n    }\n    alignText(alignment = \"left\", baseline = \"alphabetic\") {\n        if (baseline == \"center\")\n            baseline = \"middle\";\n        if (baseline == \"baseline\")\n            baseline = \"alphabetic\";\n        this._ctx.textAlign = alignment;\n        this._ctx.textBaseline = baseline;\n        return this;\n    }\n    log(txt) {\n        let w = this._ctx.measureText(txt).width + 20;\n        this.stroke(false).fill(\"rgba(0,0,0,.4)\").rect([[0, 0], [w, 20]]);\n        this.fill(\"#fff\").text([10, 14], txt);\n        return this;\n    }\n}\n//# sourceMappingURL=Canvas.js.map","import { Pt, Group } from \"./Pt\";\nimport { Line, Triangle } from \"./Op\";\nimport { Const } from \"./Util\";\nimport { Num, Geom } from \"./Num\";\nimport { Vec } from \"./LinearAlgebra\";\nexport class Create {\n    static distributeRandom(bound, count, dimensions = 2) {\n        let pts = new Group();\n        for (let i = 0; i < count; i++) {\n            let p = [bound.x + Math.random() * bound.width];\n            if (dimensions > 1)\n                p.push(bound.y + Math.random() * bound.height);\n            if (dimensions > 2)\n                p.push(bound.z + Math.random() * bound.depth);\n            pts.push(new Pt(p));\n        }\n        return pts;\n    }\n    static distributeLinear(line, count) {\n        let ln = Line.subpoints(line, count - 2);\n        ln.unshift(line[0]);\n        ln.push(line[line.length - 1]);\n        return ln;\n    }\n    static gridPts(bound, columns, rows, orientation = [0.5, 0.5]) {\n        if (columns === 0 || rows === 0)\n            throw new Error(\"grid columns and rows cannot be 0\");\n        let unit = bound.size.$subtract(1).$divide(columns, rows);\n        let offset = unit.$multiply(orientation);\n        let g = new Group();\n        for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < columns; c++) {\n                g.push(bound.topLeft.$add(unit.$multiply(c, r)).add(offset));\n            }\n        }\n        return g;\n    }\n    static gridCells(bound, columns, rows) {\n        if (columns === 0 || rows === 0)\n            throw new Error(\"grid columns and rows cannot be 0\");\n        let unit = bound.size.$subtract(1).divide(columns, rows);\n        let g = [];\n        for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < columns; c++) {\n                g.push(new Group(bound.topLeft.$add(unit.$multiply(c, r)), bound.topLeft.$add(unit.$multiply(c, r).add(unit))));\n            }\n        }\n        return g;\n    }\n    static radialPts(center, radius, count) {\n        let g = new Group();\n        let a = Const.two_pi / count;\n        for (let i = 0; i < count; i++) {\n            g.push(new Pt(center).toAngle(a * i - Const.half_pi, radius, true));\n        }\n        return g;\n    }\n    static noisePts(pts, dx = 0.01, dy = 0.01, rows = 0, columns = 0) {\n        let seed = Math.random();\n        let g = new Group();\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let np = new Noise(pts[i]);\n            let r = (rows && rows > 0) ? Math.floor(i / rows) : i;\n            let c = (columns && columns > 0) ? i % columns : i;\n            np.initNoise(dx * c, dy * r);\n            np.seed(seed);\n            g.push(np);\n        }\n        return g;\n    }\n    static delaunay(pts) {\n        return Delaunay.from(pts);\n    }\n}\nconst grad3 = [\n    [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],\n    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],\n    [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]\n];\nconst permTable = [151, 160, 137, 91, 90, 15,\n    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\n    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\n    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\n    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\n    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\n    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\n    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n    129, 22, 39, 253, 9, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\n    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\n    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n];\nexport class Noise extends Pt {\n    constructor(...args) {\n        super(...args);\n        this.perm = [];\n        this._n = new Pt(0.01, 0.01);\n        this.perm = permTable.concat(permTable);\n    }\n    initNoise(...args) {\n        this._n = new Pt(...args);\n    }\n    step(x = 0, y = 0) {\n        this._n.add(x, y);\n    }\n    seed(s) {\n        if (s > 0 && s < 1)\n            s *= 65536;\n        s = Math.floor(s);\n        if (s < 256)\n            s |= s << 8;\n        for (let i = 0; i < 255; i++) {\n            let v = (i & 1) ? permTable[i] ^ (s & 255) : permTable[i] ^ ((s >> 8) & 255);\n            this.perm[i] = this.perm[i + 256] = v;\n        }\n    }\n    noise2D() {\n        let i = Math.max(0, Math.floor(this._n[0])) % 255;\n        let j = Math.max(0, Math.floor(this._n[1])) % 255;\n        let x = (this._n[0] % 255) - i;\n        let y = (this._n[1] % 255) - j;\n        let n00 = Vec.dot(grad3[(i + this.perm[j]) % 12], [x, y, 0]);\n        let n01 = Vec.dot(grad3[(i + this.perm[j + 1]) % 12], [x, y - 1, 0]);\n        let n10 = Vec.dot(grad3[(i + 1 + this.perm[j]) % 12], [x - 1, y, 0]);\n        let n11 = Vec.dot(grad3[(i + 1 + this.perm[j + 1]) % 12], [x - 1, y - 1, 0]);\n        let _fade = (f) => f * f * f * (f * (f * 6 - 15) + 10);\n        let tx = _fade(x);\n        return Num.lerp(Num.lerp(n00, n10, tx), Num.lerp(n01, n11, tx), _fade(y));\n    }\n}\nexport class Delaunay extends Group {\n    constructor() {\n        super(...arguments);\n        this._mesh = [];\n    }\n    delaunay(triangleOnly = true) {\n        if (this.length < 3)\n            return [];\n        this._mesh = [];\n        let n = this.length;\n        let indices = [];\n        for (let i = 0; i < n; i++)\n            indices[i] = i;\n        indices.sort((i, j) => this[j][0] - this[i][0]);\n        let pts = this.slice();\n        let st = this._superTriangle();\n        pts = pts.concat(st);\n        let opened = [this._circum(n, n + 1, n + 2, st)];\n        let closed = [];\n        let tris = [];\n        for (let i = 0, len = indices.length; i < len; i++) {\n            let c = indices[i];\n            let edges = [];\n            let j = opened.length;\n            if (!this._mesh[c])\n                this._mesh[c] = {};\n            while (j--) {\n                let circum = opened[j];\n                let radius = circum.circle[1][0];\n                let d = pts[c].$subtract(circum.circle[0]);\n                if (d[0] > 0 && d[0] * d[0] > radius * radius) {\n                    closed.push(circum);\n                    tris.push(circum.triangle);\n                    opened.splice(j, 1);\n                    continue;\n                }\n                if (d[0] * d[0] + d[1] * d[1] - radius * radius > Const.epsilon) {\n                    continue;\n                }\n                edges.push(circum.i, circum.j, circum.j, circum.k, circum.k, circum.i);\n                opened.splice(j, 1);\n            }\n            Delaunay._dedupe(edges);\n            j = edges.length;\n            while (j > 1) {\n                opened.push(this._circum(edges[--j], edges[--j], c, false, pts));\n            }\n        }\n        for (let i = 0, len = opened.length; i < len; i++) {\n            let o = opened[i];\n            if (o.i < n && o.j < n && o.k < n) {\n                closed.push(o);\n                tris.push(o.triangle);\n                this._cache(o);\n            }\n        }\n        return (triangleOnly) ? tris : closed;\n    }\n    voronoi() {\n        let vs = [];\n        let n = this._mesh;\n        for (let i = 0, len = n.length; i < len; i++) {\n            vs.push(this.neighborPts(i, true));\n        }\n        return vs;\n    }\n    mesh() {\n        return this._mesh;\n    }\n    neighborPts(i, sort = false) {\n        let cs = new Group();\n        let n = this._mesh;\n        for (let k in n[i]) {\n            if (n[i].hasOwnProperty(k))\n                cs.push(n[i][k].circle[0]);\n        }\n        return (sort) ? Geom.sortEdges(cs) : cs;\n    }\n    neighbors(i) {\n        let cs = [];\n        let n = this._mesh;\n        for (let k in n[i]) {\n            if (n[i].hasOwnProperty(k))\n                cs.push(n[i][k]);\n        }\n        return cs;\n    }\n    _cache(o) {\n        this._mesh[o.i][`${Math.min(o.j, o.k)}-${Math.max(o.j, o.k)}`] = o;\n        this._mesh[o.j][`${Math.min(o.i, o.k)}-${Math.max(o.i, o.k)}`] = o;\n        this._mesh[o.k][`${Math.min(o.i, o.j)}-${Math.max(o.i, o.j)}`] = o;\n    }\n    _superTriangle() {\n        let minPt = this[0];\n        let maxPt = this[0];\n        for (let i = 1, len = this.length; i < len; i++) {\n            minPt = minPt.$min(this[i]);\n            maxPt = maxPt.$max(this[i]);\n        }\n        let d = maxPt.$subtract(minPt);\n        let mid = minPt.$add(maxPt).divide(2);\n        let dmax = Math.max(d[0], d[1]);\n        return new Group(mid.$subtract(20 * dmax, dmax), mid.$add(0, 20 * dmax), mid.$add(20 * dmax, -dmax));\n    }\n    _triangle(i, j, k, pts = this) {\n        return new Group(pts[i], pts[j], pts[k]);\n    }\n    _circum(i, j, k, tri, pts = this) {\n        let t = tri || this._triangle(i, j, k, pts);\n        return {\n            i: i,\n            j: j,\n            k: k,\n            triangle: t,\n            circle: Triangle.circumcircle(t)\n        };\n    }\n    static _dedupe(edges) {\n        let j = edges.length;\n        while (j > 1) {\n            let b = edges[--j];\n            let a = edges[--j];\n            let i = j;\n            while (i > 1) {\n                let n = edges[--i];\n                let m = edges[--i];\n                if ((a == m && b == n) || (a == n && b == m)) {\n                    edges.splice(j, 2);\n                    edges.splice(i, 2);\n                    break;\n                }\n            }\n        }\n        return edges;\n    }\n}\n//# sourceMappingURL=Create.js.map","import { Pt, Group } from \"./Pt\";\nimport { Util } from \"./Util\";\nimport { Num, Geom } from \"./Num\";\nexport class Color extends Pt {\n    constructor(...args) {\n        super(...args);\n        this._mode = \"rgb\";\n        this._isNorm = false;\n    }\n    static from(...args) {\n        let p = [1, 1, 1, 1];\n        let c = Util.getArgs(args);\n        for (let i = 0, len = p.length; i < len; i++) {\n            if (i < c.length)\n                p[i] = c[i];\n        }\n        return new Color(p);\n    }\n    static fromHex(hex) {\n        if (hex[0] == \"#\")\n            hex = hex.substr(1);\n        if (hex.length <= 3) {\n            let fn = (i) => hex[i] || \"F\";\n            hex = `${fn(0)}${fn(0)}${fn(1)}${fn(1)}${fn(2)}${fn(2)}`;\n        }\n        let alpha = 1;\n        if (hex.length === 8) {\n            alpha = hex.substr(6) && 0xFF / 255;\n            hex = hex.substring(0, 6);\n        }\n        let hexVal = parseInt(hex, 16);\n        return new Color(hexVal >> 16, hexVal >> 8 & 0xFF, hexVal & 0xFF, alpha);\n    }\n    static rgb(...args) { return Color.from(...args).toMode(\"rgb\"); }\n    static hsl(...args) { return Color.from(...args).toMode(\"hsl\"); }\n    static hsb(...args) { return Color.from(...args).toMode(\"hsb\"); }\n    static lab(...args) { return Color.from(...args).toMode(\"lab\"); }\n    static lch(...args) { return Color.from(...args).toMode(\"lch\"); }\n    static luv(...args) { return Color.from(...args).toMode(\"luv\"); }\n    static xyz(...args) { return Color.from(...args).toMode(\"xyz\"); }\n    static maxValues(mode) { return Color.ranges[mode].zipSlice(1).$take([0, 1, 2]); }\n    get hex() { return this.toString(\"hex\"); }\n    get rgb() { return this.toString(\"rgb\"); }\n    get rgba() { return this.toString(\"rgba\"); }\n    clone() {\n        let c = new Color(this);\n        c.toMode(this._mode);\n        return c;\n    }\n    toMode(mode, convert = false) {\n        if (convert) {\n            let fname = this._mode.toUpperCase() + \"to\" + mode.toUpperCase();\n            if (Color[fname]) {\n                this.to(Color[fname](this, this._isNorm, this._isNorm));\n            }\n            else {\n                throw new Error(\"Cannot convert color with \" + fname);\n            }\n        }\n        this._mode = mode;\n        return this;\n    }\n    get mode() { return this._mode; }\n    get r() { return this[0]; }\n    set r(n) { this[0] = n; }\n    get g() { return this[1]; }\n    set g(n) { this[1] = n; }\n    get b() { return this[2]; }\n    set b(n) { this[2] = n; }\n    get h() { return (this._mode == \"lch\") ? this[2] : this[0]; }\n    set h(n) {\n        let i = (this._mode == \"lch\") ? 2 : 0;\n        this[i] = n;\n    }\n    get s() { return this[1]; }\n    set s(n) { this[1] = n; }\n    get l() { return (this._mode == \"hsl\") ? this[2] : this[0]; }\n    set l(n) {\n        let i = (this._mode == \"hsl\") ? 2 : 0;\n        this[i] = n;\n    }\n    get a() { return this[1]; }\n    set a(n) { this[1] = n; }\n    get c() { return this[1]; }\n    set c(n) { this[1] = n; }\n    get u() { return this[1]; }\n    set u(n) { this[1] = n; }\n    get v() { return this[2]; }\n    set v(n) { this[2] = n; }\n    get alpha() { return (this.length > 3) ? this[3] : 1; }\n    get normalized() { return this._isNorm; }\n    set normalized(b) { this._isNorm = b; }\n    normalize(toNorm = true) {\n        if (this._isNorm == toNorm)\n            return this;\n        let ranges = Color.ranges[this._mode];\n        for (let i = 0; i < 3; i++) {\n            this[i] = (!toNorm)\n                ? Num.mapToRange(this[i], 0, 1, ranges[i][0], ranges[i][1])\n                : Num.mapToRange(this[i], ranges[i][0], ranges[i][1], 0, 1);\n        }\n        this._isNorm = toNorm;\n        return this;\n    }\n    $normalize(toNorm = true) { return this.clone().normalize(toNorm); }\n    toString(format = \"mode\") {\n        if (format == \"hex\") {\n            let _hex = (n) => {\n                let s = Math.floor(n).toString(16);\n                return (s.length < 2) ? '0' + s : s;\n            };\n            return `#${_hex(this[0])}${_hex(this[1])}${_hex(this[2])}`;\n        }\n        else if (format == \"rgba\") {\n            return `rgba(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])},${this.alpha}`;\n        }\n        else if (format == \"rgb\") {\n            return `rgb(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])}`;\n        }\n        else {\n            return `${this._mode}(${this[0]},${this[1]},${this[2]},${this.alpha})`;\n        }\n    }\n    static RGBtoHSL(rgb, normalizedInput = false, normalizedOutput = false) {\n        let [r, g, b] = (!normalizedInput) ? rgb.$normalize() : rgb;\n        let max = Math.max(r, g, b);\n        let min = Math.min(r, g, b);\n        let h = (max + min) / 2;\n        let s = h;\n        let l = h;\n        if (max == min) {\n            h = 0;\n            s = 0;\n        }\n        else {\n            let d = max - min;\n            s = (l > 0.5) ? d / (2 - max - min) : d / (max + min);\n            h = 0;\n            if (max === r) {\n                h = (g - b) / d + ((g < b) ? 6 : 0);\n            }\n            else if (max === g) {\n                h = (b - r) / d + 2;\n            }\n            else if (max === b) {\n                h = (r - g) / d + 4;\n            }\n        }\n        return Color.hsl(((normalizedOutput) ? h / 60 : h * 60), s, l, rgb.alpha);\n    }\n    static HSLtoRGB(hsl, normalizedInput = false, normalizedOutput = false) {\n        let [h, s, l] = hsl;\n        if (!normalizedInput)\n            h = h / 360;\n        if (s == 0)\n            return Color.rgb(l * 255, l * 255, l * 255, hsl.alpha);\n        let q = (l <= 0.5) ? l * (1 + s) : l + s - (l * s);\n        let p = 2 * l - q;\n        let convert = (t) => {\n            t = (t < 0) ? t + 1 : (t > 1) ? t - 1 : t;\n            if (t * 6 < 1) {\n                return p + (q - p) * t * 6;\n            }\n            else if (t * 2 < 1) {\n                return q;\n            }\n            else if (t * 3 < 2) {\n                return p + (q - p) * ((2 / 3) - t) * 6;\n            }\n            else {\n                return p;\n            }\n        };\n        let sc = (normalizedOutput) ? 1 : 255;\n        return Color.rgb(sc * convert((h + 1 / 3)), sc * convert(h), sc * convert((h - 1 / 3)), hsl.alpha);\n    }\n    static RGBtoHSB(rgb, normalizedInput = false, normalizedOutput = false) {\n        let [r, g, b] = (!normalizedInput) ? rgb.$normalize() : rgb;\n        let max = Math.max(r, g, b);\n        let min = Math.min(r, g, b);\n        let d = max - min;\n        let h = 0;\n        let s = (max === 0) ? 0 : d / max;\n        let v = max;\n        if (max != min) {\n            if (max === r) {\n                h = (g - b) / d + ((g < b) ? 6 : 0);\n            }\n            else if (max === g) {\n                h = (b - r) / d + 2;\n            }\n            else if (max === b) {\n                h = (r - g) / d + 4;\n            }\n        }\n        return Color.hsb(((normalizedOutput) ? h / 60 : h * 60), s, v, rgb.alpha);\n    }\n    static HSBtoRGB(hsb, normalizedInput = false, normalizedOutput = false) {\n        let [h, s, v] = hsb;\n        if (!normalizedInput)\n            h = h / 360;\n        let i = Math.floor(h * 6);\n        let f = h * 6 - i;\n        let p = v * (1 - s);\n        let q = v * (1 - f * s);\n        let t = v * (1 - (1 - f) * s);\n        let pick = [\n            [v, t, p], [q, v, p], [p, v, t],\n            [p, q, v], [t, p, v], [v, p, q]\n        ];\n        let c = pick[i % 6];\n        let sc = (normalizedOutput) ? 1 : 255;\n        return Color.rgb(sc * c[0], sc * c[1], sc * c[2], hsb.alpha);\n    }\n    static RGBtoLAB(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.XYZtoLAB(Color.RGBtoXYZ(c), false, normalizedOutput);\n    }\n    static LABtoRGB(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        return Color.XYZtoRGB(Color.LABtoXYZ(c), false, normalizedOutput);\n    }\n    static RGBtoLCH(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.LABtoLCH(Color.RGBtoLAB(c), false, normalizedOutput);\n    }\n    static LCHtoRGB(lch, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lch.$normalize(false) : lch;\n        return Color.LABtoRGB(Color.LCHtoLAB(c), false, normalizedOutput);\n    }\n    static RGBtoLUV(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.XYZtoLUV(Color.RGBtoXYZ(c), false, normalizedOutput);\n    }\n    static LUVtoRGB(luv, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? luv.$normalize(false) : luv;\n        return Color.XYZtoRGB(Color.LUVtoXYZ(c), false, normalizedOutput);\n    }\n    static RGBtoXYZ(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (!normalizedInput) ? rgb.$normalize() : rgb.clone();\n        for (let i = 0; i < 3; i++) {\n            c[i] = (c[i] > 0.04045) ? Math.pow((c[i] + 0.055) / 1.055, 2.4) : c[i] / 12.92;\n            if (!normalizedOutput)\n                c[i] = c[i] * 100;\n        }\n        let cc = Color.xyz(c[0] * 0.4124564 + c[1] * 0.3575761 + c[2] * 0.1804375, c[0] * 0.2126729 + c[1] * 0.7151522 + c[2] * 0.0721750, c[0] * 0.0193339 + c[1] * 0.1191920 + c[2] * 0.9503041, rgb.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static XYZtoRGB(xyz, normalizedInput = false, normalizedOutput = false) {\n        let [x, y, z] = (!normalizedInput) ? xyz.$normalize() : xyz;\n        let rgb = [\n            x * 3.2404542 + y * -1.5371385 + z * -0.4985314,\n            x * -0.9692660 + y * 1.8760108 + z * 0.0415560,\n            x * 0.0556434 + y * -0.2040259 + z * 1.0572252\n        ];\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = (rgb[i] < 0) ? 0 : (rgb[i] > 0.0031308) ? (1.055 * Math.pow(rgb[i], 1 / 2.4) - 0.055) : (12.92 * rgb[i]);\n            rgb[i] = Math.max(0, Math.min(1, rgb[i]));\n            if (!normalizedOutput)\n                rgb[i] = Math.round(rgb[i] * 255);\n        }\n        let cc = Color.rgb(rgb[0], rgb[1], rgb[2], xyz.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static XYZtoLAB(xyz, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? xyz.$normalize(false) : xyz.clone();\n        c.divide(Color.D65);\n        let fn = (n) => (n > 0.008856) ? Math.pow(n, 1 / 3) : (7.787 * n) + 16 / 116;\n        let cy = fn(c[1]);\n        let cc = Color.lab((116 * cy) - 16, 500 * (fn(c[0]) - cy), 200 * (cy - fn(c[2])), xyz.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static LABtoXYZ(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        let y = (c[0] + 16) / 116;\n        let x = (c[1] / 500) + y;\n        let z = y - c[2] / 200;\n        let fn = (n) => {\n            let nnn = n * n * n;\n            return (nnn > 0.008856) ? nnn : (n - 16 / 116) / 7.787;\n        };\n        let d = Color.D65;\n        let cc = Color.xyz(Math.max(0, d[0] * fn(x)), Math.max(0, d[1] * fn(y)), Math.max(0, d[2] * fn(z)), lab.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static XYZtoLUV(xyz, normalizedInput = false, normalizedOutput = false) {\n        let [x, y, z] = (normalizedInput) ? xyz.$normalize(false) : xyz;\n        let u = (4 * x) / (x + (15 * y) + (3 * z));\n        let v = (9 * y) / (x + (15 * y) + (3 * z));\n        y = y / 100;\n        y = (y > 0.008856) ? Math.pow(y, 1 / 3) : (7.787 * y + 16 / 116);\n        let refU = (4 * Color.D65[0]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let refV = (9 * Color.D65[1]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let L = (116 * y) - 16;\n        return Color.luv(L, 13 * L * (u - refU), 13 * L * (v - refV), xyz.alpha);\n    }\n    static LUVtoXYZ(luv, normalizedInput = false, normalizedOutput = false) {\n        let [l, u, v] = (normalizedInput) ? luv.$normalize(false) : luv;\n        let y = (l + 16) / 116;\n        let cubeY = y * y * y;\n        y = (cubeY > 0.008856) ? cubeY : (y - 16 / 116) / 7.787;\n        let refU = (4 * Color.D65[0]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let refV = (9 * Color.D65[1]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        u = u / (13 * l) + refU;\n        v = v / (13 * l) + refV;\n        y = y * 100;\n        let x = -1 * (9 * y * u) / ((u - 4) * v - u * v);\n        let z = (9 * y - (15 * v * y) - (v * x)) / (3 * v);\n        return Color.xyz(x, y, z, luv.alpha);\n    }\n    static LABtoLCH(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        let h = Geom.toDegree(Geom.boundRadian(Math.atan2(c[2], c[1])));\n        return Color.lch(c[0], Math.sqrt(c[1] * c[1] + c[2] * c[2]), h, lab.alpha);\n    }\n    static LCHtoLAB(lch, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lch.$normalize(false) : lch;\n        let rad = Geom.toRadian(c[2]);\n        return Color.lab(c[0], Math.cos(rad) * c[1], Math.sin(rad) * c[1], lch.alpha);\n    }\n}\nColor.D65 = new Pt(95.047, 100, 108.883, 1);\nColor.ranges = {\n    rgb: new Group(new Pt(0, 255), new Pt(0, 255), new Pt(0, 255)),\n    hsl: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n    hsb: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n    lab: new Group(new Pt(0, 100), new Pt(-128, 127), new Pt(-128, 127)),\n    lch: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 360)),\n    luv: new Group(new Pt(0, 100), new Pt(-134, 220), new Pt(-140, 122)),\n    xyz: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 100))\n};\n//# sourceMappingURL=Color.js.map","import { MultiTouchSpace } from './Space';\nimport { VisualForm, Font } from \"./Form\";\nimport { Util } from './Util';\nimport { Pt, Bound } from './Pt';\nexport class DOMSpace extends MultiTouchSpace {\n    constructor(elem, callback) {\n        super();\n        this.id = \"domspace\";\n        this._autoResize = true;\n        this._bgcolor = \"#e1e9f0\";\n        this._css = {};\n        var _selector = null;\n        var _existed = false;\n        this.id = \"pts\";\n        if (elem instanceof Element) {\n            _selector = elem;\n            this.id = \"pts_existing_space\";\n        }\n        else {\n            _selector = document.querySelector(elem);\n            _existed = true;\n            this.id = elem.substr(1);\n        }\n        if (!_selector) {\n            this._container = DOMSpace.createElement(\"div\", \"pts_container\");\n            this._canvas = DOMSpace.createElement(\"div\", \"pts_element\");\n            this._container.appendChild(this._canvas);\n            document.body.appendChild(this._container);\n            _existed = false;\n        }\n        else {\n            this._canvas = _selector;\n            this._container = _selector.parentElement;\n        }\n        setTimeout(this._ready.bind(this, callback), 50);\n    }\n    static createElement(elem = \"div\", id, appendTo) {\n        let d = document.createElement(elem);\n        if (id)\n            d.setAttribute(\"id\", id);\n        if (appendTo && appendTo.appendChild)\n            appendTo.appendChild(d);\n        return d;\n    }\n    _ready(callback) {\n        if (!this._container)\n            throw new Error(`Cannot initiate #${this.id} element`);\n        this._isReady = true;\n        this._resizeHandler(null);\n        this.clear(this._bgcolor);\n        this._canvas.dispatchEvent(new Event(\"ready\"));\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                if (this.players[k].start)\n                    this.players[k].start(this.bound.clone(), this);\n            }\n        }\n        this._pointer = this.center;\n        this.refresh(false);\n        if (callback)\n            callback(this.bound, this._canvas);\n    }\n    setup(opt) {\n        if (opt.bgcolor) {\n            this._bgcolor = opt.bgcolor;\n        }\n        this.autoResize = (opt.resize != undefined) ? opt.resize : false;\n        return this;\n    }\n    getForm() {\n        return null;\n    }\n    set autoResize(auto) {\n        this._autoResize = auto;\n        if (auto) {\n            window.addEventListener('resize', this._resizeHandler.bind(this));\n        }\n        else {\n            delete this._css['width'];\n            delete this._css['height'];\n            window.removeEventListener('resize', this._resizeHandler.bind(this));\n        }\n    }\n    get autoResize() { return this._autoResize; }\n    resize(b, evt) {\n        this.bound = b;\n        this.styles({ width: `${b.width}px`, height: `${b.height}px` }, true);\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                let p = this.players[k];\n                if (p.resize)\n                    p.resize(this.bound, evt);\n            }\n        }\n        return this;\n    }\n    _resizeHandler(evt) {\n        let b = Bound.fromBoundingRect(this._container.getBoundingClientRect());\n        if (this._autoResize) {\n            this.styles({ width: \"100%\", height: \"100%\" }, true);\n        }\n        else {\n            this.styles({ width: `${b.width}px`, height: `${b.height}px` }, true);\n        }\n        this.resize(b, evt);\n    }\n    get element() {\n        return this._canvas;\n    }\n    get parent() {\n        return this._container;\n    }\n    get ready() { return this._isReady; }\n    clear(bg) {\n        if (bg)\n            this.background = bg;\n        this._canvas.innerHTML = \"\";\n        return this;\n    }\n    set background(bg) {\n        this._bgcolor = bg;\n        this._container.style.backgroundColor = this._bgcolor;\n    }\n    get background() { return this._bgcolor; }\n    style(key, val, update = false) {\n        this._css[key] = val;\n        if (update)\n            this._canvas.style[key] = val;\n        return this;\n    }\n    styles(styles, update = false) {\n        for (let k in styles) {\n            if (styles.hasOwnProperty(k))\n                this.style(k, styles[k], update);\n        }\n        return this;\n    }\n    static setAttr(elem, data) {\n        for (let k in data) {\n            if (data.hasOwnProperty(k)) {\n                elem.setAttribute(k, data[k]);\n            }\n        }\n        return elem;\n    }\n    static getInlineStyles(data) {\n        let str = \"\";\n        for (let k in data) {\n            if (data.hasOwnProperty(k)) {\n                if (data[k])\n                    str += `${k}: ${data[k]}; `;\n            }\n        }\n        return str;\n    }\n}\nexport class HTMLSpace extends DOMSpace {\n    getForm() {\n        return new HTMLForm(this);\n    }\n    static htmlElement(parent, name, id, autoClass = true) {\n        if (!parent || !parent.appendChild)\n            throw new Error(\"parent is not a valid DOM element\");\n        let elem = document.querySelector(`#${id}`);\n        if (!elem) {\n            elem = document.createElement(name);\n            elem.setAttribute(\"id\", id);\n            if (autoClass)\n                elem.setAttribute(\"class\", id.substring(0, id.indexOf(\"-\")));\n            parent.appendChild(elem);\n        }\n        return elem;\n    }\n    remove(player) {\n        let temp = this._container.querySelectorAll(\".\" + HTMLForm.scopeID(player));\n        temp.forEach((el) => {\n            el.parentNode.removeChild(el);\n        });\n        return super.remove(player);\n    }\n    removeAll() {\n        this._container.innerHTML = \"\";\n        return super.removeAll();\n    }\n}\nexport class HTMLForm extends VisualForm {\n    constructor(space) {\n        super();\n        this._ctx = {\n            group: null,\n            groupID: \"pts\",\n            groupCount: 0,\n            currentID: \"pts0\",\n            currentClass: \"\",\n            style: {\n                \"filled\": true,\n                \"stroked\": true,\n                \"background\": \"#f03\",\n                \"border-color\": \"#fff\",\n                \"color\": \"#000\",\n                \"border-width\": \"1px\",\n                \"border-radius\": \"0\",\n                \"border-style\": \"solid\",\n                \"position\": \"absolute\",\n                \"top\": 0,\n                \"left\": 0,\n                \"width\": 0,\n                \"height\": 0\n            },\n            font: \"11px sans-serif\",\n            fontSize: 11,\n            fontFamily: \"sans-serif\"\n        };\n        this._ready = false;\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx.group = this._space.element;\n                this._ctx.groupID = \"pts_dom_\" + (HTMLForm.groupID++);\n                this._ready = true;\n            } });\n    }\n    get space() { return this._space; }\n    styleTo(k, v, unit = '') {\n        if (this._ctx.style[k] === undefined)\n            throw new Error(`${k} style property doesn't exist`);\n        this._ctx.style[k] = `${v}${unit}`;\n    }\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"filled\", c);\n            if (!c)\n                this.styleTo(\"background\", \"transparent\");\n        }\n        else {\n            this.styleTo(\"filled\", true);\n            this.styleTo(\"background\", c);\n        }\n        return this;\n    }\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"stroked\", c);\n            if (!c)\n                this.styleTo(\"border-width\", 0);\n        }\n        else {\n            this.styleTo(\"stroked\", true);\n            this.styleTo(\"border-color\", c);\n            this.styleTo(\"border-width\", (width || 1) + \"px\");\n        }\n        return this;\n    }\n    fillText(c) {\n        this.styleTo(\"color\", c);\n        return this;\n    }\n    cls(c) {\n        if (typeof c == \"boolean\") {\n            this._ctx.currentClass = \"\";\n        }\n        else {\n            this._ctx.currentClass = c;\n        }\n        return this;\n    }\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n            this._ctx.font = this._font.value;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        return this;\n    }\n    reset() {\n        this._ctx.style = {\n            \"filled\": true, \"stroked\": true,\n            \"background\": \"#f03\", \"border-color\": \"#fff\",\n            \"border-width\": \"1px\"\n        };\n        this._font = new Font(14, \"sans-serif\");\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    updateScope(group_id, group) {\n        this._ctx.group = group;\n        this._ctx.groupID = group_id;\n        this._ctx.groupCount = 0;\n        this.nextID();\n        return this._ctx;\n    }\n    scope(item) {\n        if (!item || item.animateID == null)\n            throw new Error(\"item not defined or not yet added to Space\");\n        return this.updateScope(HTMLForm.scopeID(item), this.space.element);\n    }\n    nextID() {\n        this._ctx.groupCount++;\n        this._ctx.currentID = `${this._ctx.groupID}-${this._ctx.groupCount}`;\n        return this._ctx.currentID;\n    }\n    static getID(ctx) {\n        return ctx.currentID || `p-${HTMLForm.domID++}`;\n    }\n    static scopeID(item) {\n        return `item-${item.animateID}`;\n    }\n    static style(elem, styles) {\n        let st = [];\n        if (!styles[\"filled\"])\n            st.push(\"background: none\");\n        if (!styles[\"stroked\"])\n            st.push(\"border: none\");\n        for (let k in styles) {\n            if (styles.hasOwnProperty(k) && k != \"filled\" && k != \"stroked\") {\n                let v = styles[k];\n                if (v) {\n                    if (!styles[\"filled\"] && k.indexOf('background') === 0) {\n                        continue;\n                    }\n                    else if (!styles[\"stroked\"] && k.indexOf('border-width') === 0) {\n                        continue;\n                    }\n                    else {\n                        st.push(`${k}: ${v}`);\n                    }\n                }\n            }\n        }\n        return HTMLSpace.setAttr(elem, { style: st.join(\";\") });\n    }\n    static rectStyle(ctx, pt, size) {\n        ctx.style[\"left\"] = pt[0] + \"px\";\n        ctx.style[\"top\"] = pt[1] + \"px\";\n        ctx.style[\"width\"] = size[0] + \"px\";\n        ctx.style[\"height\"] = size[1] + \"px\";\n        return ctx;\n    }\n    static point(ctx, pt, radius = 5, shape = \"square\") {\n        if (shape === \"circle\") {\n            return HTMLForm.circle(ctx, pt, radius);\n        }\n        else {\n            return HTMLForm.square(ctx, pt, radius);\n        }\n    }\n    point(pt, radius = 5, shape = \"square\") {\n        this.nextID();\n        if (shape == \"circle\")\n            this.styleTo(\"border-radius\", \"100%\");\n        HTMLForm.point(this._ctx, pt, radius, shape);\n        return this;\n    }\n    static circle(ctx, pt, radius = 10) {\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, { class: `pts-form pts-circle ${ctx.currentClass}` });\n        HTMLForm.rectStyle(ctx, new Pt(pt).$subtract(radius), new Pt(radius * 2, radius * 2));\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    circle(pts) {\n        this.nextID();\n        this.styleTo(\"border-radius\", \"100%\");\n        HTMLForm.circle(this._ctx, pts[0], pts[1][0]);\n        return this;\n    }\n    static square(ctx, pt, halfsize) {\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, { class: `pts-form pts-square ${ctx.currentClass}` });\n        HTMLForm.rectStyle(ctx, new Pt(pt).$subtract(halfsize), new Pt(halfsize * 2, halfsize * 2));\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    square(pt, halfsize) {\n        this.nextID();\n        HTMLForm.square(this._ctx, pt, halfsize);\n        return this;\n    }\n    static rect(ctx, pts) {\n        if (!this._checkSize(pts))\n            return;\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, { class: `pts-form pts-rect ${ctx.currentClass}` });\n        HTMLForm.rectStyle(ctx, pts[0], pts[1]);\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    rect(pts) {\n        this.nextID();\n        this.styleTo(\"border-radius\", \"0\");\n        HTMLForm.rect(this._ctx, pts);\n        return this;\n    }\n    static text(ctx, pt, txt) {\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, {\n            position: 'absolute',\n            class: `pts-form pts-text ${ctx.currentClass}`,\n            left: pt[0],\n            top: pt[1],\n        });\n        elem.textContent = txt;\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    text(pt, txt) {\n        this.nextID();\n        HTMLForm.text(this._ctx, pt, txt);\n        return this;\n    }\n    log(txt) {\n        this.fill(\"#000\").stroke(\"#fff\", 0.5).text([10, 14], txt);\n        return this;\n    }\n    arc(pt, radius, startAngle, endAngle, cc) {\n        Util.warn(\"arc is not implemented in HTMLForm\");\n        return this;\n    }\n    line(pts) {\n        Util.warn(\"line is not implemented in HTMLForm\");\n        return this;\n    }\n    polygon(pts) {\n        Util.warn(\"polygon is not implemented in HTMLForm\");\n        return this;\n    }\n}\nHTMLForm.groupID = 0;\nHTMLForm.domID = 0;\n//# sourceMappingURL=Dom.js.map","import { VisualForm, Font } from \"./Form\";\nimport { Geom } from './Num';\nimport { Const } from './Util';\nimport { Pt, Group } from './Pt';\nimport { Rectangle } from \"./Op\";\nimport { DOMSpace } from \"./Dom\";\nexport class SVGSpace extends DOMSpace {\n    constructor(elem, callback) {\n        super(elem, callback);\n        this.id = \"svgspace\";\n        this._bgcolor = \"#999\";\n        if (this._canvas.nodeName.toLowerCase() != \"svg\") {\n            let s = SVGSpace.svgElement(this._canvas, \"svg\", `${this.id}_svg`);\n            this._container = this._canvas;\n            this._canvas = s;\n        }\n    }\n    getForm() { return new SVGForm(this); }\n    get element() {\n        return this._canvas;\n    }\n    resize(b, evt) {\n        super.resize(b, evt);\n        SVGSpace.setAttr(this.element, {\n            \"viewBox\": `0 0 ${this.bound.width} ${this.bound.height}`,\n            \"width\": `${this.bound.width}`,\n            \"height\": `${this.bound.height}`,\n            \"xmlns\": \"http://www.w3.org/2000/svg\",\n            \"version\": \"1.1\"\n        });\n        return this;\n    }\n    static svgElement(parent, name, id) {\n        if (!parent || !parent.appendChild)\n            throw new Error(\"parent is not a valid DOM element\");\n        let elem = document.querySelector(`#${id}`);\n        if (!elem) {\n            elem = document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n            elem.setAttribute(\"id\", id);\n            parent.appendChild(elem);\n        }\n        return elem;\n    }\n    remove(player) {\n        let temp = this._container.querySelectorAll(\".\" + SVGForm.scopeID(player));\n        temp.forEach((el) => {\n            el.parentNode.removeChild(el);\n        });\n        return super.remove(player);\n    }\n    removeAll() {\n        this._container.innerHTML = \"\";\n        return super.removeAll();\n    }\n}\nexport class SVGForm extends VisualForm {\n    constructor(space) {\n        super();\n        this._ctx = {\n            group: null,\n            groupID: \"pts\",\n            groupCount: 0,\n            currentID: \"pts0\",\n            currentClass: \"\",\n            style: {\n                \"filled\": true,\n                \"stroked\": true,\n                \"fill\": \"#f03\",\n                \"stroke\": \"#fff\",\n                \"stroke-width\": 1,\n                \"stroke-linejoin\": \"bevel\",\n                \"stroke-linecap\": \"sqaure\"\n            },\n            font: \"11px sans-serif\",\n            fontSize: 11,\n            fontFamily: \"sans-serif\"\n        };\n        this._ready = false;\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx.group = this._space.element;\n                this._ctx.groupID = \"pts_svg_\" + (SVGForm.groupID++);\n                this._ready = true;\n            } });\n    }\n    get space() { return this._space; }\n    styleTo(k, v) {\n        if (this._ctx.style[k] === undefined)\n            throw new Error(`${k} style property doesn't exist`);\n        this._ctx.style[k] = v;\n    }\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"filled\", c);\n        }\n        else {\n            this.styleTo(\"filled\", true);\n            this.styleTo(\"fill\", c);\n        }\n        return this;\n    }\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"stroked\", c);\n        }\n        else {\n            this.styleTo(\"stroked\", true);\n            this.styleTo(\"stroke\", c);\n            if (width)\n                this.styleTo(\"stroke-width\", width);\n            if (linejoin)\n                this.styleTo(\"stroke-linejoin\", linejoin);\n            if (linecap)\n                this.styleTo(\"stroke-linecap\", linecap);\n        }\n        return this;\n    }\n    cls(c) {\n        if (typeof c == \"boolean\") {\n            this._ctx.currentClass = \"\";\n        }\n        else {\n            this._ctx.currentClass = c;\n        }\n        return this;\n    }\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n            this._ctx.font = this._font.value;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        return this;\n    }\n    reset() {\n        this._ctx.style = {\n            \"filled\": true, \"stroked\": true,\n            \"fill\": \"#f03\", \"stroke\": \"#fff\",\n            \"stroke-width\": 1,\n            \"stroke-linejoin\": \"bevel\",\n            \"stroke-linecap\": \"sqaure\"\n        };\n        this._font = new Font(14, \"sans-serif\");\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    updateScope(group_id, group) {\n        this._ctx.group = group;\n        this._ctx.groupID = group_id;\n        this._ctx.groupCount = 0;\n        this.nextID();\n        return this._ctx;\n    }\n    scope(item) {\n        if (!item || item.animateID == null)\n            throw new Error(\"item not defined or not yet added to Space\");\n        return this.updateScope(SVGForm.scopeID(item), this.space.element);\n    }\n    nextID() {\n        this._ctx.groupCount++;\n        this._ctx.currentID = `${this._ctx.groupID}-${this._ctx.groupCount}`;\n        return this._ctx.currentID;\n    }\n    static getID(ctx) {\n        return ctx.currentID || `p-${SVGForm.domID++}`;\n    }\n    static scopeID(item) {\n        return `item-${item.animateID}`;\n    }\n    static style(elem, styles) {\n        let st = [];\n        if (!styles[\"filled\"])\n            st.push(\"fill: none\");\n        if (!styles[\"stroked\"])\n            st.push(\"stroke: none\");\n        for (let k in styles) {\n            if (styles.hasOwnProperty(k) && k != \"filled\" && k != \"stroked\") {\n                let v = styles[k];\n                if (v) {\n                    if (!styles[\"filled\"] && k.indexOf('fill') === 0) {\n                        continue;\n                    }\n                    else if (!styles[\"stroked\"] && k.indexOf('stroke') === 0) {\n                        continue;\n                    }\n                    else {\n                        st.push(`${k}: ${v}`);\n                    }\n                }\n            }\n        }\n        return DOMSpace.setAttr(elem, { style: st.join(\";\") });\n    }\n    static point(ctx, pt, radius = 5, shape = \"square\") {\n        if (shape === \"circle\") {\n            return SVGForm.circle(ctx, pt, radius);\n        }\n        else {\n            return SVGForm.square(ctx, pt, radius);\n        }\n    }\n    point(pt, radius = 5, shape = \"square\") {\n        this.nextID();\n        SVGForm.point(this._ctx, pt, radius, shape);\n        return this;\n    }\n    static circle(ctx, pt, radius = 10) {\n        let elem = SVGSpace.svgElement(ctx.group, \"circle\", SVGForm.getID(ctx));\n        DOMSpace.setAttr(elem, {\n            cx: pt[0],\n            cy: pt[1],\n            r: radius,\n            'class': `pts-svgform pts-circle ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    circle(pts) {\n        this.nextID();\n        SVGForm.circle(this._ctx, pts[0], pts[1][0]);\n        return this;\n    }\n    static arc(ctx, pt, radius, startAngle, endAngle, cc) {\n        let elem = SVGSpace.svgElement(ctx.group, \"path\", SVGForm.getID(ctx));\n        const start = new Pt(pt).toAngle(startAngle, radius, true);\n        const end = new Pt(pt).toAngle(endAngle, radius, true);\n        const diff = Geom.boundAngle(endAngle) - Geom.boundAngle(startAngle);\n        let largeArc = (diff > Const.pi) ? true : false;\n        if (cc)\n            largeArc = !largeArc;\n        const sweep = (cc) ? \"0\" : \"1\";\n        const d = `M ${start[0]} ${start[1]} A ${radius} ${radius} 0 ${largeArc ? \"1\" : \"0\"} ${sweep} ${end[0]} ${end[1]}`;\n        DOMSpace.setAttr(elem, {\n            d: d,\n            'class': `pts-svgform pts-arc ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    arc(pt, radius, startAngle, endAngle, cc) {\n        this.nextID();\n        SVGForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n        return this;\n    }\n    static square(ctx, pt, halfsize) {\n        let elem = SVGSpace.svgElement(ctx.group, \"rect\", SVGForm.getID(ctx));\n        DOMSpace.setAttr(elem, {\n            x: pt[0] - halfsize,\n            y: pt[1] - halfsize,\n            width: halfsize * 2,\n            height: halfsize * 2,\n            'class': `pts-svgform pts-square ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    square(pt, halfsize) {\n        this.nextID();\n        SVGForm.square(this._ctx, pt, halfsize);\n        return this;\n    }\n    static line(ctx, pts) {\n        if (!this._checkSize(pts))\n            return;\n        if (pts.length > 2)\n            return SVGForm._poly(ctx, pts, false);\n        let elem = SVGSpace.svgElement(ctx.group, \"line\", SVGForm.getID(ctx));\n        DOMSpace.setAttr(elem, {\n            x1: pts[0][0],\n            y1: pts[0][1],\n            x2: pts[1][0],\n            y2: pts[1][1],\n            'class': `pts-svgform pts-line ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    line(pts) {\n        this.nextID();\n        SVGForm.line(this._ctx, pts);\n        return this;\n    }\n    static _poly(ctx, pts, closePath = true) {\n        if (!this._checkSize(pts))\n            return;\n        let elem = SVGSpace.svgElement(ctx.group, ((closePath) ? \"polygon\" : \"polyline\"), SVGForm.getID(ctx));\n        let points = pts.reduce((a, p) => a + `${p[0]},${p[1]} `, \"\");\n        DOMSpace.setAttr(elem, {\n            points: points,\n            'class': `pts-svgform pts-polygon ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    static polygon(ctx, pts) {\n        return SVGForm._poly(ctx, pts, true);\n    }\n    polygon(pts) {\n        this.nextID();\n        SVGForm.polygon(this._ctx, pts);\n        return this;\n    }\n    static rect(ctx, pts) {\n        if (!this._checkSize(pts))\n            return;\n        let elem = SVGSpace.svgElement(ctx.group, \"rect\", SVGForm.getID(ctx));\n        let bound = Group.fromArray(pts).boundingBox();\n        let size = Rectangle.size(bound);\n        DOMSpace.setAttr(elem, {\n            x: bound[0][0],\n            y: bound[0][1],\n            width: size[0],\n            height: size[1],\n            'class': `pts-svgform pts-rect ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    rect(pts) {\n        this.nextID();\n        SVGForm.rect(this._ctx, pts);\n        return this;\n    }\n    static text(ctx, pt, txt) {\n        let elem = SVGSpace.svgElement(ctx.group, \"text\", SVGForm.getID(ctx));\n        DOMSpace.setAttr(elem, {\n            \"pointer-events\": \"none\",\n            x: pt[0],\n            y: pt[1],\n            dx: 0, dy: 0,\n            'class': `pts-svgform pts-text ${ctx.currentClass}`,\n        });\n        elem.textContent = txt;\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    text(pt, txt) {\n        this.nextID();\n        SVGForm.text(this._ctx, pt, txt);\n        return this;\n    }\n    log(txt) {\n        this.fill(\"#000\").stroke(\"#fff\", 0.5).text([10, 14], txt);\n        return this;\n    }\n}\nSVGForm.groupID = 0;\nSVGForm.domID = 0;\n//# sourceMappingURL=Svg.js.map","import { Pt, Group, Bound } from \"./Pt\";\nimport { Polygon, Circle } from \"./Op\";\nexport class World {\n    constructor(bound, friction = 1, gravity = 0) {\n        this._lastTime = null;\n        this._gravity = new Pt();\n        this._friction = 1;\n        this._damping = 0.75;\n        this._particles = [];\n        this._bodies = [];\n        this._names = { p: {}, b: {} };\n        this._bound = Bound.fromGroup(bound);\n        this._friction = friction;\n        this._gravity = (typeof gravity === \"number\") ? new Pt(0, gravity) : new Pt(gravity);\n        return this;\n    }\n    get gravity() { return this._gravity; }\n    set gravity(g) { this._gravity = g; }\n    get friction() { return this._friction; }\n    set friction(f) { this._friction = f; }\n    get damping() { return this._damping; }\n    set damping(f) { this._damping = f; }\n    get bodyCount() { return this._bodies.length; }\n    get particleCount() { return this._particles.length; }\n    body(id) { return this._bodies[(typeof id === \"string\") ? this._names.b[id] : id]; }\n    particle(id) { return this._particles[(typeof id === \"string\") ? this._names.p[id] : id]; }\n    update(ms) {\n        let dt = ms / 1000;\n        this._updateParticles(dt);\n        this._updateBodies(dt);\n    }\n    drawParticles(fn) {\n        this._drawParticles = fn;\n    }\n    drawBodies(fn) {\n        this._drawBodies = fn;\n    }\n    add(p, name) {\n        if (p instanceof Body) {\n            this._bodies.push(p);\n            if (name)\n                this._names.b[name] = this._bodies.length - 1;\n        }\n        else {\n            this._particles.push(p);\n            if (name)\n                this._names.p[name] = this._particles.length - 1;\n        }\n        return this;\n    }\n    remove(which, index, count = 1) {\n        let param = (index < 0) ? [index * -1 - 1, count] : [index, count];\n        if (which == \"body\") {\n            this._bodies.splice(param[0], param[1]);\n        }\n        else {\n            this._particles.splice(param[0], param[1]);\n        }\n        return this;\n    }\n    static edgeConstraint(p1, p2, dist, stiff = 1, precise = false) {\n        const m1 = 1 / (p1.mass || 1);\n        const m2 = 1 / (p2.mass || 1);\n        const mm = m1 + m2;\n        let delta = p2.$subtract(p1);\n        let distSq = dist * dist;\n        let d = (precise) ? (dist / delta.magnitude() - 1) : (distSq / (delta.dot(delta) + distSq) - 0.5);\n        let f = delta.$multiply(d * stiff);\n        p1.subtract(f.$multiply(m1 / mm));\n        p2.add(f.$multiply(m2 / mm));\n        return p1;\n    }\n    static boundConstraint(p, rect, damping = 0.75) {\n        let bound = rect.boundingBox();\n        let np = p.$min(bound[1].subtract(p.radius)).$max(bound[0].add(p.radius));\n        if (np[0] === bound[0][0] || np[0] === bound[1][0]) {\n            let c = p.changed.$multiply(damping);\n            p.previous = np.$subtract(new Pt(-c[0], c[1]));\n        }\n        else if (np[1] === bound[0][1] || np[1] === bound[1][1]) {\n            let c = p.changed.$multiply(damping);\n            p.previous = np.$subtract(new Pt(c[0], -c[1]));\n        }\n        p.to(np);\n    }\n    integrate(p, dt, prevDt) {\n        p.addForce(this._gravity);\n        p.verlet(dt, this._friction, prevDt);\n        return p;\n    }\n    _updateParticles(dt) {\n        for (let i = 0, len = this._particles.length; i < len; i++) {\n            let p = this._particles[i];\n            this.integrate(p, dt, this._lastTime);\n            World.boundConstraint(p, this._bound, this._damping);\n            for (let k = i + 1; k < len; k++) {\n                if (i !== k) {\n                    let p2 = this._particles[k];\n                    p.collide(p2, this._damping);\n                }\n            }\n            if (this._drawParticles)\n                this._drawParticles(p, i);\n        }\n        this._lastTime = dt;\n    }\n    _updateBodies(dt) {\n        for (let i = 0, len = this._bodies.length; i < len; i++) {\n            let b = this._bodies[i];\n            for (let k = 0, klen = b.length; k < klen; k++) {\n                let bk = b[k];\n                World.boundConstraint(bk, this._bound, this._damping);\n                this.integrate(bk, dt, this._lastTime);\n            }\n            for (let k = i + 1; k < len; k++) {\n                b.processBody(this._bodies[k]);\n            }\n            for (let m = 0, mlen = this._particles.length; m < mlen; m++) {\n                b.processParticle(this._particles[m]);\n            }\n            b.processEdges();\n            if (this._drawBodies)\n                this._drawBodies(b, i);\n        }\n    }\n}\nexport class Particle extends Pt {\n    constructor(...args) {\n        super(...args);\n        this._mass = 1;\n        this._radius = 0;\n        this._force = new Pt();\n        this._prev = new Pt();\n        this._lock = false;\n        this._prev = this.clone();\n    }\n    get mass() { return this._mass; }\n    set mass(m) { this._mass = m; }\n    get radius() { return this._radius; }\n    set radius(f) { this._radius = f; }\n    get previous() { return this._prev; }\n    set previous(p) { this._prev = p; }\n    get force() { return this._force; }\n    set force(g) { this._force = g; }\n    get body() { return this._body; }\n    set body(b) { this._body = b; }\n    get lock() { return this._lock; }\n    set lock(b) {\n        this._lock = b;\n        this._lockPt = new Pt(this);\n    }\n    get changed() { return this.$subtract(this._prev); }\n    set position(p) {\n        this.previous.to(this);\n        if (this._lock)\n            this._lockPt = p;\n        this.to(p);\n    }\n    size(r) {\n        this._mass = r;\n        this._radius = r;\n        return this;\n    }\n    addForce(...args) {\n        this._force.add(...args);\n        return this._force;\n    }\n    verlet(dt, friction, lastDt) {\n        if (this._lock) {\n            this.to(this._lockPt);\n        }\n        else {\n            let lt = (lastDt) ? lastDt : dt;\n            let a = this._force.multiply(dt * (dt + lt) / 2);\n            let v = this.changed.multiply(friction * dt / lt).add(a);\n            this._prev = this.clone();\n            this.add(v);\n            this._force = new Pt();\n        }\n        return this;\n    }\n    hit(...args) {\n        this._prev.subtract(new Pt(...args).$divide(Math.sqrt(this._mass)));\n        return this;\n    }\n    collide(p2, damp = 1) {\n        let p1 = this;\n        let dp = p1.$subtract(p2);\n        let distSq = dp.magnitudeSq();\n        let dr = p1.radius + p2.radius;\n        if (distSq < dr * dr) {\n            let c1 = p1.changed;\n            let c2 = p2.changed;\n            let dist = Math.sqrt(distSq);\n            let d = dp.$multiply(((dist - dr) / dist) / 2);\n            let np1 = p1.$subtract(d);\n            let np2 = p2.$add(d);\n            p1.to(np1);\n            p2.to(np2);\n            let f1 = damp * dp.dot(c1) / distSq;\n            let f2 = damp * dp.dot(c2) / distSq;\n            let dm1 = p1.mass / (p1.mass + p2.mass);\n            let dm2 = p2.mass / (p1.mass + p2.mass);\n            c1.add(new Pt(f2 * dp[0] - f1 * dp[0], f2 * dp[1] - f1 * dp[1]).$multiply(dm2));\n            c2.add(new Pt(f1 * dp[0] - f2 * dp[0], f1 * dp[1] - f2 * dp[1]).$multiply(dm1));\n            p1.previous = p1.$subtract(c1);\n            p2.previous = p2.$subtract(c2);\n        }\n    }\n    toString() {\n        return `Particle: ${this[0]} ${this[1]} | previous ${this._prev[0]} ${this._prev[1]} | mass ${this._mass}`;\n    }\n}\nexport class Body extends Group {\n    constructor() {\n        super();\n        this._cs = [];\n        this._stiff = 1;\n        this._locks = {};\n        this._mass = 1;\n    }\n    static fromGroup(list, stiff = 1, autoLink = true, autoMass = true) {\n        let b = new Body().init(list);\n        if (autoLink)\n            b.linkAll(stiff);\n        if (autoMass)\n            b.autoMass();\n        return b;\n    }\n    init(list, stiff = 1) {\n        let c = new Pt();\n        for (let i = 0, len = list.length; i < len; i++) {\n            let p = new Particle(list[i]);\n            p.body = this;\n            c.add(list[i]);\n            this.push(p);\n        }\n        this._stiff = stiff;\n        return this;\n    }\n    get mass() { return this._mass; }\n    set mass(m) {\n        this._mass = m;\n        for (let i = 0, len = this.length; i < len; i++) {\n            this[i].mass = this._mass;\n        }\n    }\n    autoMass() {\n        this.mass = Math.sqrt(Polygon.area(this)) / 10;\n        return this;\n    }\n    link(index1, index2, stiff) {\n        if (index1 < 0 || index1 >= this.length)\n            throw new Error(\"index1 is not in the Group's indices\");\n        if (index2 < 0 || index2 >= this.length)\n            throw new Error(\"index1 is not in the Group's indices\");\n        let d = this[index1].$subtract(this[index2]).magnitude();\n        this._cs.push([index1, index2, d, stiff || this._stiff]);\n        return this;\n    }\n    linkAll(stiff) {\n        let half = this.length / 2;\n        for (let i = 0, len = this.length; i < len; i++) {\n            let n = (i >= len - 1) ? 0 : i + 1;\n            this.link(i, n, stiff);\n            if (len > 4) {\n                let nd = (Math.floor(half / 2)) + 1;\n                let n2 = (i >= len - nd) ? i % len : i + nd;\n                this.link(i, n2, stiff);\n            }\n            if (i <= half - 1) {\n                this.link(i, Math.min(this.length - 1, i + Math.floor(half)));\n            }\n        }\n    }\n    linksToLines() {\n        let gs = [];\n        for (let i = 0, len = this._cs.length; i < len; i++) {\n            let ln = this._cs[i];\n            gs.push(new Group(this[ln[0]], this[ln[1]]));\n        }\n        return gs;\n    }\n    processEdges() {\n        for (let i = 0, len = this._cs.length; i < len; i++) {\n            let [m, n, d, s] = this._cs[i];\n            World.edgeConstraint(this[m], this[n], d, s);\n        }\n    }\n    processBody(b) {\n        let b1 = this;\n        let b2 = b;\n        let hit = Polygon.hasIntersectPolygon(b1, b2);\n        if (hit) {\n            let cv = hit.normal.$multiply(hit.dist);\n            let t;\n            let eg = hit.edge;\n            if (Math.abs(eg[0][0] - eg[1][0]) > Math.abs(eg[0][1] - eg[1][1])) {\n                t = (hit.vertex[0] - cv[0] - eg[0][0]) / (eg[1][0] - eg[0][0]);\n            }\n            else {\n                t = (hit.vertex[1] - cv[1] - eg[0][1]) / (eg[1][1] - eg[0][1]);\n            }\n            let lambda = 1 / (t * t + (1 - t) * (1 - t));\n            let m0 = hit.vertex.body.mass || 1;\n            let m1 = hit.edge[0].body.mass || 1;\n            let mr0 = m0 / (m0 + m1);\n            let mr1 = m1 / (m0 + m1);\n            eg[0].subtract(cv.$multiply(mr0 * (1 - t) * lambda / 2));\n            eg[1].subtract(cv.$multiply(mr0 * t * lambda / 2));\n            hit.vertex.add(cv.$multiply(mr1));\n        }\n    }\n    processParticle(b) {\n        let b1 = this;\n        let b2 = b;\n        let hit = Polygon.hasIntersectCircle(b1, Circle.fromCenter(b, b.radius));\n        if (hit) {\n            let cv = hit.normal.$multiply(hit.dist);\n            let t;\n            let eg = hit.edge;\n            if (Math.abs(eg[0][0] - eg[1][0]) > Math.abs(eg[0][1] - eg[1][1])) {\n                t = (hit.vertex[0] - cv[0] - eg[0][0]) / (eg[1][0] - eg[0][0]);\n            }\n            else {\n                t = (hit.vertex[1] - cv[1] - eg[0][1]) / (eg[1][1] - eg[0][1]);\n            }\n            let lambda = 1 / (t * t + (1 - t) * (1 - t));\n            let m0 = hit.vertex.mass || b2.mass || 1;\n            let m1 = hit.edge[0].body.mass || 1;\n            let mr0 = m0 / (m0 + m1);\n            let mr1 = m1 / (m0 + m1);\n            eg[0].subtract(cv.$multiply(mr0 * (1 - t) * lambda / 2));\n            eg[1].subtract(cv.$multiply(mr0 * t * lambda / 2));\n            let c1 = b.changed.add(cv.$multiply(mr1));\n            b.previous = b.$subtract(c1);\n        }\n    }\n}\n//# sourceMappingURL=Physics.js.map","export * from \"./Canvas\";\nexport * from \"./Create\";\nexport * from \"./Form\";\nexport * from \"./LinearAlgebra\";\nexport * from \"./Num\";\nexport * from \"./Op\";\nexport * from \"./Pt\";\nexport * from \"./Space\";\nexport * from \"./Color\";\nexport * from \"./Util\";\nexport * from \"./Dom\";\nexport * from \"./Svg\";\nexport * from \"./Typography\";\nexport * from \"./Physics\";\n//# sourceMappingURL=_module.js.map"],"sourceRoot":""}