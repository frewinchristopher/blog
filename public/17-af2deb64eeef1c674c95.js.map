{"version":3,"sources":["webpack:///./node_modules/gatsby/node_modules/core-js/modules/es6.array.sort.js","webpack:///./node_modules/pts/dist/es2015/Util.js","webpack:///./node_modules/pts/dist/es2015/LinearAlgebra.js","webpack:///./node_modules/pts/dist/es2015/Op.js","webpack:///./node_modules/pts/dist/es2015/Num.js","webpack:///./node_modules/pts/dist/es2015/Pt.js","webpack:///./node_modules/pts/dist/es2015/UI.js","webpack:///./node_modules/pts/dist/es2015/Space.js","webpack:///./node_modules/pts/dist/es2015/Form.js","webpack:///./node_modules/pts/dist/es2015/Typography.js","webpack:///./node_modules/pts/dist/es2015/Canvas.js","webpack:///./node_modules/pts/dist/es2015/Create.js","webpack:///./node_modules/pts/dist/es2015/Color.js","webpack:///./node_modules/pts/dist/es2015/Dom.js","webpack:///./node_modules/pts/dist/es2015/Svg.js","webpack:///./node_modules/pts/dist/es2015/Physics.js","webpack:///./node_modules/pts/dist/es2015/_module.js"],"names":["$export","__webpack_require__","aFunction","toObject","fails","$sort","sort","test","P","F","undefined","comparefn","call","this","Const","xy","yz","xz","xyz","horizontal","vertical","identical","right","bottom_right","bottom","bottom_left","left","top_left","top","top_right","epsilon","max","Number","MAX_VALUE","min","MIN_VALUE","pi","Math","PI","two_pi","half_pi","quarter_pi","one_degree","rad_to_deg","deg_to_rad","gravity","newton","gaussian","Util_Util","[object Object]","lv","_warnLevel","args","length","pos","isArray","Array","ArrayBuffer","isView","prototype","slice","a","p","i","push","message","defaultReturn","warnLevel","Error","console","warn","range","start","floor","random","pts","size","stride","loopBack","st","chunks","g","concat","flattenAsGroup","arr","Pt_Group","apply","b","op","result","len","k","lenB","arrays","z","callback","c","fn","step","temp","LinearAlgebra_Vec","toString","d","Pt_Pt","sqrt","dot","magnitude","m","divide","map","abs","ceil","round","index","value","s","LinearAlgebra_Mat","isNum","$add","transposed","elementwise","ai","alen","$multiply","transpose","make","bi","blen","defaultValue","useLongest","ps","reduce","zipSlice","zip","pt","x","y","cosA","sinA","tanX","tanY","sx","sy","at","scale2DMatrix","rotate2DMatrix","shear2DMatrix","p1","p2","intercept","Op_Line","yi","ang2","atan","slope","cos","sin","_errorLength","obj","param","_errorOutofBound","anchor","angle","toAngle","xi","line","p3","threshold","to","$subtract","$cross","equals","magnitudeSq","asProjection","proj","$project","perpendicularFromPt","la","lb","pa","pb","y1","px","py","intersectRay2D","Num_Geom","withinBound","ray","lineOrRay","poly","sourceIsRay","intersectLineWithRay2D","intersectLine2D","next","lines1","lines2","isRay","group","lenk","_ip","gridPt","t","subtract","intersectGridWithRay2D","gg","rect","box","boundingBox","fromPtArray","Op_Rectangle","hasIntersectRect2D","intersectLines2D","sides","num","interpolate","cropAsCircle","ls","unit","multiply","fromCenter","sideIdx","graphic","atTail","perpendicular","add","$min","$max","topLeft","widthOrSize","height","fromTopLeft","center","half","within","Op_Circle","fromRect","enclose","maxValue","minValue","p0","corners","rects","merged","flatten","_center","ratio","asRows","mid","Num_Num","lerp","rect1","rect2","resetBoundingBox","r","radius","f","disc","discSqrt","t1","t2","circle","dv","dr2","dr","ar","br","ar2","br2","clone","h","ang","inc","Op_Triangle","toTriangle","fromCircle","Op_Polygon","midpoints","opp","oppositeSide","altitude","bisector","incenter","area","perimeter","total","md","medial","circumcenter","centroid","idx","closePath","sp","split","lines","gs","adjacentSides","mag","segments","det","sorted","dq","bot","hull","originIndex","_near","_item","unitAxis","n","poly1","poly2","projectAxis","ln","lineAt","info","which","dist","normal","edge","vertex","minDist","MAX_SAFE_INTEGER","axis","_axisOverlap","plen","b1","b2","c1","c2","smallest","lp","ins","intersectPolygon2D","polys","boxes","unshift","val","sum","currA","currB","targetA","targetB","normalizeValue","boundValue","radian","minPt","maxPt","average","ptOrIndex","direction","method","boundPt1","boundPt2","bounds","da","db","$cross2D","scale","scs","lenP","rotateAt2DMatrix","$take","transform2D","shearAt2DMatrix","tanx","tan","tany","mat","reflectAt2DMatrix","Float64Array","table","rad","boundAngle","toDegree","UIShape","PtBaseArray","Float32Array","super","getArgs","dimensions","randomize","fill","id","_id","w","anchorFromPt","change","self","params","fns","_ops","toArray","cross2D","cross","atan2","boundRadian","rotate2D","shear2D","reflect2D","join","p4","q1","q2","q3","q4","list","from","chunkSize","splice","count","pts_per_segment","clamp","chunk","tc","moveBy","dim","desc","ptFn","forEachPt","Bound","_size","_topLeft","_bottomRight","_inited","init","width","_updateSize","_updateCenter","_updatePosFromTop","_updatePosFromCenter","bottomRight","depth","inited","UIPointerActions","up","down","move","drag","drop","over","out","Space_Space","bound","_time","prev","diff","end","players","playerCount","_animID","_pause","_refresh","_pointer","_isReady","_playing","player","animate","pid","animateID","resize","time","requestAnimationFrame","play","bind","playItems","err","cancelAnimationFrame","clear","toggle","duration","stop","context","_renderFunc","customRendering","isPlaying","outerBound","innerBound","Space_MultiTouchSpace","arguments","_pressed","_dragged","_hasMouse","_hasTouch","pointer","evt","_canvas","addEventListener","removeEventListener","_bind","bindCanvas","_mouseDown","_mouseUp","_mouseOver","_mouseOut","_mouseMove","unbindCanvas","_touchMove","ts","item","pageX","pageY","type","MouseEvent","hasOwnProperty","v","action","changedTouches","touch","_mouseAction","preventDefault","Form_Form","_ready","ready","required","VisualForm","_filled","_stroked","_font","Font","filled","stroked","currentFont","groups","shape","rest","stroke","linejoin","linecap","point","_multiple","face","weight","style","lineHeight","Typography_Typography","samples","distribution","avg","str","tail","trim","substr","byHeight","nh","defaultSize","Canvas_CanvasSpace","elem","_pixelScale","_autoResize","_bgcolor","_offscreen","_initialResize","_selector","Element","document","querySelector","nodeName","toLowerCase","_container","_createElement","appendChild","parentElement","body","setTimeout","_ctx","getContext","createElement","setAttribute","_resizeHandler","dispatchEvent","Event","opt","bgcolor","autoResize","retina","r1","window","devicePixelRatio","r2","webkitBackingStorePixelRatio","mozBackingStorePixelRatio","msBackingStorePixelRatio","oBackingStorePixelRatio","backingStorePixelRatio","offscreen","_offCanvas","_offCtx","auto","translate","render","playOnce","getBoundingClientRect","fromBoundingRect","pageXOffset","pageYOffset","background","bg","pixelScale","hasOffscreen","offscreenCtx","offscreenCanvas","Canvas_CanvasForm","element","parent","ctx","lastColor","fillStyle","fillRect","clearRect","save","restore","space","_style","strokeStyle","lineWidth","lineJoin","lineCap","_space","font","off","clearOffscreen","offset","drawImage","sizeOrFont","family","_estimateTextWidth","fontWidthEstimate","estimate","textWidthEstimator","measureText","truncate","getTextWidth","textAlign","_paint","beginPath","arc","startAngle","endAngle","cc","halfsize","x1","x2","y2","moveTo","lineTo","square","polygon","img","target","orig","original","image","txt","maxWidth","fillText","text","verticalAlign","overrideBaseline","textBaseline","_textTruncate","_textAlign","crop","lstep","nextLine","sub","buffer","newln","indexOf","dt","lastIndexOf","lsize","lbox","lpad","alignment","baseline","Create_Create","subpoints","columns","rows","orientation","$divide","dx","dy","seed","np","Create_Noise","initNoise","Create_Delaunay","grad3","permTable","perm","_n","j","n00","n01","n10","n11","_fade","tx","_mesh","triangleOnly","indices","_superTriangle","opened","_circum","closed","tris","edges","circum","triangle","_dedupe","o","_cache","vs","neighborPts","cs","sortEdges","dmax","tri","_triangle","circumcircle","Color_Color","_mode","_isNorm","hex","alpha","substring","hexVal","parseInt","toMode","mode","ranges","rgb","rgba","convert","fname","toUpperCase","l","u","normalized","toNorm","mapToRange","normalize","format","_hex","normalizedInput","normalizedOutput","$normalize","hsl","q","sc","hsb","XYZtoLAB","RGBtoXYZ","lab","XYZtoRGB","LABtoXYZ","LABtoLCH","RGBtoLAB","lch","LABtoRGB","LCHtoLAB","XYZtoLUV","luv","LUVtoXYZ","pow","D65","cy","nnn","refU","refV","L","cubeY","toRadian","Dom_DOMSpace","_css","appendTo","refresh","styles","innerHTML","backgroundColor","key","update","data","HTMLSpace","Dom_HTMLForm","name","autoClass","querySelectorAll","scopeID","forEach","el","parentNode","removeChild","remove","removeAll","groupID","groupCount","currentID","currentClass","border-color","color","border-width","border-radius","border-style","position","fontSize","fontFamily","styleTo","group_id","nextID","updateScope","domID","setAttr","htmlElement","getID","class","rectStyle","_checkSize","textContent","Svg_SVGSpace","svgElement","Svg_SVGForm","viewBox","xmlns","version","createElementNS","stroke-width","stroke-linejoin","stroke-linecap","cx","largeArc","sweep","_poly","points","fromArray","pointer-events","Physics_World","friction","_lastTime","_gravity","_friction","_damping","_particles","_bodies","_names","_bound","fromGroup","damping","bodyCount","particleCount","ms","_updateParticles","_updateBodies","_drawParticles","_drawBodies","Physics_Body","stiff","precise","m1","mass","m2","mm","delta","distSq","changed","previous","prevDt","addForce","verlet","integrate","boundConstraint","collide","klen","bk","processBody","mlen","processParticle","processEdges","Physics_Particle","_mass","_radius","_force","_prev","_lock","force","_body","lock","_lockPt","lastDt","lt","damp","dp","np1","np2","f1","f2","dm1","dm2","_cs","_stiff","_locks","autoLink","autoMass","linkAll","index1","index2","link","nd","n2","edgeConstraint","hit","hasIntersectPolygon","cv","eg","lambda","m0","mr0","mr1","hasIntersectCircle","__webpack_exports__"],"mappings":"2FACA,IAAAA,EAAcC,EAAQ,GACtBC,EAAgBD,EAAQ,IACxBE,EAAeF,EAAQ,IACvBG,EAAYH,EAAQ,IACpBI,EAAA,GAAAC,KACAC,EAAA,QAEAP,IAAAQ,EAAAR,EAAAS,GAAAL,EAAA,WAEAG,EAAAD,UAAAI,OACCN,EAAA,WAEDG,EAAAD,KAAA,UAEOL,EAAQ,GAARA,CAA0BI,IAAA,SAEjCC,KAAA,SAAAK,GACA,YAAAD,IAAAC,EACAN,EAAAO,KAAAT,EAAAU,OACAR,EAAAO,KAAAT,EAAAU,MAAAX,EAAAS,+DCnBO,MAAAG,EAAA,CACPC,GAAA,KACAC,GAAA,KACAC,GAAA,KACAC,IAAA,MACAC,WAAA,EACAC,SAAA,EACAC,UAAA,EACAC,MAAA,EACAC,aAAA,EACAC,OAAA,EACAC,YAAA,EACAC,KAAA,EACAC,SAAA,EACAC,IAAA,EACAC,UAAA,EACAC,QAAA,KACAC,IAAAC,OAAAC,UACAC,IAAAF,OAAAG,UACAC,GAAAC,KAAAC,GACAC,OAAA,kBACAC,QAAA,mBACAC,WAAA,kBACAC,WAAA,oBACAC,WAAA,kBACAC,WAAA,oBACAC,QAAA,KACAC,OAAA,OACAC,SAAA,mBAEO,MAAMC,EACbC,iBAAAC,GAIA,OAHAA,IACYF,EAAIG,WAAAD,GAEDF,EAAIG,WAEnBF,eAAAG,GACA,GAAAA,EAAAC,OAAA,EACA,SACA,IAAAC,EAAA,GACAC,EAAAC,MAAAD,QAAAH,EAAA,KAAAK,YAAAC,OAAAN,EAAA,IACA,oBAAAA,EAAA,GACAE,EAAAE,MAAAG,UAAAC,MAAAhD,KAAAwC,QAEA,oBAAAA,EAAA,IAAAG,EASAA,IACAD,EAAA,GAAAM,MAAAhD,KAAAwC,EAAA,SAVA,CACA,IAAAS,EAAA,kBACAC,EAAAV,EAAA,GACA,QAAAW,EAAA,EAA2BA,EAAAF,EAAAR,WAC3BS,EAAAT,QAAAU,GAAAD,EAAAT,SAAAQ,EAAAE,KAAAD,GADyCC,IAGzCT,EAAAU,KAAAF,EAAAD,EAAAE,KAMA,OAAAT,EAEAL,YAAAgB,EAAA,QAAAC,GACA,GAAgB,SAAJlB,EAAImB,YAChB,UAAAC,MAAAH,GAKA,MAHqB,QAAJjB,EAAImB,aACrBE,QAAAC,KAAAL,GAEAC,EAEAjB,iBAAAsB,EAAAC,EAAA,GACA,OAAAnC,KAAAoC,MAAApC,KAAAqC,SAAAH,GAAAC,EAEAvB,aAAA0B,EAAAC,EAAAC,EAAAC,GAAA,GACA,IAAAC,EAAAF,GAAAD,EACAI,EAAA,GACA,QAAAjB,EAAA,EAAuBA,EAAAY,EAAAtB,OAAgBU,IACvC,GAAAA,EAAAgB,EAAAH,EAAAD,EAAAtB,OAAA,CACA,IAAAyB,EAMA,MANA,CACA,IAAAG,EAAAN,EAAAf,MAAAG,EAAAgB,GACAE,IAAAC,OAAAP,EAAAf,MAAA,GAAAG,EAAAgB,EAAAH,OACAI,EAAAhB,KAAAiB,SAOAD,EAAAhB,KAAAW,EAAAf,MAAAG,EAAAgB,EAAAhB,EAAAgB,EAAAH,IAGA,OAAAI,EAEA/B,eAAA0B,EAAAQ,GAAA,GACA,IAAAC,EAAA,MAAyCC,EAAK,IAAA7B,MAC9C,OAAA4B,EAAAF,OAAAI,MAAAF,EAAAT,GAEA1B,eAAAY,EAAA0B,EAAAC,GACA,IAAAC,EAAA,GACA,QAAA1B,EAAA,EAAA2B,EAAA7B,EAAAR,OAAuCU,EAAA2B,EAAS3B,IAChD,QAAA4B,EAAA,EAAAC,EAAAL,EAAAlC,OAA4CsC,EAAAC,EAAUD,IACtDF,EAAAzB,KAAAwB,EAAA3B,EAAAE,GAAAwB,EAAAI,KAGA,OAAAF,EAEAxC,WAAA4C,GACA,IAAAC,EAAA,GACA,QAAA/B,EAAA,EAAA2B,EAAAG,EAAA,GAAAxC,OAA+CU,EAAA2B,EAAS3B,IAAA,CACxD,IAAAD,EAAA,GACA,QAAA6B,EAAA,EAA2BA,EAAAE,EAAAxC,OAAmBsC,IAC9C7B,EAAAE,KAAA6B,EAAAF,GAAA5B,IAEA+B,EAAA9B,KAAAF,GAEA,OAAAgC,EAEA7C,eAAAlB,EAAAG,EAAA,EAAA2C,EAAA,EAAAkB,GACA,IAAAC,EAAA9D,EACA,kBAOA,OANA8D,GAAAnB,IACA9C,IACAiE,EAAA9D,GAAA8D,EAAAjE,IAEAgE,GACAA,EAAAC,GACAA,GAGA/C,gBAAAgD,EAAA1B,EAAAC,EAAA,EAAA0B,EAAA,GACA,IAAAC,EAAA,GACA,QAAApC,EAAAS,EAAAkB,EAAAnB,EAAwCR,EAAA2B,EAAS3B,GAAAmC,EACjDC,EAAApC,GAAAkC,EAAAlC,GAEA,OAAAoC,GAGAnD,EAAIG,WAAA,OCtIG,MAAMiD,EACbnD,WAAAY,EAAA0B,GACA,oBAAAA,EACA,QAAAxB,EAAA,EAAA2B,EAAA7B,EAAAR,OAA2CU,EAAA2B,EAAS3B,IACpDF,EAAAE,IAAAwB,OAGA,QAAAxB,EAAA,EAAA2B,EAAA7B,EAAAR,OAA2CU,EAAA2B,EAAS3B,IACpDF,EAAAE,IAAAwB,EAAAxB,IAAA,EAEA,OAAAF,EAEAZ,gBAAAY,EAAA0B,GACA,oBAAAA,EACA,QAAAxB,EAAA,EAAA2B,EAAA7B,EAAAR,OAA2CU,EAAA2B,EAAS3B,IACpDF,EAAAE,IAAAwB,OAGA,QAAAxB,EAAA,EAAA2B,EAAA7B,EAAAR,OAA2CU,EAAA2B,EAAS3B,IACpDF,EAAAE,IAAAwB,EAAAxB,IAAA,EAEA,OAAAF,EAEAZ,gBAAAY,EAAA0B,GACA,oBAAAA,EACA,QAAAxB,EAAA,EAAA2B,EAAA7B,EAAAR,OAA2CU,EAAA2B,EAAS3B,IACpDF,EAAAE,IAAAwB,MAEA,CACA,GAAA1B,EAAAR,QAAAkC,EAAAlC,OACA,UAAAe,8EAAwGP,EAAAwC,4BAA8Bd,EAAAc,cAEtI,QAAAtC,EAAA,EAAA2B,EAAA7B,EAAAR,OAA2CU,EAAA2B,EAAS3B,IACpDF,EAAAE,IAAAwB,EAAAxB,GAEA,OAAAF,EAEAZ,cAAAY,EAAA0B,GACA,oBAAAA,EAAA,CACA,OAAAA,EACA,UAAAnB,MAAA,yBACA,QAAAL,EAAA,EAAA2B,EAAA7B,EAAAR,OAA2CU,EAAA2B,EAAS3B,IACpDF,EAAAE,IAAAwB,MAEA,CACA,GAAA1B,EAAAR,QAAAkC,EAAAlC,OACA,UAAAe,4EAAsGP,EAAAwC,wBAA0Bd,EAAAc,cAEhI,QAAAtC,EAAA,EAAA2B,EAAA7B,EAAAR,OAA2CU,EAAA2B,EAAS3B,IACpDF,EAAAE,IAAAwB,EAAAxB,GAEA,OAAAF,EAEAZ,WAAAY,EAAA0B,GACA,GAAA1B,EAAAR,QAAAkC,EAAAlC,OACA,UAAAe,MAAA,6BACA,IAAAkC,EAAA,EACA,QAAAvC,EAAA,EAAA2B,EAAA7B,EAAAR,OAAuCU,EAAA2B,EAAS3B,IAChDuC,GAAAzC,EAAAE,GAAAwB,EAAAxB,GAEA,OAAAuC,EAEArD,eAAAY,EAAA0B,GACA,OAAA1B,EAAA,GAAA0B,EAAA,GAAA1B,EAAA,GAAA0B,EAAA,GAEAtC,aAAAY,EAAA0B,GACA,WAAmBgB,EAAE1C,EAAA,GAAA0B,EAAA,GAAA1B,EAAA,GAAA0B,EAAA,GAAA1B,EAAA,GAAA0B,EAAA,GAAA1B,EAAA,GAAA0B,EAAA,GAAA1B,EAAA,GAAA0B,EAAA,GAAA1B,EAAA,GAAA0B,EAAA,IAErBtC,iBAAAY,GACA,OAAAxB,KAAAmE,KAAyBJ,EAAGK,IAAA5C,MAE5BZ,YAAAY,EAAA6C,GACA,IAAAC,OAAAjG,IAAAgG,EAA4CN,EAAGM,UAAA7C,GAAA6C,EAC/C,OAAAC,EACA,UAAAvC,MAAA,uDACA,OAAegC,EAAGQ,OAAA/C,EAAA8C,GAElB1D,WAAAY,GACA,OAAeuC,EAAGS,IAAAhD,EAAAxB,KAAAyE,KAElB7D,aAAAY,GACA,OAAeuC,EAAGS,IAAAhD,EAAAxB,KAAAoC,OAElBxB,YAAAY,GACA,OAAeuC,EAAGS,IAAAhD,EAAAxB,KAAA0E,MAElB9D,aAAAY,GACA,OAAeuC,EAAGS,IAAAhD,EAAAxB,KAAA2E,OAElB/D,WAAAY,GACA,IAAA8C,EAAA3E,OAAAG,UACA8E,EAAA,EACA,QAAAlD,EAAA,EAAA2B,EAAA7B,EAAAR,OAAuCU,EAAA2B,EAAS3B,KAChD4C,EAAAtE,KAAAN,IAAA4E,EAAA9C,EAAAE,OACAF,EAAAE,KACAkD,EAAAlD,GAEA,OAAgBmD,MAAAP,EAAAM,SAEhBhE,WAAAY,GACA,IAAA8C,EAAA3E,OAAAC,UACAgF,EAAA,EACA,QAAAlD,EAAA,EAAA2B,EAAA7B,EAAAR,OAAuCU,EAAA2B,EAAS3B,KAChD4C,EAAAtE,KAAAH,IAAAyE,EAAA9C,EAAAE,OACAF,EAAAE,KACAkD,EAAAlD,GAEA,OAAgBmD,MAAAP,EAAAM,SAEhBhE,WAAAY,GACA,IAAAsD,EAAA,EACA,QAAApD,EAAA,EAAA2B,EAAA7B,EAAAR,OAAuCU,EAAA2B,EAAS3B,IAChDoD,GAAAtD,EAAAE,GACA,OAAAoD,EAEAlE,WAAAY,EAAAoC,GACA,QAAAlC,EAAA,EAAA2B,EAAA7B,EAAAR,OAAuCU,EAAA2B,EAAS3B,IAChDF,EAAAE,GAAAkC,EAAApC,EAAAE,KAAAF,GAEA,OAAAA,GAGO,MAAMuD,EACbnE,WAAAY,EAAA0B,GACA,oBAAAA,EAAA,CACA,GAAA1B,EAAA,GAAAR,QAAAkC,EAAA,GAAAlC,OACA,UAAAe,MAAA,6DACA,GAAAP,EAAAR,QAAAkC,EAAAlC,OACA,UAAAe,MAAA,6DAEA,IAAAa,EAAA,IAAoBI,EACpBgC,EAAA,iBAAA9B,EACA,QAAAxB,EAAA,EAAA2B,EAAA7B,EAAAR,OAAuCU,EAAA2B,EAAS3B,IAChDkB,EAAAjB,KAAAH,EAAAE,GAAAuD,KAAA,EAAA/B,IAAAxB,KAEA,OAAAkB,EAEAhC,gBAAAY,EAAA0B,EAAAgC,GAAA,EAAAC,GAAA,GACA,IAAAvC,EAAA,IAAoBI,EACpB,oBAAAE,EACA,GAAAiC,EAAA,CACA,GAAA3D,EAAAR,QAAAkC,EAAAlC,OACA,UAAAe,MAAA,gFACA,QAAAqD,EAAA,EAAAC,EAAA7D,EAAAR,OAAiDoE,EAAAC,EAAWD,IAC5DxC,EAAAjB,KAAAH,EAAA4D,GAAAE,UAAApC,EAAAkC,SAGA,CACA,IAAAF,GAAA1D,EAAA,GAAAR,QAAAkC,EAAAlC,OACA,UAAAe,MAAA,+EACA,GAAAmD,GAAA1D,EAAA,GAAAR,QAAAkC,EAAA,GAAAlC,OACA,UAAAe,MAAA,sFACAmD,IACAhC,EAAwB6B,EAAGQ,UAAArC,IAC3B,QAAAkC,EAAA,EAAAC,EAAA7D,EAAAR,OAAiDoE,EAAAC,EAAWD,IAAA,CAC5D,IAAA3D,EAA4ByC,EAAEsB,KAAAtC,EAAAlC,OAAA,GAC9B,QAAAyE,EAAA,EAAAC,EAAAxC,EAAAlC,OAAqDyE,EAAAC,EAAWD,IAChEhE,EAAAgE,GAAgC1B,EAAGK,IAAA5C,EAAA4D,GAAAlC,EAAAuC,IAEnC7C,EAAAjB,KAAAF,SAKA,QAAA2D,EAAA,EAAAC,EAAA7D,EAAAR,OAA6CoE,EAAAC,EAAWD,IACxDxC,EAAAjB,KAAAH,EAAA4D,GAAAE,UAAApC,IAGA,OAAAN,EAEAhC,gBAAAgC,EAAAgC,EAAAe,GAAA,GACA,IAAAlC,EAAA,GACA,QAAA/B,EAAA,EAAA2B,EAAAT,EAAA5B,OAAuCU,EAAA2B,EAAS3B,IAAA,CAChD,GAAAkB,EAAAlB,GAAAV,OAAA,EAAA4D,IAAA,IAAAe,EACA,cAA+Bf,qBAC/BnB,EAAA9B,KAAAiB,EAAAlB,GAAAkD,IAAAe,GAEA,WAAmBzB,EAAET,GAErB7C,WAAAgC,EAAA+C,GAAA,EAAAC,GAAA,GACA,IAAAC,EAAA,IAAqB7C,EACrBK,EAAA,EAAAT,EAAAkD,OAAA,CAAAtE,EAAA0B,IAAAlD,KAAAN,IAAA8B,EAAA0B,EAAAlC,QAAA,GAAA4B,EAAA,GAAA5B,OACA,QAAAU,EAAA,EAAuBA,EAAA2B,EAAS3B,IAChCmE,EAAAlE,KAAoBoD,EAAGgB,SAAAnD,EAAAlB,EAAAiE,IAEvB,OAAAE,EAEAjF,iBAAAgC,EAAA+C,GAAA,EAAAC,GAAA,GACA,OAAeb,EAAGiB,IAAApD,EAAA+C,EAAAC,GAElBhF,mBAAAqF,EAAA3B,GACA,IAAA4B,EAAAD,EAAA,GAAA3B,EAAA,MAAA2B,EAAA,GAAA3B,EAAA,MAAAA,EAAA,MACA6B,EAAAF,EAAA,GAAA3B,EAAA,MAAA2B,EAAA,GAAA3B,EAAA,MAAAA,EAAA,MACA,WAAmBJ,EAAEgC,EAAAC,GAErBvF,qBAAAsF,EAAAC,GACA,WAAmBnD,EAAK,IAAKkB,EAAEgC,EAAA,SAAehC,EAAE,EAAAiC,EAAA,OAAejC,EAAE,QAEjEtD,sBAAAwF,EAAAC,GACA,WAAmBrD,EAAK,IAAKkB,EAAEkC,EAAAC,EAAA,OAAqBnC,GAAEmC,EAAAD,EAAA,OAAsBlC,EAAE,QAE9EtD,qBAAA0F,EAAAC,GACA,WAAmBvD,EAAK,IAAKkB,EAAE,EAAAoC,EAAA,OAAkBpC,EAAEqC,EAAA,SAAkBrC,EAAE,QAEvEtD,yBAAAsF,EAAAC,GACA,WAAmBnD,EAAK,IAAKkB,EAAE,WAAeA,EAAE,WAAeA,EAAEgC,EAAAC,EAAA,IAEjEvF,uBAAA4F,EAAAC,EAAAC,GACA,IAAApC,EAAgBS,EAAG4B,cAAAH,EAAAC,GAGnB,OAFAnC,EAAA,OAAAoC,EAAA,GAAAF,EAAAE,EAAA,GACApC,EAAA,OAAAoC,EAAA,GAAAD,EAAAC,EAAA,GACApC,EAEA1D,wBAAAwF,EAAAC,EAAAK,GACA,IAAApC,EAAgBS,EAAG6B,eAAAR,EAAAC,GAGnB,OAFA/B,EAAA,MAAAoC,EAAA,MAAAN,GAAAM,EAAA,GAAAL,EACA/B,EAAA,MAAAoC,EAAA,MAAAN,GAAAM,EAAA,GAAAL,EACA/B,EAEA1D,uBAAA0F,EAAAC,EAAAG,GACA,IAAApC,EAAgBS,EAAG8B,cAAAP,EAAAC,GAGnB,OAFAjC,EAAA,OAAAoC,EAAA,GAAAH,EACAjC,EAAA,OAAAoC,EAAA,GAAAJ,EACAhC,EAEA1D,yBAAAkG,EAAAC,GACA,IAAAC,EAAwBC,EAAID,UAAAF,EAAAC,GAC5B,GAAA1I,MAAA2I,EACA,OACA,IAAoB9C,EAAE,UACtB,IAAoBA,EAAE,SACtB,IAAoBA,EAAE,CAAA4C,EAAA,GAAAC,EAAA,UAGtB,CACA,IAAAG,EAAAF,EAAAE,GACAC,EAAA,EAAAnH,KAAAoH,KAAAJ,EAAAK,OACAjB,EAAApG,KAAAsH,IAAAH,GACAd,EAAArG,KAAAuH,IAAAJ,GACA,OACA,IAAoBjD,EAAE,CAAAkC,EAAAC,EAAA,IACtB,IAAoBnC,EAAE,CAAAmC,GAAAD,EAAA,IACtB,IAAoBlC,EAAE,EAAAgD,EAAAb,EAAAa,IAAAd,EAAA,OChPtB,IAAAoB,EAAA,CAAAC,EAAAC,EAAA,aAAgD/G,EAAIsB,KAAA,+BAAAyF,EAAAD,GACpDE,EAAA,CAAAF,EAAAC,EAAA,KAA4C/G,EAAIsB,cAAeyF,6BAAMD,GAC9D,MAAMR,EACbrG,iBAAAgH,EAAAC,EAAAxD,GACA,IAAAzB,EAAA,IAAoBI,EAAK,IAAKkB,EAAE0D,GAAA,IAAc1D,EAAE0D,IAEhD,OADAhF,EAAA,GAAAkF,QAAAD,EAAAxD,GAAA,GACAzB,EAEAhC,aAAAkG,EAAAC,GACA,OAAAA,EAAA,GAAAD,EAAA,WAAAzI,GAAA0I,EAAA,GAAAD,EAAA,KAAAC,EAAA,GAAAD,EAAA,IAEAlG,iBAAAkG,EAAAC,GACA,GAAAA,EAAA,GAAAD,EAAA,MAGA,CACA,IAAAxC,GAAAyC,EAAA,GAAAD,EAAA,KAAAC,EAAA,GAAAD,EAAA,IACAnD,EAAAmD,EAAA,GAAAxC,EAAAwC,EAAA,GACA,OAAoBO,MAAA/C,EAAA4C,GAAAvD,EAAAoE,GAAA,IAAAzD,OAAAjG,GAAAsF,EAAAW,IAGpB1D,kBAAAoH,EAAA/B,GACA,OAAA+B,EAAA,MAAAA,EAAA,QAAA/B,EAAA,GAAA+B,EAAA,QAAA/B,EAAA,GAAA+B,EAAA,QAAAA,EAAA,MAAAA,EAAA,OAEApH,iBAAAkG,EAAAC,EAAAkB,EAAAC,EAAA,KACA,IAAA1G,EAAA,IAAoB0C,EAAE,OAAAiE,GAAArB,GAAAsB,UAAArB,GACtB7D,EAAA,IAAoBgB,EAAE,OAAAiE,GAAArB,GAAAsB,UAAAH,GACtB,OAAAzG,EAAA6G,OAAAnF,GAAAqB,OAAA,KAAA+D,OAAA,IAAmDpE,EAAE,OAAAgE,GAErDtH,iBAAAoH,GACA,OAAAA,EAAAhH,QAAA,EAAAgH,EAAA,GAAAI,UAAAJ,EAAA,IAAA3D,YAAA,EAEAzD,mBAAAoH,GACA,OAAAA,EAAAhH,QAAA,EAAAgH,EAAA,GAAAI,UAAAJ,EAAA,IAAAO,cAAA,EAEA3H,2BAAAoH,EAAA/B,EAAAuC,GAAA,GACA,GAAAR,EAAA,GAAAM,OAAAN,EAAA,IACA,OACA,IAAAxG,EAAAwG,EAAA,GAAAI,UAAAJ,EAAA,IACA9E,EAAA8E,EAAA,GAAAI,UAAAnC,GACAwC,EAAAvF,EAAAkF,UAAA5G,EAAAkH,SAAAxF,IACA,SAAAuF,IAAAxD,KAAAgB,GAEArF,sBAAAoH,EAAA/B,GACA,OAAegB,EAAI0B,oBAAAX,EAAA/B,GAAA,GAAA5B,YAEnBzD,sBAAAgI,EAAAC,GACA,IAAArH,EAAgByF,EAAID,UAAA4B,EAAA,GAAAA,EAAA,IACpB1F,EAAgB+D,EAAID,UAAA6B,EAAA,GAAAA,EAAA,IACpBC,EAAAF,EAAA,GACAG,EAAAF,EAAA,GACA,GAAAxK,MAAAmD,EAAA,CACA,GAAAnD,MAAA6E,EACA,OACA,IAAA8F,GAAA9F,EAAAmE,OAAA0B,EAAA,GAAAD,EAAA,IAAAC,EAAA,GACA,WAAuB7E,EAAE4E,EAAA,GAAAE,GAGzB,GAAA3K,MAAA6E,EAAA,CACA,IAAA8F,GAAAxH,EAAA6F,OAAAyB,EAAA,GAAAC,EAAA,IAAAD,EAAA,GACA,WAA2B5E,EAAE6E,EAAA,GAAAC,GAE7B,GAAA9F,EAAAmE,OAAA7F,EAAA6F,MAAA,CACA,IAAA4B,GAAAzH,EAAA6F,MAAAyB,EAAA,GAAA5F,EAAAmE,MAAA0B,EAAA,GAAAA,EAAA,GAAAD,EAAA,KAAAtH,EAAA6F,MAAAnE,EAAAmE,OACA6B,EAAA1H,EAAA6F,OAAA4B,EAAAH,EAAA,IAAAA,EAAA,GACA,WAA2B5E,EAAE+E,EAAAC,GAG7B,OAAA1H,EAAA0F,IAAAhE,EAAAgE,GACA,IAA+BhD,EAAE4E,EAAA,GAAAA,EAAA,SAGjC,EAKAlI,uBAAAgI,EAAAC,GACA,IAAA5C,EAAiBgB,EAAIkC,eAAAP,EAAAC,GACrB,OAAA5C,GAAsBmD,EAAIC,YAAApD,EAAA2C,EAAA,GAAAA,EAAA,KAAkCQ,EAAIC,YAAApD,EAAA4C,EAAA,GAAAA,EAAA,IAAA5C,OAAA5H,EAEhEuC,8BAAAoH,EAAAsB,GACA,IAAArD,EAAiBgB,EAAIkC,eAAAnB,EAAAsB,GACrB,OAAArD,GAAsBmD,EAAIC,YAAApD,EAAA+B,EAAA,GAAAA,EAAA,IAAA/B,OAAA5H,EAE1BuC,0BAAA2I,EAAAC,EAAAC,GAAA,GACA,IAAA7F,EAAA6F,EAA+BxC,EAAIyC,uBAA0BzC,EAAI0C,gBACjErH,EAAA,IAAsBU,EACtB,QAAAtB,EAAA,EAAA2B,EAAAmG,EAAAxI,OAA0CU,EAAA2B,EAAS3B,IAAA,CACnD,IAAAkI,EAAAlI,IAAA2B,EAAA,IAAA3B,EAAA,EACAuC,EAAAL,EAAA,CAAA4F,EAAA9H,GAAA8H,EAAAI,IAAAL,GACAtF,GACA3B,EAAAX,KAAAsC,GAEA,OAAA3B,EAAAtB,OAAA,EAAAsB,OAAAjE,EAEAuC,wBAAAiJ,EAAAC,EAAAC,GAAA,GACA,IAAAC,EAAA,IAAwBhH,EACxBY,EAAAmG,EAAyB9C,EAAIyC,uBAA0BzC,EAAI0C,gBAC3D,QAAAjI,EAAA,EAAA2B,EAAAwG,EAAA7I,OAA4CU,EAAA2B,EAAS3B,IACrD,QAAA4B,EAAA,EAAA2G,EAAAH,EAAA9I,OAAiDsC,EAAA2G,EAAU3G,IAAA,CAC3D,IAAA4G,EAAAtG,EAAAiG,EAAAnI,GAAAoI,EAAAxG,IACA4G,GACAF,EAAArI,KAAAuI,GAGA,OAAAF,EAEApJ,8BAAA0I,EAAAa,GACA,IAAAC,EAAgBnD,EAAID,UAAA,IAAe9C,EAAEoF,EAAA,IAAAe,SAAAF,GAAA,IAA+BjG,EAAEoF,EAAA,IAAAe,SAAAF,IACtEvH,EAAA,IAAoBI,EAKpB,OAJAoH,KAAArC,IACAnF,EAAAjB,KAAA,IAAuBuC,EAAEiG,EAAA,GAAAC,EAAArC,GAAAoC,EAAA,KACzBC,KAAAlD,IACAtE,EAAAjB,KAAA,IAAuBuC,EAAEiG,EAAA,GAAAA,EAAA,GAAAC,EAAAlD,KACzBtE,EAEAhC,+BAAAoH,EAAAmC,GACA,IAAAvH,EAAgBqE,EAAIqD,uBAAAtC,EAAAmC,GACpBI,EAAA,IAAqBvH,EACrB,QAAAtB,EAAA,EAAA2B,EAAAT,EAAA5B,OAAuCU,EAAA2B,EAAS3B,IAChC0H,EAAIC,YAAAzG,EAAAlB,GAAAsG,EAAA,GAAAA,EAAA,KACpBuC,EAAA5I,KAAAiB,EAAAlB,IAEA,OAAA6I,EAEA3J,uBAAAoH,EAAAwC,GACA,IAAAC,EAAkBrB,EAAIsB,YAAa1H,EAAK2H,YAAA3C,IACxC,OAAa4C,EAASC,mBAAAJ,EAAAD,GAEPvD,EAAI6D,iBAAA,CAAA9C,GAA0B4C,EAASG,MAAAP,IADtD,IAAuBxH,EAGvBpC,iBAAAoH,EAAAgD,GACA,IAAA1I,EAAA,IAAsBU,EACtB,QAAAtB,EAAA,EAAuBA,GAAAsJ,EAAUtJ,IACjCY,EAAAX,KAAqByH,EAAI6B,YAAAjD,EAAA,GAAAA,EAAA,GAAAtG,GAAAsJ,EAAA,KAEzB,OAAA1I,EAEA1B,YAAAoH,EAAAzF,EAAAqC,EAAA,EAAAsG,GAAA,GACA,IACAC,EAAAnD,EADA,IAAApD,EAAA,KACAwD,UAAAJ,EAAApD,IACA,OAAAuG,EAAA,QAAA5I,EAAA,GACA,OAAAyF,EAAApD,GACA,GAAAsG,EAAA,CACA,IAAAjH,EAAAkH,EAAAC,OAAAC,SAAA9I,EAAA,IACA,OAAAyF,EAAApD,GAAAK,KAAAhB,GAEA,CACA,IAAAuG,EAAuBI,EAASU,WAAAtD,EAAApD,GAAArC,GAChCwI,EAAwBH,EAASG,MAAAP,GACjCe,EAAA,EAOA,OALAA,EADAvL,KAAAyE,IAAA0G,EAAA,GAAAA,EAAA,IAAAnL,KAAAyE,IAAAlC,EAAA,GAAAA,EAAA,IACA4I,EAAA,SAGAA,EAAA,SAEmBlE,EAAIkC,eAAA4B,EAAAQ,GAAAvD,IAGvBpH,cAAAoH,EAAAzF,EAAAiJ,EAAA,QAA0DC,GAAA,GAC1D,IACArB,EAAAqB,EAAA,IACAL,EAAApD,EAFAyD,EAAA,KAEArD,UAAAJ,EAAAoC,IACA,OAAAgB,EAAA7C,cACA,WAAuBvF,EACvBoI,SACA,IAAAvF,EAAiBuD,EAAIsC,cAAAN,GAAAC,SAAA9I,EAAA,IAAAoJ,IAAA3D,EAAAoC,IACrB,eAAAoB,GACA3F,EAAA8F,IAAAP,EAAA9F,UAAA/C,EAAA,KACA,IAAuBS,EAAKgF,EAAAoC,GAAAvE,EAAA,GAAAA,EAAA,KAG5B,IAAuB7C,EAAK6C,EAAA,GAAAA,EAAA,IAG5BjF,cAAAoH,GACA,WAAmBhF,EAAKgF,EAAA,GAAA4D,KAAA5D,EAAA,IAAAA,EAAA,GAAA6D,KAAA7D,EAAA,MAGjB,MAAM4C,EACbhK,YAAAkL,EAAAC,EAAAC,GACA,OAAepB,EAASqB,YAAAH,EAAAC,EAAAC,GAExBpL,mBAAAkL,EAAAC,EAAAC,GACA,IAAAzJ,EAAA,iBAAAwJ,EAAA,CAAAA,EAAAC,GAAAD,KACA,WAAmB/I,EAAK,IAAKkB,EAAE4H,GAAA,IAAe5H,EAAE4H,GAAAH,IAAApJ,IAEhD3B,kBAAAsL,EAAAH,EAAAC,GACA,IAAAG,EAAA,iBAAAJ,EAAA,CAAAA,EAAA,GAAAC,GAAAD,GAAA,OAA2G7H,EAAE6H,GAAAxH,OAAA,GAC7G,WAAmBvB,EAAK,IAAKkB,EAAEgI,GAAA7B,SAAA8B,GAAA,IAA6BjI,EAAEgI,GAAAP,IAAAQ,IAE9DvL,gBAAA0B,EAAA8J,GAAA,GACA,OAAeC,EAAMC,SAAAhK,EAAA8J,GAErBxL,gBAAA0B,EAAAiK,GAAA,GACA,IAAAzH,EAAgB8F,EAASrI,KAAAD,GACzBgC,EAAA,EAAAQ,EAAA0H,WAAA3H,MAAAC,EAAA2H,WAAA5H,MACA,OAAe+F,EAASU,WAAYV,EAASsB,OAAA5J,GAAAgC,KAE7C1D,YAAA0B,GACA,OAAAA,EAAA,GAAAuJ,KAAAvJ,EAAA,IAAA+H,SAAA/H,EAAA,GAAAsJ,KAAAtJ,EAAA,KAEA1B,cAAA0B,GACA,IAAAzC,EAAAyC,EAAA,GAAAsJ,KAAAtJ,EAAA,IACA5C,EAAA4C,EAAA,GAAAuJ,KAAAvJ,EAAA,IACA,OAAAzC,EAAA8L,IAAAjM,EAAA0I,UAAAvI,GAAA0E,OAAA,IAEA3D,eAAA4J,GACA,IAAAkC,EAAAlC,EAAA,GAAAoB,KAAApB,EAAA,IACAzD,EAAAyD,EAAA,GAAAqB,KAAArB,EAAA,IACA,WAAmBxH,EAAK0J,EAAA,IAASxI,EAAE6C,EAAAb,EAAAwG,EAAAvG,GAAAY,EAAA,IAAsB7C,EAAEwI,EAAAxG,EAAAa,EAAAZ,IAE3DvF,aAAA4J,GACA,IAAAkC,EAAA5F,EAAAC,EAAAkB,GAA+B2C,EAAS+B,QAAAnC,GACxC,OACA,IAAgBxH,EAAK0J,EAAA5F,GAAA,IAAc9D,EAAK8D,EAAAC,GACxC,IAAgB/D,EAAK+D,EAAAkB,GAAA,IAAcjF,EAAKiF,EAAAyE,IAGxC9L,mBAAAgM,GACA,IAAAC,EAAqBlM,EAAImM,QAAAF,GAAA,GACzB/M,EAAkBqE,EAAEsB,KAAA,EAAA7F,OAAAC,WACpBF,EAAkBwE,EAAEsB,KAAA,EAAA7F,OAAAG,WACpB,QAAA4B,EAAA,EAAA2B,EAAAwJ,EAAA7L,OAA4CU,EAAA2B,EAAS3B,IACrD,QAAA4B,EAAA,EAA2BA,EAAA,EAAOA,IAClCzD,EAAAyD,GAAAtD,KAAAH,MAAAyD,GAAAuJ,EAAAnL,GAAA4B,IACA5D,EAAA4D,GAAAtD,KAAAN,MAAA4D,GAAAuJ,EAAAnL,GAAA4B,IAGA,WAAmBN,EAAKnD,EAAAH,GAExBkB,eAAA4J,GACA,OAAeI,EAAS+B,QAAAnC,GAExB5J,iBAAA4J,EAAA0B,GACA,IAAAS,EAAsB/B,EAAS+B,QAAAnC,GAC/BuC,EAAA1O,MAAA6N,EAAA,IAAkDhI,EAAEgI,GAAWtB,EAASsB,OAAA1B,GACxE,OAAAmC,EAAAnI,IAAAb,GAAA,IAAsCX,EAAKW,EAAAoJ,GAAArC,eAE3C9J,cAAA4J,EAAAwC,EAAA,GAAAC,GAAA,GACA,IAAApN,EAAA2K,EAAA,GAAAoB,KAAApB,EAAA,IACA9K,EAAA8K,EAAA,GAAAqB,KAAArB,EAAA,IACA0C,EAAA,EAA6BC,EAAGC,KAAAvN,EAAA,GAAAH,EAAA,GAAAsN,GAA+BG,EAAGC,KAAAvN,EAAA,GAAAH,EAAA,GAAAsN,GAClE,SACA,KAAmBhK,EAAKnD,EAAA,IAAUqE,EAAExE,EAAA,GAAAwN,IAAA,IAAoBlK,EAAK,IAAKkB,EAAErE,EAAA,GAAAqN,GAAAxN,IACpE,KAAmBsD,EAAKnD,EAAA,IAAUqE,EAAEgJ,EAAAxN,EAAA,SAAoBsD,EAAK,IAAKkB,EAAEgJ,EAAArN,EAAA,IAAAH,IAEpEkB,mBAAA4J,EAAAvE,GACA,OAAemD,EAAIC,YAAApD,EAAAuE,EAAA,GAAAA,EAAA,IAEnB5J,0BAAAyM,EAAAC,EAAAC,GAAA,GAKA,OAJAA,IACAF,EAAoBjE,EAAIsB,YAAA2C,GACxBC,EAAoBlE,EAAIsB,YAAA4C,MAExBD,EAAA,MAAAC,EAAA,OAAAA,EAAA,MAAAD,EAAA,UAEAA,EAAA,MAAAC,EAAA,OAAAA,EAAA,MAAAD,EAAA,OAIAzM,uBAAAyM,EAAAC,GACA,OAAa1C,EAASC,mBAAAwC,EAAAC,GAEPrG,EAAI6D,iBAAkBF,EAASG,MAAAsC,GAAezC,EAASG,MAAAuC,IADtE,IAAuBtK,GAIhB,MAAMqJ,EACbzL,gBAAA0B,EAAAiK,GAAA,GACA,IAAAiB,EAAA,EACA3N,EAAA2N,EAAsB5C,EAASrI,KAAAD,GAAAmK,WAAA5H,MAAA,EAC/B,GAAA0H,EAAA,CACA,IAAA7M,EAAsBkL,EAASrI,KAAAD,GAAAkK,WAAA3H,MAAA,EAC/B2I,EAAAxN,KAAAmE,KAAAtE,IAAAH,UAGA8N,EAAA3N,EAEA,WAAmBmD,EAAM4H,EAASsB,OAAA5J,GAAA,IAAkB4B,EAAEsJ,MAEtD5M,kBAAAqF,EAAAwH,GACA,WAAmBzK,EAAK,IAAKkB,EAAE+B,GAAA,IAAU/B,EAAEuJ,MAE3C7M,mBAAA0B,EAAA2D,EAAAiC,EAAA,GACA,IAAAjE,EAAA3B,EAAA,GAAA8F,UAAAnC,GACA,OAAAhC,EAAAG,IAAAH,GAAAiE,EAAA5F,EAAA,GAAA4D,EAAA5D,EAAA,GAAA4D,EAEAtF,sBAAA0B,EAAAgH,GACA,IAAArF,EAAAqF,EAAA,GAAAlB,UAAAkB,EAAA,IACAoE,EAAApL,EAAA,GAAA8F,UAAAkB,EAAA,IACA9H,EAAAyC,EAAAG,IAAAH,GAGAxC,EAFAiM,EAAAtJ,IAAAH,GAEAzC,EAEAmM,EAAAlM,KAHAiM,EAAAtJ,IAAAsJ,GAAApL,EAAA,GAAA4D,EAAA5D,EAAA,GAAA4D,GAEA1E,EAEA,GAAAmM,EAAA,EACA,WAAuB3K,EAEvB,CACA,IAAA4K,EAAA5N,KAAAmE,KAAAwJ,GACAE,GAAApM,EAAAmM,EACA9G,EAAAwC,EAAA,GAAAlB,UAAAnE,EAAAqB,UAAAuI,IACA,OAAAF,EACA,WAA2B3K,EAAK8D,GAChC,IAAAgH,GAAArM,EAAAmM,EACA7G,EAAAuC,EAAA,GAAAlB,UAAAnE,EAAAqB,UAAAwI,IACA,WAAuB9K,EAAK8D,EAAAC,IAG5BnG,uBAAA0B,EAAA0F,GACA,IAAAnC,EAAiBwG,EAAMlD,eAAA7G,EAAA0F,GACvBpF,EAAA,IAAoBI,EACpB,GAAA6C,EAAA7E,OAAA,EACA,QAAAU,EAAA,EAAA2B,EAAAwC,EAAA7E,OAA4CU,EAAA2B,EAAS3B,IACjCkJ,EAASvB,YAAArB,EAAAnC,EAAAnE,KAC7BkB,EAAAjB,KAAAkE,EAAAnE,IAGA,OAAAkB,EAEAhC,yBAAA0B,EAAAyL,GACA,IAAAC,EAAAD,EAAA,GAAA3F,UAAA9F,EAAA,IACA2L,EAAAD,EAAAzF,cACA2F,EAAAlO,KAAAmE,KAAA8J,GACAE,EAAA7L,EAAA,GAAA4D,EACAkI,EAAAL,EAAA,GAAA7H,EACAmI,EAAAF,IACAG,EAAAF,IACA,GAAAF,EAAAC,EAAAC,EACA,WAAuBpL,EAEvB,GAAAkL,EAAAlO,KAAAyE,IAAA0J,EAAAC,GACA,WAAuBpL,EAAKV,EAAA,GAAAiM,SAE5B,CACA,IAAA/M,GAAA6M,EAAAC,EAAAL,IAAA,EAAAC,GACAM,EAAAxO,KAAAmE,KAAAkK,EAAA7M,KACAC,EAAAuM,EAAA1I,UAAA9D,EAAA0M,GAAAvC,IAAArJ,EAAA,IACA,WAAuBU,EAAK,IAAKkB,EAAEzC,EAAAyE,EAAAsI,EAAAR,EAAA7H,EAAA+H,EAAAzM,EAAA0E,EAAAqI,EAAAR,EAAA9H,EAAAgI,GAAA,IAAgDhK,EAAEzC,EAAAyE,EAAAsI,EAAAR,EAAA7H,EAAA+H,EAAAzM,EAAA0E,EAAAqI,EAAAR,EAAA9H,EAAAgI,KAGrFtN,uBAAA0B,EAAAkI,GACA,IAAAO,EAAoBH,EAASG,MAAAP,GAC7B5H,EAAA,GACA,QAAAlB,EAAA,EAAA2B,EAAA0H,EAAA/J,OAA2CU,EAAA2B,EAAS3B,IAAA,CACpD,IAAAmE,EAAqBwG,EAAM1C,gBAAArH,EAAAyI,EAAArJ,IAC3BmE,EAAA7E,OAAA,GACA4B,EAAAjB,KAAAkE,GAEA,OAAelF,EAAImM,QAAAlK,GAEnBhC,cAAA0B,EAAA8J,GAAA,GACA,IAAAoB,EAAAlL,EAAA,MACA,GAAA8J,EAAA,CACA,IAAAD,EAAAnM,KAAAmE,KAAAqJ,KAAA,EACA,WAAuBxK,EAAKV,EAAA,GAAA8F,UAAA+D,GAAA7J,EAAA,GAAA2C,KAAAkH,IAG5B,WAAuBnJ,EAAKV,EAAA,GAAA8F,UAAAoF,GAAAlL,EAAA,GAAA2C,KAAAuI,IAG5B5M,kBAAA0B,EAAA8J,GAAA,GACA,GAAAA,EAAA,CACA,IAAAqC,GAAAzO,KAAAC,GAAA,EACAyO,EAAA,EAAA1O,KAAAC,GAAA,EACA2C,EAAA,IAAwBI,EACxB,QAAAtB,EAAA,EAA2BA,EAAA,EAAOA,IAClCkB,EAAAjB,KAAAW,EAAA,GAAAiM,QAAAzG,QAAA2G,EAAAnM,EAAA,WACAmM,GAAAC,EAEA,OAAA9L,EAGA,OAAmB+L,EAAQrD,WAAAhJ,EAAA,GAAAA,EAAA,QAIpB,MAAMqM,EACb/N,gBAAA4J,GACA,IAAAjL,EAAAiL,EAAA,GAAAvF,KAAAuF,EAAA,IAAAjG,OAAA,GACAhF,EAAA4G,EAAAqE,EAAA,MACA,IAAAnL,EAAAmL,EAAA,GAAA+D,QAEA,OADAlP,EAAA6G,EAAAsE,EAAA,MACA,IAAmBxH,EAAKzD,EAAAiL,EAAA,GAAA+D,QAAAlP,GAExBuB,kBAAAmN,GACA,OAAe1B,EAAMuC,WAAAb,GAAA,GAErBnN,kBAAAqF,EAAA1D,GACA,OAAeoM,EAAQE,WAAYxC,EAAMf,WAAArF,EAAA1D,IAEzC3B,cAAA0B,GACA,OAAAA,EAAAtB,OAAA,EACAwG,EAAA,IAAoCxE,EAAK,GAC1B8L,EAAOC,UAAAzM,GAAA,GAEtB1B,oBAAA0B,EAAAsC,GACA,OAAAtC,EAAAtB,OAAA,EACAwG,EAAA,IAAoCxE,EAAK,GACzC,IAAA4B,EACmB5B,EAAK2H,YAAA,CAAArI,EAAA,GAAAA,EAAA,KAExB,IAAAsC,EACmB5B,EAAK2H,YAAA,CAAArI,EAAA,GAAAA,EAAA,KAGLU,EAAK2H,YAAA,CAAArI,EAAA,GAAAA,EAAA,KAGxB1B,gBAAA0B,EAAAsC,GACA,IAAAoK,EAAkBL,EAAQM,aAAA3M,EAAAsC,GAC1B,OAAAoK,EAAAhO,OAAA,EACA,IAAuBgC,EAAKV,EAAAsC,GAAaqC,EAAI0B,oBAAAqG,EAAA1M,EAAAsC,KAG7C,IAAuB5B,EAGvBpC,mBAAA0B,GACA,GAAAA,EAAAtB,OAAA,EACA,OAAAwG,OAAAnJ,EAAA,GACA,IAAAmD,EAAgBmN,EAAQO,SAAA5M,EAAA,GACxBY,EAAgByL,EAAQO,SAAA5M,EAAA,GACxB,OAAe2E,EAAIkC,eAAA3H,EAAA0B,GAEnBtC,gBAAA0B,GACA,GAAAA,EAAAtB,OAAA,EACA,OAAAwG,OAAAnJ,EAAA,GACA,IAAAmD,EAAgBsN,EAAOK,SAAA7M,EAAA,GAAAqJ,IAAArJ,EAAA,IACvBY,EAAgB4L,EAAOK,SAAA7M,EAAA,GAAAqJ,IAAArJ,EAAA,IACvB,OAAe2E,EAAIkC,eAAA,IAAoBnG,EAAKV,EAAA,GAAAd,GAAA,IAAiBwB,EAAKV,EAAA,GAAAY,IAElEtC,gBAAA0B,EAAA4J,GACA,IAAAvI,EAAA,GAAoCgL,EAAQS,SAAA9M,GAG5CkL,EAAA,EAFmBsB,EAAOO,KAAA/M,GACNwM,EAAOQ,UAAAhN,GAAA,GAC3BiN,MACA,OAAelD,EAAMf,WAAA3H,EAAA6J,GAErB5M,oBAAA0B,GACA,IAAAkN,EAAiBb,EAAQc,OAAAnN,GACzBd,EAAA,CAAAgO,EAAA,GAAwBpG,EAAIsC,cAAApJ,EAAA,GAAA8F,UAAAoH,EAAA,KAAA1I,GAAA7B,KAAAuK,EAAA,KAC5BtM,EAAA,CAAAsM,EAAA,GAAwBpG,EAAIsC,cAAApJ,EAAA,GAAA8F,UAAAoH,EAAA,KAAA1I,GAAA7B,KAAAuK,EAAA,KAC5B,OAAevI,EAAIkC,eAAA3H,EAAA0B,GAEnBtC,oBAAA0B,EAAA4J,GACA,IAAAvI,EAAA,GAAoCgL,EAAQe,aAAApN,GAC5CkL,EAAAlL,EAAA,GAAA8F,UAAAzE,GAAAU,YACA,OAAegI,EAAMf,WAAA3H,EAAA6J,IAGd,MAAMsB,EACblO,gBAAA0B,GACA,OAAe8G,EAAIuG,SAAArN,GAEnB1B,iBAAAsL,EAAAH,EAAAC,GACA,OAAepB,EAAS+B,QAAS/B,EAASU,WAAAY,EAAAH,EAAAC,IAE1CpL,kBAAAsL,EAAAuB,EAAA1C,GACA,IAAAnI,EAAA,IAAoBI,EACpB,QAAAtB,EAAA,EAAuBA,EAAAqJ,EAAWrJ,IAAA,CAClC,IAAA+M,EAAA,EAAAzO,KAAAC,GAAAyB,EAAAqJ,EACAnI,EAAAjB,KAAA,IAAuBuC,EAAElE,KAAAsH,IAAAmH,GAAAhB,EAAAzN,KAAAuH,IAAAkH,GAAAhB,GAAA9B,IAAAO,IAEzB,OAAAtJ,EAEAhC,cAAA0B,EAAAsN,GACA,GAAAA,EAAA,GAAAA,GAAAtN,EAAAtB,OACA,UAAAe,MAAA,oCACA,WAAmBiB,EAAKV,EAAAsN,OAAAtN,EAAAtB,OAAA,EAAAsB,EAAA,GAAAA,EAAAsN,EAAA,IAExBhP,aAAA0B,EAAAuN,GAAA,GACA,GAAAvN,EAAAtB,OAAA,EACA,OAAAwG,EAAA,IAAoCxE,EAAK,GACzC,IAAA8M,EAAiBnP,EAAIoP,MAAAzN,EAAA,KAGrB,OAFAuN,GACAC,EAAAnO,KAAA,IAAwBqB,EAAKV,IAAAtB,OAAA,GAAAsB,EAAA,KAC7BwN,EAAAtL,IAAA5B,MAEAhC,iBAAA0B,EAAAuN,GAAA,EAAAzF,EAAA,IACA,GAAA9H,EAAAtB,OAAA,EACA,OAAAwG,EAAA,IAAoCxE,EAAK,GAGzC,OAFoB8L,EAAOkB,MAAA1N,EAAAuN,GAC3BrL,IAAAM,GAAoCsE,EAAI6B,YAAAnG,EAAA,GAAAA,EAAA,GAAAsF,IAGxCxJ,qBAAA0B,EAAAsC,EAAAiL,GAAA,GACA,GAAAvN,EAAAtB,OAAA,EACA,OAAAwG,EAAA,IAAoCxE,EAAK,GACzC,GAAA4B,EAAA,GAAAA,GAAAtC,EAAAtB,OACA,OAAA2G,EAAA,IAAwC3E,EAAK4B,GAC7C,IAAAqL,EAAA,GACA5Q,EAAAuF,EAAA,EACAiL,GAAAxQ,EAAA,IACAA,EAAAiD,EAAAtB,OAAA,GACA3B,GAAA,GACA4Q,EAAAtO,KAAA,IAAwBqB,EAAKV,EAAAsC,GAAAtC,EAAAjD,KAC7B,IAAAJ,EAAA2F,EAAA,EAKA,OAJAiL,GAAA5Q,EAAAqD,EAAAtB,OAAA,IACA/B,EAAA,GACAA,GAAAqD,EAAAtB,OAAA,GACAiP,EAAAtO,KAAA,IAAwBqB,EAAKV,EAAAsC,GAAAtC,EAAArD,KAC7BgR,EAEArP,gBAAA0B,EAAAsC,GACA,IAAAmG,EAAoB+D,EAAOoB,cAAA5N,EAAAsC,GAAA,GAC3B,GAAAmG,EAAA/J,QAAA,GACA,IAAAQ,EAAAuJ,EAAA,MAAA3C,UAAA2C,EAAA,OAAAK,OACAlI,EAAA6H,EAAA,MAAA3C,UAAA2C,EAAA,OAAAK,OACA,OAAA5J,EAAAmK,IAAAzI,GAAAqB,OAAA,IAMA3D,iBAAA0B,EAAAuN,GAAA,GACA,GAAAvN,EAAAtB,OAAA,EACA,OAAAwG,EAAA,IAAoCxE,EAAK,GACzC,IAAAgN,EAAoBlB,EAAOkB,MAAA1N,EAAAuN,GAC3BM,EAAA,EACA1O,EAAgByC,EAAEsB,KAAAwK,EAAAhP,OAAA,GAClB,QAAAU,EAAA,EAAA2B,EAAA2M,EAAAhP,OAA2CU,EAAA2B,EAAS3B,IAAA,CACpD,IAAA4C,EAAoB2C,EAAI5C,UAAA2L,EAAAtO,IACxByO,GAAA7L,EACA7C,EAAAC,GAAA4C,EAEA,OACAiL,MAAAY,EACAC,SAAA3O,GAGAb,YAAA0B,GACA,GAAAA,EAAAtB,OAAA,EACA,OAAAwG,EAAA,IAAoCxE,EAAK,GACzC,IAAAqN,EAAA,CAAA7O,EAAA0B,IAAA1B,EAAA,GAAA0B,EAAA,GAAA1B,EAAA,GAAA0B,EAAA,GACAmM,EAAA,EACA,QAAA3N,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAClDA,EAAAY,EAAAtB,OAAA,EACAqO,GAAAgB,EAAA/N,EAAAZ,GAAAY,EAAAZ,EAAA,IAGA2N,GAAAgB,EAAA/N,EAAAZ,GAAAY,EAAA,IAGA,OAAAtC,KAAAyE,IAAA4K,EAAA,GAEAzO,kBAAA0B,EAAAgO,GAAA,GACA,GAAAhO,EAAAtB,OAAA,EACA,OAAAwG,EAAA,IAAoCxE,EAAK,GACzCsN,IACAhO,IAAAf,SACAtD,KAAA,CAAAuD,EAAA0B,IAAA1B,EAAA,GAAA0B,EAAA,IAEA,IAAA7D,EAAA,CAAAmC,EAAA0B,EAAAS,KACAT,EAAA,GAAA1B,EAAA,KAAAmC,EAAA,GAAAnC,EAAA,KAAAmC,EAAA,GAAAnC,EAAA,KAAA0B,EAAA,GAAA1B,EAAA,MAEA+O,EAAA,GACAC,EAAAlO,EAAAtB,OAAA,EACAzB,EAAAiR,EAAA,EACAD,EAAAC,GAAAlO,EAAA,GACAiO,EAAAhR,GAAA+C,EAAA,GACAjD,EAAAiD,EAAA,GAAAA,EAAA,GAAAA,EAAA,KACAiO,EAAAC,EAAA,GAAAlO,EAAA,GACAiO,EAAAC,EAAA,GAAAlO,EAAA,KAGAiO,EAAAC,EAAA,GAAAlO,EAAA,GACAiO,EAAAC,EAAA,GAAAlO,EAAA,IAEA,QAAAZ,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAAA,CAClD,IAAAuE,EAAA3D,EAAAZ,GACA,IAAArC,EAAAkR,EAAAC,GAAAD,EAAAC,EAAA,GAAAvK,KAAA5G,EAAAkR,EAAAhR,EAAA,GAAAgR,EAAAhR,GAAA0G,GAAA,CAGA,MAAA5G,EAAAkR,EAAAC,GAAAD,EAAAC,EAAA,GAAAvK,IACAuK,GAAA,EAIA,IADAD,EADAC,GAAA,GACAvK,GACA5G,EAAAkR,EAAAhR,EAAA,GAAAgR,EAAAhR,GAAA0G,IACA1G,GAAA,EAGAgR,EADAhR,GAAA,GACA0G,GAEA,IAAAwK,EAAA,IAAuBzN,EACvB,QAAAwL,EAAA,EAAuBA,EAAAjP,EAAAiR,EAAiBhC,IACxCiC,EAAA9O,KAAA4O,EAAAC,EAAAhC,IAEA,OAAAiC,EAEA7P,eAAA0B,EAAAoO,EAAA,GACA,IAAA9N,EAAA,GACA,QAAAlB,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAClDA,GAAAgP,GACA9N,EAAAjB,KAAA,IAA2BqB,EAAKV,EAAAoO,GAAApO,EAAAZ,KAEhC,OAAAkB,EAEAhC,iBAAA0B,EAAA2D,GACA,IAAA0K,EAAAhR,OAAAC,UACAgR,GAAA,EACA,QAAAlP,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAAA,CAClD,IAAAuC,EAAA3B,EAAAZ,GAAA0G,UAAAnC,GAAAsC,cACAtE,EAAA0M,IACAA,EAAA1M,EACA2M,EAAAlP,GAGA,OAAAkP,EAEAhQ,mBAAA4I,EAAAqH,GACA,IAAAzM,EAAAyM,EAAAzM,IAAAoF,EAAA,IACAvF,EAAA,IAAoBC,EAAEE,KACtB,QAAA0M,EAAA,EAAAzN,EAAAmG,EAAAxI,OAA0C8P,EAAAzN,EAASyN,IACnD1M,EAAAyM,EAAAzM,IAAAoF,EAAAsH,IACA7M,EAAA,IAAoBC,EAAElE,KAAAH,IAAAuE,EAAAH,EAAA,IAAAjE,KAAAN,IAAA0E,EAAAH,EAAA,KAEtB,OAAAA,EAEArD,oBAAAmQ,EAAAC,EAAAH,GACA,IAAA/H,EAAiBgG,EAAOmC,YAAAF,EAAAF,GACxB9H,EAAiB+F,EAAOmC,YAAAD,EAAAH,GACxB,OAAA/H,EAAA,GAAAC,EAAA,GAAAA,EAAA,GAAAD,EAAA,GAAAA,EAAA,GAAAC,EAAA,GAEAnI,yBAAA4I,EAAAvD,GACA,IAAAtC,GAAA,EACA,QAAAjC,EAAA,EAAA2B,EAAAmG,EAAAxI,OAA0CU,EAAA2B,EAAS3B,IAAA,CACnD,IAAAwP,EAAqBpC,EAAOqC,OAAA3H,EAAA9H,GAC5BwP,EAAA,MAAAjL,EAAA,IAAAiL,EAAA,MAAAjL,EAAA,IACAA,EAAA,IAAAiL,EAAA,MAAAA,EAAA,QAAAjL,EAAA,GAAAiL,EAAA,QAAAA,EAAA,MAAAA,EAAA,OAAAA,EAAA,QACAvN,MAGA,OAAAA,EAEA/C,0BAAA4I,EAAAuE,GACA,IAAAqD,EAAA,CACAC,OAAA,EACAC,KAAA,EACAC,OAAA,KACAC,KAAA,KACAC,OAAA,MAEA9N,EAAAoK,EAAA,GACAP,EAAAO,EAAA,MACA2D,EAAA/R,OAAAgS,iBACA,QAAAjQ,EAAA,EAAA2B,EAAAmG,EAAAxI,OAA0CU,EAAA2B,EAAS3B,IAAA,CACnD,IAAA8P,EAAuB1C,EAAOqC,OAAA3H,EAAA9H,GAC9BkQ,EAAA,IAA2B1N,EAAEsN,EAAA,GAAArL,EAAAqL,EAAA,GAAArL,EAAAqL,EAAA,GAAAtL,EAAAsL,EAAA,GAAAtL,GAAAkF,OAC7B4F,EAAA,IAA4BhO,EAAKW,EAAAsB,KAAA2M,EAAAtM,UAAAkI,IAAA7J,EAAAyE,UAAAwJ,EAAAtM,UAAAkI,KACjC8D,EAAuBxC,EAAO+C,aAAArI,EAAAwH,EAAAY,GAC9B,GAAAN,EAAA,EACA,YAEA,GAAAtR,KAAAyE,IAAA6M,GAAAI,EAAA,EAC4B9G,EAASvB,YAAAmI,EAAmBvK,EAAI0B,oBAAA6I,EAAA7N,KAAkC0I,EAAM1C,gBAAAoE,EAAAyD,GAAAxQ,OAAA,KAEpGoQ,EAAAI,OACAJ,EAAAG,OAAAK,EACAF,EAAA1R,KAAAyE,IAAA6M,GACAF,EAAAC,MAAA3P,IAIA,OAAA0P,EAAAI,MAEA7N,EAAAyE,UAA8B0G,EAAOa,SAAAnG,IAAApF,IAAAgN,EAAAG,QACrC,GACAH,EAAAG,OAAAlG,UAAA,GACA+F,EAAAE,KAAAI,EACAN,EAAAK,OAAA9N,EACAyN,GANA,KAQAxQ,2BAAAmQ,EAAAC,GACA,IAAAI,EAAA,CACAC,OAAA,EACAC,KAAA,EACAC,OAAA,IAAwBrN,EACxBsN,KAAA,IAAsBxO,EACtByO,OAAA,IAAwBvN,GAExBwN,EAAA/R,OAAAgS,iBACA,QAAAjQ,EAAA,EAAAoQ,EAAAf,EAAA/P,OAAAgQ,EAAAhQ,OAA6DU,EAAAoQ,EAAUpQ,IAAA,CACvE,IAAA8P,EAAA9P,EAAAqP,EAAA/P,OAA4C8N,EAAOqC,OAAAJ,EAAArP,GAAoBoN,EAAOqC,OAAAH,EAAAtP,EAAAqP,EAAA/P,QAC9E4Q,EAAA,IAA2B1N,EAAEsN,EAAA,GAAArL,EAAAqL,EAAA,GAAArL,EAAAqL,EAAA,GAAAtL,EAAAsL,EAAA,GAAAtL,GAAAkF,OAC7BkG,EAAuBxC,EAAO+C,aAAAd,EAAAC,EAAAY,GAC9B,GAAAN,EAAA,EACA,YAEAtR,KAAAyE,IAAA6M,GAAAI,IACAN,EAAAI,OACAJ,EAAAG,OAAAK,EACAF,EAAA1R,KAAAyE,IAAA6M,GACAF,EAAAC,MAAA3P,EAAAqP,EAAA/P,OAAA,KAGAoQ,EAAAE,KAAAI,EACA,IAAAK,EAAA,IAAAX,EAAAC,MAAAL,EAAAD,EACAiB,EAAA,IAAAZ,EAAAC,MAAAN,EAAAC,EACAiB,EAAiBnD,EAAOa,SAAAoC,GACxBG,EAAiBpD,EAAOa,SAAAqC,GACxBC,EAAA7J,UAAA8J,GAAA9N,IAAAgN,EAAAG,QACA,GACAH,EAAAG,OAAAlG,UAAA,GACA,IAAA8G,EAAAxS,OAAAgS,iBACA,QAAAjQ,EAAA,EAAA2B,EAAA0O,EAAA/Q,OAAwCU,EAAA2B,EAAS3B,IAAA,CACjD,IAAAuC,EAAAmN,EAAAG,OAAAnN,IAAA2N,EAAArQ,GAAA0G,UAAA8J,IACAjO,EAAAkO,IACAA,EAAAlO,EACAmN,EAAAK,OAAAM,EAAArQ,IAGA,OAAA0P,EAEAxQ,0BAAAmQ,EAAAC,GACA,IAAAoB,EAAiBtD,EAAOkB,MAAAe,GACxBnO,EAAA,GACA,QAAAlB,EAAA,EAAA2B,EAAA+O,EAAApR,OAAwCU,EAAA2B,EAAS3B,IAAA,CACjD,IAAA2Q,EAAsBpL,EAAIqL,mBAAAF,EAAA1Q,GAAAsP,GAAA,GAC1BqB,GACAzP,EAAAjB,KAAA0Q,GAEA,OAAe1R,EAAImM,QAAAlK,GAAA,GAEnBhC,eAAA2R,GACA,IAAAC,EAAAD,EAAA/N,IAAA5B,GAAqCwG,EAAIsB,YAAA9H,IACzCiK,EAAqBlM,EAAImM,QAAA0F,GAAA,GAEzB,OADAA,EAAAC,QAAsBrJ,EAAIsB,YAAAmC,IAC1B2F,GC5tBO,MAAMrF,EACbvM,cAAAY,EAAA0B,EAAAgF,EAAA,MACA,OAAAlI,KAAAyE,IAAAjD,EAAA0B,GAAAgF,EAEAtH,YAAAY,EAAA0B,EAAAkH,GACA,SAAAA,GAAA5I,EAAA4I,EAAAlH,EAEAtC,aAAA8R,EAAA7S,EAAAH,GACA,OAAAM,KAAAN,IAAAG,EAAAG,KAAAH,IAAAH,EAAAgT,IAEA9R,kBAAA8R,EAAA7S,EAAAH,GACA,IAAA2D,EAAArD,KAAAyE,IAAA/E,EAAAG,GACA2B,EAAAkR,EAAArP,EAKA,OAJA7B,EAAA9B,EACA8B,GAAA6B,EACA7B,EAAA3B,IACA2B,GAAA6B,GACA7B,EAEAZ,cAAAa,EAAAD,EAAA0B,GACA,OAAAzB,GAAAzB,KAAAH,IAAA2B,EAAA0B,IAAAzB,GAAAzB,KAAAN,IAAA8B,EAAA0B,GAEAtC,mBAAAY,EAAA0B,EAAA,GACA,IAAAsK,EAAAhM,EAAA0B,EAAA1B,EAAA0B,IAAA1B,EACA,OAAAA,EAAAxB,KAAAqC,SAAAmL,EAEA5M,sBAAAkQ,EAAAtP,EAAA0B,GACA,IAAArD,EAAAG,KAAAH,IAAA2B,EAAA0B,GAEA,OAAA4N,EAAAjR,IADAG,KAAAN,IAAA8B,EAAA0B,GACArD,GAEAe,WAAA0B,GACA,IAAAqB,EAAA,IAAoBO,EAAE5B,EAAA,IACtB,QAAAZ,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IACtCqC,EAAG4H,IAAAhI,EAAArB,EAAAZ,IAEf,OAAAiC,EAEA/C,eAAA0B,GACA,OAAe6K,EAAGwF,IAAArQ,GAAAiC,OAAAjC,EAAAtB,QAElBJ,aAAAwJ,GACA,OAAApK,KAAAuH,IAAA,EAAAvH,KAAAC,GAAAmK,GAAA,KAEAxJ,kBAAAkQ,EAAA8B,EAAAC,EAAAC,EAAAC,GACA,GAAAH,GAAAC,EACA,UAAA9Q,MAAA,2DACA,IAAAlC,EAAAG,KAAAH,IAAAiT,EAAAC,GACArT,EAAAM,KAAAN,IAAAoT,EAAAC,GACA,OAAe5F,EAAG6F,eAAAlC,EAAA8B,EAAAC,IAAAnT,EAAAG,MAGX,MAAMuJ,EACbxI,kBAAAiH,GACA,OAAesF,EAAG8F,WAAApL,EAAA,OAElBjH,mBAAAsS,GACA,OAAe/F,EAAG8F,WAAAC,EAAA,EAAuBzU,EAAKyB,QAE9CU,gBAAAiH,GACA,OAAAA,EAAuBpJ,EAAK8B,WAE5BK,gBAAAsS,GACA,OAAAA,EAAwBzU,EAAK6B,WAE7BM,mBAAA0B,GACA,IAAA6Q,EAAA7Q,EAAAwD,OAAA,CAAAtE,EAAAC,IAAAD,EAAAoK,KAAAnK,IACA2R,EAAA9Q,EAAAwD,OAAA,CAAAtE,EAAAC,IAAAD,EAAAqK,KAAApK,IACA,WAAmBuB,EAAKmQ,EAAAC,GAExBxS,gBAAA0B,GACA,OAAe6K,EAAGkG,QAAA/Q,GAElB1B,cAAA0B,EAAAgR,EAAA,EAAAC,EAAA,MACA,IAAAC,EAAA,MAAAD,EAAA,iBACA,QAAA7R,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAClD,iBAAA4R,EACAA,IAAA5R,GACAY,EAAAZ,GAAA8R,GAAAlR,EAAAgR,IAGAhR,EAAAZ,GAAA8R,GAAAF,GAIA1S,mBAAAY,EAAA0B,EAAAkH,EAAA,IACA,IAAA/G,EAAArD,KAAAH,IAAA2B,EAAAR,OAAAkC,EAAAlC,QACAiD,EAAgBC,EAAEsB,KAAAnC,GAClB,QAAA3B,EAAA,EAAuBA,EAAA2B,EAAS3B,IAChCuC,EAAAvC,GAAAF,EAAAE,IAAA,EAAA0I,GAAAlH,EAAAxB,GAAA0I,EAEA,OAAAnG,EAEArD,qBAAAqF,EAAA2L,EAAoCnT,EAAKC,IACzC,IAAAyH,EAAAyL,EAAA,GACA1L,EAAA0L,EAAA,GACAnQ,EAAA,IAAoByC,EAAE+B,GACtB6C,EAAA,IAAqB5E,EAAEzC,GACvBqH,EAAA5C,IAAAzE,EAAA0E,GACA2C,EAAA3C,GAAA1E,EAAAyE,GACA,IAAA6C,EAAA,IAAqB7E,EAAEzC,GAGvB,OAFAsH,EAAA7C,GAAAzE,EAAA0E,GACA4C,EAAA5C,IAAA1E,EAAAyE,GACA,IAAmBlD,EAAK8F,EAAAC,GAExBnI,uBAAAkG,EAAAC,GACA,OAAqB,IAArB,IAAmB7C,EAAE4C,GAAA1C,IAAA2C,GAErBnG,mBAAAqF,EAAAwN,EAAAC,GACA,QAAAhS,EAAA,EAAA2B,EAAArD,KAAAH,IAAAoG,EAAAjF,OAAAyS,EAAAzS,OAAA0S,EAAA1S,QAAoFU,EAAA2B,EAAS3B,IAC7F,IAAiByL,EAAGf,OAAAnG,EAAAvE,GAAA+R,EAAA/R,GAAAgS,EAAAhS,IACpB,SAEA,SAEAd,iBAAA0B,GACA,IAAAqR,EAAqBvK,EAAIsB,YAAApI,GACzB4J,EAAAyH,EAAA,GAAAhI,IAAAgI,EAAA,IAAApP,OAAA,GAsBA,OAAAjC,EAAArE,KArBA,CAAAuD,EAAA0B,KACA,GAAA1B,EAAAR,OAAA,GAAAkC,EAAAlC,OAAA,EACA,UAAAe,MAAA,sCACA,IAAA6R,EAAApS,EAAA4G,UAAA8D,GACA2H,EAAA3Q,EAAAkF,UAAA8D,GACA,GAAA0H,EAAA,OAAAC,EAAA,KACA,SACA,GAAAD,EAAA,MAAAC,EAAA,MACA,SACA,MAAAD,EAAA,OAAAC,EAAA,GACA,OAAAD,EAAA,OAAAC,EAAA,MACAD,EAAA,GAAAC,EAAA,QACAA,EAAA,GAAAD,EAAA,QAEA,IAAAvD,EAAAuD,EAAAE,SAAAD,GACA,OAAAxD,EAAA,EACA,EACAA,EAAA,GACA,EACAuD,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAC,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,UAIAjT,aAAAiF,EAAAkO,EAAAnM,GACA,IAAAtF,EAAAnB,MAAAD,QAAA2E,KAAA,CAAAA,GACAmO,EAAA,iBAAAD,EAA+C7P,EAAEsB,KAAAlD,EAAA,GAAAtB,OAAA+S,KACjDnM,IACAA,EAAqB1D,EAAEsB,KAAAlD,EAAA,GAAAtB,OAAA,IACvB,QAAAU,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAAA,CAClD,IAAAD,EAAAa,EAAAZ,GACA,QAAA4B,EAAA,EAAA2Q,EAAAxS,EAAAT,OAA4CsC,EAAA2Q,EAAU3Q,IACtD7B,EAAA6B,GAAAsE,KAAAtE,GAAAsE,EAAAtE,IAAA7B,EAAA6B,GAAAsE,EAAAtE,IAAA0Q,EAAA1Q,GAAA7B,EAAA6B,GAAA0Q,EAAA1Q,GAGA,OAAe8F,EAEfxI,gBAAAiF,EAAAgC,EAAAD,EAAAgK,GACA,IAAAtP,EAAAnB,MAAAD,QAAA2E,KAAA,CAAAA,GACAjC,EAAA,EAA4BmB,EAAGmP,iBAAoBnP,EAAG6B,eACtDgB,IACAA,EAAqB1D,EAAEsB,KAAAlD,EAAA,GAAAtB,OAAA,IACvB,IAAAsG,EAAAtH,KAAAsH,IAAAO,GACAN,EAAAvH,KAAAuH,IAAAM,GACA,QAAAnG,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAAA,CAClD,IAAAD,EAAA,EAAAa,EAAAZ,GAAAyS,MAAAvC,GAAAtP,EAAAZ,GACAD,EAAA0G,GAAiBpD,EAAGqP,YAAA3S,EAAAmC,EAAA0D,EAAAC,EAAAK,KAEpB,OAAewB,EAEfxI,eAAAiF,EAAAkO,EAAAnM,EAAAgK,GACA,IAAAtP,EAAAnB,MAAAD,QAAA2E,KAAA,CAAAA,GACAf,EAAA,iBAAAiP,EAAA,CAAAA,OACAnM,IACAA,EAAqB1D,EAAEsB,KAAAlD,EAAA,GAAAtB,OAAA,IACvB,IAAA4C,EAAA,EAA4BmB,EAAGsP,gBAAmBtP,EAAG8B,cACrDyN,EAAAtU,KAAAuU,IAAAzP,EAAA,IACA0P,EAAAxU,KAAAuU,IAAAzP,EAAA,IACA,QAAApD,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAAA,CAClD,IAAAD,EAAA,EAAAa,EAAAZ,GAAAyS,MAAAvC,GAAAtP,EAAAZ,GACAD,EAAA0G,GAAiBpD,EAAGqP,YAAA3S,EAAAmC,EAAA0Q,EAAAE,EAAA5M,KAEpB,OAAewB,EAEfxI,iBAAAiF,EAAAmC,EAAA4J,GACA,IAAAtP,EAAAnB,MAAAD,QAAA2E,KAAA,CAAAA,GACA4O,EAAkB1P,EAAG2P,kBAAA1M,EAAA,GAAAA,EAAA,IACrB,QAAAtG,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAAA,CAClD,IAAAD,EAAA,EAAAa,EAAAZ,GAAAyS,MAAAvC,GAAAtP,EAAAZ,GACAD,EAAA0G,GAAiBpD,EAAGqP,YAAA3S,EAAAgT,IAEpB,OAAerL,EAEfxI,kBACA,IAAA0G,EAAA,IAAAqN,aAAA,KACA,QAAAjT,EAAA,EAAuBA,EAAA,IAASA,IAChC4F,EAAA5F,GAAA1B,KAAAsH,IAAA5F,EAAA1B,KAAAC,GAAA,KAEA,OAAgB2U,MAAAtN,MADhBuN,GAAAvN,EAAAtH,KAAAoC,MAA2CgH,EAAI0L,WAAY1L,EAAI2L,SAAAF,OAG/DjU,kBACA,IAAA2G,EAAA,IAAAoN,aAAA,KACA,QAAAjT,EAAA,EAAuBA,EAAA,IAASA,IAChC6F,EAAA7F,GAAA1B,KAAAuH,IAAA7F,EAAA1B,KAAAC,GAAA,KAEA,OAAgB2U,MAAArN,MADhBsN,GAAAtN,EAAAvH,KAAAoC,MAA2CgH,EAAI0L,WAAY1L,EAAI2L,SAAAF,QC1MxD,ICFAG,EDEAC,EAAAC,aACA,MAAMhR,UAAE+Q,EACfrU,eAAAG,GACA,IAAAA,EAAAC,QAAA,iBAAAD,EAAA,GACAoU,MAAApU,EAAA,IAGAoU,MAAApU,EAAAC,OAAA,EAAsCL,EAAIyU,QAAArU,GAAA,OAG1CH,YAAAyU,EAAA1P,EAAA,EAAA2P,GAAA,GACA,IAAA7T,EAAA,IAAAwT,EAAAI,GAGA,GAFA1P,GACAlE,EAAA8T,KAAA5P,GACA2P,EACA,QAAA5T,EAAA,EAAA2B,EAAA5B,EAAAT,OAA2CU,EAAA2B,EAAS3B,IACpDD,EAAAC,GAAAD,EAAAC,GAAA1B,KAAAqC,SAGA,WAAmB6B,EAAEzC,GAErB+T,SAAc,OAAAhX,KAAAiX,IACdD,OAAA1Q,GAAetG,KAAAiX,IAAA3Q,EACfoB,QAAa,OAAA1H,KAAA,GACb0H,MAAA4K,GAActS,KAAA,GAAAsS,EACd3K,QAAa,OAAA3H,KAAA,GACb2H,MAAA2K,GAActS,KAAA,GAAAsS,EACdrN,QAAa,OAAAjF,KAAA,GACbiF,MAAAqN,GAActS,KAAA,GAAAsS,EACd4E,QAAa,OAAAlX,KAAA,GACbkX,MAAA5E,GAActS,KAAA,GAAAsS,EACdlQ,QACA,WAAmBsD,EAAE1F,MAErBoC,OAAAa,EAAAyG,EAAA,MACA,QAAAxG,EAAA,EAAA2B,EAAA7E,KAAAwC,OAA0CU,EAAA2B,EAAS3B,IACnD,GAAA1B,KAAAyE,IAAAjG,KAAAkD,GAAAD,EAAAC,IAAAwG,EACA,SAEA,SAEAtH,MAAAG,GACA,IAAAU,EAAgBd,EAAIyU,QAAArU,GACpB,QAAAW,EAAA,EAAA2B,EAAArD,KAAAH,IAAArB,KAAAwC,OAAAS,EAAAT,QAA8DU,EAAA2B,EAAS3B,IACvElD,KAAAkD,GAAAD,EAAAC,GAEA,OAAAlD,KAEAoC,OAAAG,GACA,OAAAvC,KAAA+P,QAAApG,MAAApH,GAEAH,QAAAsS,EAAA7O,EAAAsR,GAAA,GACA,IAAArR,EAAAjG,MAAAgG,IAAA7F,KAAA6F,YACAuR,EAAA,CAAA5V,KAAAsH,IAAA4L,GAAA5O,EAAAtE,KAAAuH,IAAA2L,GAAA5O,GACA,SAAA9F,KAAAmN,IAAAiK,GAAApX,KAAA2J,GAAAyN,GAEAhV,GAAAgD,GACA,IAAAiS,EAAArX,KACA,UAAAsX,IACAlS,EAAAiS,KAAAC,GAGAlV,IAAAmV,GACA,IAAAC,EAAA,GACA,QAAAtU,EAAA,EAAA2B,EAAA0S,EAAA/U,OAAyCU,EAAA2B,EAAS3B,IAClDsU,EAAArU,KAAAnD,KAAA2E,GAAA4S,EAAArU,KAEA,OAAAsU,EAEApV,MAAAgR,GACA,IAAAnQ,EAAA,GACA,QAAAC,EAAA,EAAA2B,EAAAuO,EAAA5Q,OAA0CU,EAAA2B,EAAS3B,IACnDD,EAAAE,KAAAnD,KAAAoT,EAAAlQ,KAAA,GAEA,WAAmBwC,EAAEzC,GAErBb,WAAAG,GACA,WAAmBmD,EAAE1F,KAAAyX,UAAApT,OAAuBlC,EAAIyU,QAAArU,KAEhDH,OAAAG,GAEA,OADA,IAAAA,EAAAC,QAAA,iBAAAD,EAAA,GAA4DgD,EAAG4H,IAAAnN,KAAAuC,EAAA,IAAsBgD,EAAG4H,IAAAnN,KAAWmC,EAAIyU,QAAArU,IACvGvC,KAEAoC,QAAAG,GAAmB,OAAAvC,KAAA+P,QAAA5C,OAAA5K,GACnBH,YAAAG,GAEA,OADA,IAAAA,EAAAC,QAAA,iBAAAD,EAAA,GAA4DgD,EAAGsG,SAAA7L,KAAAuC,EAAA,IAA2BgD,EAAGsG,SAAA7L,KAAgBmC,EAAIyU,QAAArU,IACjHvC,KAEAoC,aAAAG,GAAwB,OAAAvC,KAAA+P,QAAAlE,YAAAtJ,GACxBH,YAAAG,GAEA,OADA,IAAAA,EAAAC,QAAA,iBAAAD,EAAA,GAA4DgD,EAAGsH,SAAA7M,KAAAuC,EAAA,IAA2BgD,EAAGsH,SAAA7M,KAAgBmC,EAAIyU,QAAArU,IACjHvC,KAEAoC,aAAAG,GAAwB,OAAAvC,KAAA+P,QAAAlD,YAAAtK,GACxBH,UAAAG,GAEA,OADA,IAAAA,EAAAC,QAAA,iBAAAD,EAAA,GAA4DgD,EAAGQ,OAAA/F,KAAAuC,EAAA,IAAyBgD,EAAGQ,OAAA/F,KAAcmC,EAAIyU,QAAArU,IAC7GvC,KAEAoC,WAAAG,GAAsB,OAAAvC,KAAA+P,QAAAhK,UAAAxD,GACtBH,cAAmB,OAAQmD,EAAGK,IAAA5F,WAC9BoC,YAAiB,OAAQmD,EAAGM,UAAA7F,MAC5BoC,KAAAyD,GAEA,OADQN,EAAGqH,KAAA5M,KAAA6F,GACX7F,KAEAoC,MAAAyD,GAAkC,OAAA7F,KAAA+P,QAAAnD,KAAA/G,GAClCzD,OAAAG,GAAkB,OAAQgD,EAAGK,IAAA5F,KAAWmC,EAAIyU,QAAArU,IAC5CH,YAAAG,GAAuB,OAAQgD,EAAGmS,QAAA1X,KAAemC,EAAIyU,QAAArU,IACrDH,UAAAG,GAAqB,OAAQgD,EAAGoS,MAAA3X,KAAamC,EAAIyU,QAAArU,IACjDH,YAAAG,GACA,OAAAvC,KAAA8G,UAAA9G,KAAA4F,OAAArD,GAAAvC,KAAA+J,eAEA3H,iBAAAG,GACA,OAAAvC,KAAA4F,OAAArD,GAAAvC,KAAA6F,YAEAzD,MAEA,OADQmD,EAAGU,IAAAjG,MACXA,KAEAoC,OACA,OAAApC,KAAA+P,QAAA9J,MAEA7D,QAEA,OADQmD,EAAG3B,MAAA5D,MACXA,KAEAoC,SACA,OAAApC,KAAA+P,QAAAnM,QAEAxB,OAEA,OADQmD,EAAGW,KAAAlG,MACXA,KAEAoC,QACA,OAAApC,KAAA+P,QAAA7J,OAEA9D,QAEA,OADQmD,EAAGY,MAAAnG,MACXA,KAEAoC,SACA,OAAApC,KAAA+P,QAAA5J,QAEA/D,WACA,OAAemD,EAAGlE,IAAArB,MAElBoC,WACA,OAAemD,EAAGrE,IAAAlB,MAElBoC,QAAAG,GACA,IAAAU,EAAgBd,EAAIyU,QAAArU,GACpBuD,EAAA9F,KAAA+P,QACA,QAAA7M,EAAA,EAAA2B,EAAArD,KAAAH,IAAArB,KAAAwC,OAAAS,EAAAT,QAA8DU,EAAA2B,EAAS3B,IACvE4C,EAAA5C,GAAA1B,KAAAH,IAAArB,KAAAkD,GAAAD,EAAAC,IAEA,OAAA4C,EAEA1D,QAAAG,GACA,IAAAU,EAAgBd,EAAIyU,QAAArU,GACpBuD,EAAA9F,KAAA+P,QACA,QAAA7M,EAAA,EAAA2B,EAAArD,KAAAH,IAAArB,KAAAwC,OAAAS,EAAAT,QAA8DU,EAAA2B,EAAS3B,IACvE4C,EAAA5C,GAAA1B,KAAAN,IAAAlB,KAAAkD,GAAAD,EAAAC,IAEA,OAAA4C,EAEA1D,MAAAgR,EAAiBnT,EAAKC,IACtB,OAAAsB,KAAAoW,MAAA5X,KAAAoT,EAAA,IAAApT,KAAAoT,EAAA,KAEAhR,aAAAa,EAAAmQ,EAA2BnT,EAAKC,IAChC,OAAe0K,EAAIiN,YAAA7X,KAAAqJ,MAAA+J,IAAiCxI,EAAIiN,YAAA5U,EAAAoG,MAAA+J,IAExDhR,MAAAmT,EAAAnM,GAEA,OADQwB,EAAI2K,MAAAvV,KAAAuV,EAAAnM,GAA8B1D,EAAEsB,KAAAhH,KAAAwC,OAAA,IAC5CxC,KAEAoC,SAAAiH,EAAAD,EAAAgK,GAEA,OADQxI,EAAIkN,SAAA9X,KAAAqJ,EAAAD,GAAiC1D,EAAEsB,KAAAhH,KAAAwC,OAAA,GAAA4Q,GAC/CpT,KAEAoC,QAAAmT,EAAAnM,EAAAgK,GAEA,OADQxI,EAAImN,QAAA/X,KAAAuV,EAAAnM,GAAgC1D,EAAEsB,KAAAhH,KAAAwC,OAAA,GAAA4Q,GAC9CpT,KAEAoC,UAAAoH,EAAA4J,GAEA,OADQxI,EAAIoN,UAAAhY,KAAAwJ,EAAA4J,GACZpT,KAEAoC,WACA,YAAqBpC,KAAAiY,KAAA,SAErB7V,UACA,SAAAW,MAAAhD,KAAAC,OAGO,MAAMwE,UAAK7B,MAClBP,eAAAG,GACAoU,SAAApU,GAEAyU,SAAc,OAAAhX,KAAAiX,IACdD,OAAA1Q,GAAetG,KAAAiX,IAAA3Q,EACfgC,SAAc,OAAAtI,KAAA,GACduI,SAAc,OAAAvI,KAAA,GACdyJ,SAAc,OAAAzJ,KAAA,GACdkY,SAAc,OAAAlY,KAAA,GACdmY,SAAc,OAAAnY,UAAAwC,OAAA,GACd4V,SAAc,OAAApY,UAAAwC,OAAA,GACd6V,SAAc,OAAArY,UAAAwC,OAAA,GACd8V,SAAc,OAAAtY,UAAAwC,OAAA,GACdJ,QACA,IAAAoJ,EAAA,IAAwBhH,EACxB,QAAAtB,EAAA,EAAA2B,EAAA7E,KAAAwC,OAA0CU,EAAA2B,EAAS3B,IACnDsI,EAAArI,KAAAnD,KAAAkD,GAAA6M,SAEA,OAAAvE,EAEApJ,iBAAAmW,GACA,IAAAnU,EAAA,IAAoBI,EACpB,QAAAtB,EAAA,EAAA2B,EAAA0T,EAAA/V,OAA0CU,EAAA2B,EAAS3B,IAAA,CACnD,IAAAD,EAAAsV,EAAArV,aAAwCwC,EAAE6S,EAAArV,GAAA,IAAkBwC,EAAE6S,EAAArV,IAC9DkB,EAAAjB,KAAAF,GAEA,OAAAmB,EAEAhC,mBAAAmW,GACA,OAAe/T,EAAKgU,KAAAD,GAEpBnW,MAAAqW,EAAAzU,EAAAC,GAAA,GAEA,OADiB9B,EAAIoP,MAAAvR,KAAAyY,EAAAzU,EAAAC,GAGrB7B,OAAA0B,EAAAsC,EAAA,GAEA,OADQ5B,EAAK1B,UAAA4V,OAAAjU,MAAAzE,KAAA,CAAAoG,EAAA,KAAAtC,IACb9D,KAEAoC,OAAAgE,EAAA,EAAAuS,EAAA,GACA,IAAAzP,EAAA9C,EAAA,MAAAA,EAAA,EAAAuS,GAAA,CAAAvS,EAAAuS,GACA,OAAenU,EAAK1B,UAAA4V,OAAAjU,MAAAzE,KAAAkJ,GAEpB9G,SAAAwW,EAAA,EAAA5U,EAAA,EAAAC,GAAA,GACA,OAAAjE,KAAAuR,MAAAqH,EAAA5U,EAAAC,GAEA7B,QAAa,OAAApC,KAAA4R,SAAA,KACbxP,WACA,OAAewI,EAAIuG,SAAAnR,MAEnBoC,cACA,OAAewI,EAAIsB,YAAAlM,MAEnBoC,SAAA0S,EAAA,GAA8BlK,EAAIxB,OAAApJ,KAAA8U,EAAA,MAClC1S,WAAA0S,EAAA,GAAgClK,EAAIxB,OAAApJ,KAAA8U,EAAA,QACpC1S,GAAAgD,GACA,IAAAiS,EAAArX,KACA,UAAAsX,IACAlS,EAAAiS,KAAAC,GAGAlV,IAAAmV,GACA,IAAAC,EAAA,GACA,QAAAtU,EAAA,EAAA2B,EAAA0S,EAAA/U,OAAyCU,EAAA2B,EAAS3B,IAClDsU,EAAArU,KAAAnD,KAAA2E,GAAA4S,EAAArU,KAEA,OAAAsU,EAEApV,YAAAwJ,GACAA,EAAY+C,EAAGkK,MAAAjN,EAAA,KACf,IAAAkN,EAAA9Y,KAAAwC,OAAA,EACAuW,EAAA,GAAA/Y,KAAAwC,OAAA,GACA4O,EAAA5P,KAAAoC,MAAAgI,EAAAmN,GACA,OAAenO,EAAI6B,YAAAzM,KAAAoR,GAAApR,KAAAwB,KAAAH,IAAArB,KAAAwC,OAAA,EAAA4O,EAAA,KAAAxF,EAAAwF,EAAA2H,GAAAD,GAEnB1W,UAAAG,GACA,OAAAvC,KAAAmN,OAAA5K,GAEAH,UAAAG,GACA,IAAAkD,EAAA,IAAoBC,EAAGvD,EAAIyU,QAAArU,IAAAsJ,SAAA7L,KAAA,IAE3B,OADAA,KAAAgZ,OAAAvT,GACAzF,KAEAoC,MAAAmT,EAAAnM,GACA,QAAAlG,EAAA,EAAA2B,EAAA7E,KAAAwC,OAA0CU,EAAA2B,EAAS3B,IACvC0H,EAAI2K,MAAAvV,KAAAkD,GAAAqS,EAAAnM,GAAApJ,KAAA,IAEhB,OAAAA,KAEAoC,SAAAiH,EAAAD,EAAAgK,GACA,QAAAlQ,EAAA,EAAA2B,EAAA7E,KAAAwC,OAA0CU,EAAA2B,EAAS3B,IACvC0H,EAAIkN,SAAA9X,KAAAkD,GAAAmG,EAAAD,GAAApJ,KAAA,GAAAoT,GAEhB,OAAApT,KAEAoC,QAAAmT,EAAAnM,EAAAgK,GACA,QAAAlQ,EAAA,EAAA2B,EAAA7E,KAAAwC,OAA0CU,EAAA2B,EAAS3B,IACvC0H,EAAImN,QAAA/X,KAAAkD,GAAAqS,EAAAnM,GAAApJ,KAAA,GAAAoT,GAEhB,OAAApT,KAEAoC,UAAAoH,EAAA4J,GACA,QAAAlQ,EAAA,EAAA2B,EAAA7E,KAAAwC,OAA0CU,EAAA2B,EAAS3B,IACvC0H,EAAIoN,UAAAhY,KAAAkD,GAAAsG,EAAA4J,GAEhB,OAAApT,KAEAoC,gBAAA6W,EAAAC,GAAA,GACA,OAAAlZ,KAAAP,KAAA,CAAAuD,EAAA0B,IAAA,EAAAA,EAAAuU,GAAAjW,EAAAiW,GAAAjW,EAAAiW,GAAAvU,EAAAuU,IAEA7W,UAAA+W,KAAA5W,GACA,IAAAvC,KAAA,GAAAmZ,GAEA,OADYhX,EAAIsB,QAAS0V,6BACzBnZ,KAEA,QAAAkD,EAAA,EAAA2B,EAAA7E,KAAAwC,OAA0CU,EAAA2B,EAAS3B,IACnDlD,KAAAkD,GAAAlD,KAAAkD,GAAAiW,MAAA5W,GAEA,OAAAvC,KAEAoC,OAAAG,GACA,OAAAvC,KAAAoZ,UAAA,SAAA7W,GAEAH,YAAAG,GACA,OAAAvC,KAAAoZ,UAAA,cAAA7W,GAEAH,YAAAG,GACA,OAAAvC,KAAAoZ,UAAA,cAAA7W,GAEAH,UAAAG,GACA,OAAAvC,KAAAoZ,UAAA,YAAA7W,GAEAH,WAAAgC,GACA,OAAemC,EAAG4G,IAAAnN,KAAAoE,GAElBhC,gBAAAgC,EAAAsC,GAAA,EAAAC,GAAA,GACA,OAAeJ,EAAGsG,SAAA7M,KAAAoE,EAAAsC,EAAAC,GAElBvE,SAAAgE,EAAAe,GAAA,GACA,OAAeZ,EAAGgB,SAAAvH,KAAAoG,EAAAe,GAElB/E,KAAA+E,EAAAC,GAAA,GACA,OAAeb,EAAGiB,IAAAxH,KAAAmH,EAAAC,GAElBhF,WACA,gBAAApC,KAAAsH,OAAA,CAAArE,EAAAkC,IAAAlC,EAAAkC,EAAAK,WAAA,cAGO,MAAA6T,UAAoB7U,EAC3BpC,eAAAG,GACAoU,SAAApU,GACAvC,KAAAuO,QAAA,IAA2B7I,EAC3B1F,KAAAsZ,MAAA,IAAyB5T,EACzB1F,KAAAuZ,SAAA,IAA4B7T,EAC5B1F,KAAAwZ,aAAA,IAAgC9T,EAChC1F,KAAAyZ,SAAA,EACAzZ,KAAA0Z,OAEAtX,wBAAA4J,GACA,IAAAtH,EAAA,IAAA2U,EAAA,IAA8B3T,EAAEsG,EAAAnL,MAAA,EAAAmL,EAAAjL,KAAA,OAAqC2E,EAAEsG,EAAAvL,OAAA,EAAAuL,EAAArL,QAAA,IAGvE,OAFAqL,EAAA2N,OAAA3N,EAAAwB,SACA9I,EAAAX,KAAA,IAAyB2B,EAAEsG,EAAA2N,MAAA3N,EAAAwB,SAC3B9I,EAEAtC,iBAAAgC,GACA,GAAAA,EAAA5B,OAAA,EACA,UAAAe,MAAA,8DACA,WAAA8V,EAAAjV,EAAA,GAAAA,IAAA5B,OAAA,IAEAJ,OAKA,GAJApC,KAAAsI,KACAtI,KAAAsZ,MAAAtZ,KAAAsI,GAAAyH,QACA/P,KAAAyZ,SAAA,GAEAzZ,KAAAsI,IAAAtI,KAAAuI,GAAA,CACA,IAAAvF,EAAAhD,KAAAsI,GACA5D,EAAA1E,KAAAuI,GACAvI,KAAAsN,QAAAtK,EAAAoK,KAAA1I,GACA1E,KAAAwZ,aAAAxW,EAAAqK,KAAA3I,GACA1E,KAAA4Z,cACA5Z,KAAAyZ,SAAA,GAGArX,QACA,WAAAiX,EAAArZ,KAAAuZ,SAAAxJ,QAAA/P,KAAAwZ,aAAAzJ,SAEA3N,cACApC,KAAAsZ,MAAAtZ,KAAAwZ,aAAA5P,UAAA5J,KAAAuZ,UAAAtT,MACAjG,KAAA6Z,gBAEAzX,gBACApC,KAAAuO,QAAAvO,KAAAsZ,MAAAxS,UAAA,IAAAqG,IAAAnN,KAAAuZ,UAEAnX,oBACApC,KAAAwZ,aAAAxZ,KAAAuZ,SAAA9S,KAAAzG,KAAAsZ,OACAtZ,KAAA6Z,gBAEAzX,uBACApC,KAAAuZ,SAAAvZ,KAAAwZ,aAAA5P,UAAA5J,KAAAsZ,OACAtZ,KAAA6Z,gBAEAzX,uBACA,IAAAuL,EAAA3N,KAAAsZ,MAAAxS,UAAA,IACA9G,KAAAuZ,SAAAvZ,KAAAuO,QAAA3E,UAAA+D,GACA3N,KAAAwZ,aAAAxZ,KAAAuO,QAAA9H,KAAAkH,GAEA5J,WAAgB,WAAY2B,EAAE1F,KAAAsZ,OAC9BvV,SAAAd,GACAjD,KAAAsZ,MAAA,IAAyB5T,EAAEzC,GAC3BjD,KAAA8Z,oBAEApM,aAAkB,WAAYhI,EAAE1F,KAAAuO,SAChCb,WAAAzK,GACAjD,KAAAuO,QAAA,IAA2B7I,EAAEzC,GAC7BjD,KAAA+Z,uBAEAzM,cAAmB,WAAY5H,EAAE1F,KAAAuZ,UACjCjM,YAAArK,GACAjD,KAAAuZ,SAAA,IAA4B7T,EAAEzC,GAC9BjD,KAAA,GAAAA,KAAAuZ,SACAvZ,KAAA4Z,cAEAI,kBAAuB,WAAYtU,EAAE1F,KAAAwZ,cACrCQ,gBAAA/W,GACAjD,KAAAwZ,aAAA,IAAgC9T,EAAEzC,GAClCjD,KAAA,GAAAA,KAAAwZ,aACAxZ,KAAA4Z,cAEAD,YAAiB,OAAA3Z,KAAAsZ,MAAA9W,OAAA,EAAAxC,KAAAsZ,MAAA5R,EAAA,EACjBiS,UAAAzC,GACAlX,KAAAsZ,MAAA5R,EAAAwP,EACAlX,KAAA8Z,oBAEAtM,aAAkB,OAAAxN,KAAAsZ,MAAA9W,OAAA,EAAAxC,KAAAsZ,MAAA3R,EAAA,EAClB6F,WAAAwC,GACAhQ,KAAAsZ,MAAA3R,EAAAqI,EACAhQ,KAAA8Z,oBAEAG,YAAiB,OAAAja,KAAAsZ,MAAA9W,OAAA,EAAAxC,KAAAsZ,MAAArU,EAAA,EACjBgV,UAAAxU,GACAzF,KAAAsZ,MAAArU,EAAAQ,EACAzF,KAAA8Z,oBAEApS,QAAa,OAAA1H,KAAAsN,QAAA5F,EACbC,QAAa,OAAA3H,KAAAsN,QAAA3F,EACb1C,QAAa,OAAAjF,KAAAsN,QAAArI,EACbiV,aAAkB,OAAAla,KAAAyZ,QAClBrX,SAIA,OAHApC,KAAAuZ,SAAAvZ,KAAA,GACAA,KAAAwZ,aAAAxZ,KAAA,GACAA,KAAA4Z,cACA5Z,OC/bA,SAAAwW,GACAA,IAAA,yBACAA,IAAA,mBACAA,IAAA,qBACAA,IAAA,uBACAA,IAAA,eALA,CAMCA,MAAA,KACM,MAAA2D,EAAA,CACPC,GAAA,KAAAC,KAAA,OAAAC,KAAA,OAAAC,KAAA,OAAAC,KAAA,OAAAC,KAAA,OAAAC,IAAA,OCRO,MAAMC,EACbvY,cACApC,KAAAgX,GAAA,QACAhX,KAAA4a,MAAA,IAAyBvB,EACzBrZ,KAAA6a,MAAA,CAAsBC,KAAA,EAAAC,KAAA,EAAAC,KAAA,GACtBhb,KAAAib,QAAA,GACAjb,KAAAkb,YAAA,EACAlb,KAAAmb,SAAA,EACAnb,KAAAob,QAAA,EACApb,KAAAqb,cAAAxb,EACAG,KAAAsb,SAAA,IAA4B5V,EAC5B1F,KAAAub,UAAA,EACAvb,KAAAwb,UAAA,EAEApZ,QAAAsC,GAEA,OADA1E,KAAAqb,SAAA3W,EACA1E,KAEAoC,IAAAa,GACA,IAAAwY,EAAA,mBAAAxY,EAAA,CAAiDyY,QAAAzY,GAAaA,EAC9D6B,EAAA9E,KAAAkb,cACAS,EAAA3b,KAAAgX,GAAAlS,EAOA,OANA9E,KAAAib,QAAAU,GAAAF,EACAA,EAAAG,UAAAD,EACAF,EAAAI,QAAA7b,KAAA4a,MAAAV,QACAuB,EAAAI,OAAA7b,KAAA4a,YACA/a,IAAAG,KAAAqb,WACArb,KAAAqb,UAAA,GACArb,KAEAoC,OAAAqZ,GAEA,cADAzb,KAAAib,QAAAQ,EAAAG,WACA5b,KAEAoC,YAEA,OADApC,KAAAib,QAAA,GACAjb,KAEAoC,KAAA0Z,EAAA,GAEA,GADA9b,KAAAmb,QAAAY,sBAAA/b,KAAAgc,KAAAC,KAAAjc,OACAA,KAAAob,OACA,OAAApb,KACAA,KAAA6a,MAAAE,KAAAe,EAAA9b,KAAA6a,MAAAC,KACA9a,KAAA6a,MAAAC,KAAAgB,EACA,IACA9b,KAAAkc,UAAAJ,GAEA,MAAAK,GAGA,MAFAC,qBAAApc,KAAAmb,SACAnb,KAAAwb,UAAA,EACAW,EAEA,OAAAnc,KAEAoC,SACApC,KAAA6a,MAAAG,KAAA,EACAhb,KAAAgc,OAEA5Z,UAAA0Z,GAIA,GAHA9b,KAAAwb,UAAA,EACAxb,KAAAqb,UACArb,KAAAqc,QACArc,KAAAub,SACA,QAAAzW,KAAA9E,KAAAib,QACAjb,KAAAib,QAAAnW,GAAA4W,SACA1b,KAAAib,QAAAnW,GAAA4W,QAAAI,EAAA9b,KAAA6a,MAAAE,KAAA/a,MAGAA,KAAA6a,MAAAG,KAAA,GAAAc,EAAA9b,KAAA6a,MAAAG,MACAoB,qBAAApc,KAAAmb,SACAnb,KAAAwb,UAAA,GAGApZ,MAAAka,GAAA,GAEA,OADAtc,KAAAob,QAAA,IAAApb,KAAAob,OACApb,KAEAoC,SAEA,OADApC,KAAAob,QAAA,EACApb,KAEAoC,KAAAwJ,EAAA,GAEA,OADA5L,KAAA6a,MAAAG,IAAApP,EACA5L,KAEAoC,SAAAma,EAAA,KAGA,OAFAvc,KAAAgc,OACAhc,KAAAwc,KAAAD,GACAvc,KAEAoC,OAAAqa,GAGA,OAFAzc,KAAA0c,aACA1c,KAAA0c,YAAAD,EAAAzc,MACAA,KAEA2c,oBAAAzN,GAA4BlP,KAAA0c,YAAAxN,EAC5ByN,sBAA2B,OAAA3c,KAAA0c,YAC3BE,gBAAqB,OAAA5c,KAAAwb,SACrBqB,iBAAsB,OAAA7c,KAAA4a,MAAA7K,QACtB+M,iBAAsB,WAAYzD,EAAM3T,EAAEsB,KAAAhH,KAAA+D,KAAAvB,OAAA,GAAAxC,KAAA+D,KAAAgM,SAC1ChM,WAAgB,OAAA/D,KAAA4a,MAAA7W,KAAAgM,QAChBrC,aAAkB,OAAA1N,KAAA+D,KAAAgC,OAAA,GAClB4T,YAAiB,OAAA3Z,KAAA4a,MAAAjB,MACjBnM,aAAkB,OAAAxN,KAAA4a,MAAApN,QAEX,MAAMuP,UAAwBpC,EACrCvY,cACAuU,SAAAqG,WACAhd,KAAAid,UAAA,EACAjd,KAAAkd,UAAA,EACAld,KAAAmd,WAAA,EACAnd,KAAAod,WAAA,EAEAC,cACA,IAAApa,EAAAjD,KAAAsb,SAAAvL,QAEA,OADA9M,EAAA+T,GAAAhX,KAAAsb,SAAAtE,GACA/T,EAEAb,WAAAkb,EAAApY,GACAlF,KAAAud,QAAAC,iBAAAF,EAAApY,GAEA9C,aAAAkb,EAAApY,GACAlF,KAAAud,QAAAE,oBAAAH,EAAApY,GAEA9C,UAAAsb,GAAA,GAiBA,OAhBAA,GACA1d,KAAA2d,WAAA,YAAA3d,KAAA4d,WAAA3B,KAAAjc,OACAA,KAAA2d,WAAA,UAAA3d,KAAA6d,SAAA5B,KAAAjc,OACAA,KAAA2d,WAAA,YAAA3d,KAAA8d,WAAA7B,KAAAjc,OACAA,KAAA2d,WAAA,WAAA3d,KAAA+d,UAAA9B,KAAAjc,OACAA,KAAA2d,WAAA,YAAA3d,KAAAge,WAAA/B,KAAAjc,OACAA,KAAAmd,WAAA,IAGAnd,KAAAie,aAAA,YAAAje,KAAA4d,WAAA3B,KAAAjc,OACAA,KAAAie,aAAA,UAAAje,KAAA6d,SAAA5B,KAAAjc,OACAA,KAAAie,aAAA,YAAAje,KAAA8d,WAAA7B,KAAAjc,OACAA,KAAAie,aAAA,WAAAje,KAAA+d,UAAA9B,KAAAjc,OACAA,KAAAie,aAAA,YAAAje,KAAAge,WAAA/B,KAAAjc,OACAA,KAAAmd,WAAA,GAEAnd,KAEAoC,UAAAsb,GAAA,GAeA,OAdAA,GACA1d,KAAA2d,WAAA,aAAA3d,KAAA4d,WAAA3B,KAAAjc,OACAA,KAAA2d,WAAA,WAAA3d,KAAA6d,SAAA5B,KAAAjc,OACAA,KAAA2d,WAAA,YAAA3d,KAAAke,WAAAjC,KAAAjc,OACAA,KAAA2d,WAAA,cAAA3d,KAAA+d,UAAA9B,KAAAjc,OACAA,KAAAod,WAAA,IAGApd,KAAAie,aAAA,aAAAje,KAAA4d,WAAA3B,KAAAjc,OACAA,KAAAie,aAAA,WAAAje,KAAA6d,SAAA5B,KAAAjc,OACAA,KAAAie,aAAA,YAAAje,KAAAke,WAAAjC,KAAAjc,OACAA,KAAAie,aAAA,cAAAje,KAAA+d,UAAA9B,KAAAjc,OACAA,KAAAod,WAAA,GAEApd,KAEAoC,gBAAAkb,EAAAzK,EAAA,WACA,IAAAyK,MAAAzK,GACA,SACA,IAAAsL,EAAA,GACA,QAAAjb,EAAA,EAAuBA,EAAAoa,EAAAzK,GAAArQ,OAAuBU,IAAA,CAC9C,IAAA0I,EAAA0R,EAAAzK,GAAAuL,KAAAlb,GACAib,EAAAhb,KAAA,IAAwBuC,EAAEkG,EAAAyS,MAAAre,KAAA4a,MAAAtN,QAAA5F,EAAAkE,EAAA0S,MAAAte,KAAA4a,MAAAtN,QAAA3F,IAE1B,OAAAwW,EAEA/b,aAAAmc,EAAAjB,GACA,IAAA7S,EAAA,EAAAC,EAAA,EACA,GAAA4S,aAAAkB,YACA,QAAA1Z,KAAA9E,KAAAib,QACA,GAAAjb,KAAAib,QAAAwD,eAAA3Z,GAAA,CACA,IAAA4Z,EAAA1e,KAAAib,QAAAnW,GACA2F,EAAA6S,EAAAe,MAAAre,KAAA6c,WAAAnV,EACAgD,EAAA4S,EAAAgB,MAAAte,KAAA6c,WAAAlV,EACA+W,EAAAC,QACAD,EAAAC,OAAAJ,EAAA9T,EAAAC,EAAA4S,SAKA,QAAAxY,KAAA9E,KAAAib,QACA,GAAAjb,KAAAib,QAAAwD,eAAA3Z,GAAA,CACA,IAAA4Z,EAAA1e,KAAAib,QAAAnW,GACAK,EAAAmY,EAAAsB,gBAAAtB,EAAAsB,eAAApc,OAAA,EACAqc,EAAAvB,EAAAsB,eAAAR,KAAA,GACA3T,EAAA,EAAAoU,EAAAR,MAAAre,KAAA6c,WAAAnV,EAAA,EACAgD,EAAA,EAAAmU,EAAAP,MAAAte,KAAA6c,WAAAlV,EAAA,EACA+W,EAAAC,QACAD,EAAAC,OAAAJ,EAAA9T,EAAAC,EAAA4S,GAIAiB,IACAve,KAAAsb,SAAA3R,GAAAc,EAAAC,GACA1K,KAAAsb,SAAAtE,GAAAuH,GAGAnc,WAAAkb,GAGA,OAFAtd,KAAA8e,aAA0B3E,EAAGE,KAAAiD,GAC7Btd,KAAAid,UAAA,GACA,EAEA7a,SAAAkb,GAMA,OALAtd,KAAA8e,aAA0B3E,EAAGC,GAAAkD,GAC7Btd,KAAAkd,UACAld,KAAA8e,aAA8B3E,EAAGE,KAAAiD,GACjCtd,KAAAid,UAAA,EACAjd,KAAAkd,UAAA,GACA,EAEA9a,WAAAkb,GAMA,OALAtd,KAAA8e,aAA0B3E,EAAGG,KAAAgD,GAC7Btd,KAAAid,WACAjd,KAAAkd,UAAA,EACAld,KAAA8e,aAA8B3E,EAAGI,KAAA+C,KAEjC,EAEAlb,WAAAkb,GAEA,OADAtd,KAAA8e,aAA0B3E,EAAGM,KAAA6C,IAC7B,EAEAlb,UAAAkb,GAKA,OAJAtd,KAAA8e,aAA0B3E,EAAGO,IAAA4C,GAC7Btd,KAAAkd,UACAld,KAAA8e,aAA8B3E,EAAGK,KAAA8C,GACjCtd,KAAAkd,UAAA,GACA,EAEA9a,WAAAkb,GAGA,OAFAtd,KAAAge,WAAAV,GACAA,EAAAyB,kBACA,GC7OO,MAAMC,EACb5c,cACApC,KAAAif,QAAA,EAEAC,YAAiB,OAAAlf,KAAAif,OACjB7c,kBAAA0B,EAAAqb,EAAA,GACA,QAAArb,EAAAtB,OAAA2c,KACYhd,EAAIsB,KAAA,0CAChB,IAKO,MAAA2b,UAAyBJ,EAChC5c,cACAuU,SAAAqG,WACAhd,KAAAqf,SAAA,EACArf,KAAAsf,UAAA,EACAtf,KAAAuf,MAAA,IAAAC,EAAA,iBAEAC,aAAkB,OAAAzf,KAAAqf,QAClBI,WAAA/a,GAAmB1E,KAAAqf,QAAA3a,EACnBgb,cAAmB,OAAA1f,KAAAsf,SACnBI,YAAAhb,GAAoB1E,KAAAsf,SAAA5a,EACpBib,kBAAuB,OAAA3f,KAAAuf,MACvBnd,UAAAwd,EAAAC,KAAAC,GACA,IAAAF,EACA,OAAA5f,KACA,QAAAkD,EAAA,EAAA2B,EAAA+a,EAAApd,OAA4CU,EAAA2B,EAAS3B,IACrDlD,KAAA6f,GAAAD,EAAA1c,MAAA4c,GAEA,OAAA9f,KAEAoC,KAAA+C,GACA,OAAAnF,KAEAoC,SAAA+C,GAEA,OADAnF,KAAA+f,QAAA,GACA/f,KAAA+W,KAAA5R,GAEA/C,OAAA+C,EAAAwU,EAAAqG,EAAAC,GACA,OAAAjgB,KAEAoC,WAAA+C,EAAAwU,EAAAqG,EAAAC,GAEA,OADAjgB,KAAA+W,MAAA,GACA/W,KAAA+f,OAAA5a,EAAAwU,EAAAqG,EAAAC,GAEA7d,OAAA0B,EAAAmL,EAAA4Q,GACA,GAAA/b,EAAA,CAEA,QAAAZ,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAClDlD,KAAAkgB,MAAApc,EAAAZ,GAAA+L,EAAA4Q,GAEA,OAAA7f,MAEAoC,QAAAwd,GACA,OAAA5f,KAAAmgB,UAAAP,EAAA,UAEAxd,QAAAwd,GACA,OAAA5f,KAAAmgB,UAAAP,EAAA,UAEAxd,MAAAwd,GACA,OAAA5f,KAAAmgB,UAAAP,EAAA,QAEAxd,SAAAwd,GACA,OAAA5f,KAAAmgB,UAAAP,EAAA,WAEAxd,MAAAwd,GACA,OAAA5f,KAAAmgB,UAAAP,EAAA,SAGO,MAAAJ,EACPpd,YAAA2B,EAAA,GAAAqc,EAAA,aAAAC,EAAA,GAAAC,EAAA,GAAAC,EAAA,KACAvgB,KAAA+D,OACA/D,KAAAogB,OACApgB,KAAAsgB,QACAtgB,KAAAqgB,SACArgB,KAAAugB,aAEAla,YAAiB,SAAWrG,KAAAsgB,SAActgB,KAAAqgB,UAAergB,KAAA+D,UAAe/D,KAAAugB,cAAmBvgB,KAAAogB,OAC3Fhe,WAAgB,OAAApC,KAAAqG,OChFT,MAAMma,EACbpe,0BAAAgD,EAAAqb,EAAA,cAAAC,EAAA,cACA,IAAA5a,EAAA2a,EAAAza,IAAAZ,GACAub,EAAA,IAAsBjb,EAAEgb,GAAA9a,IAAAE,GACxB,OAAA8a,KAAApe,OAAAme,EAEAve,gBAAAgD,EAAAwb,EAAAjH,EAAAkH,EAAA,IACA,IAAAC,EAAAtf,KAAAoC,MAAAgd,EAAApe,OAAAhB,KAAAH,IAAA,EAAAsY,EAAAvU,EAAAwb,KACA,OAAAE,EAAAF,EAAApe,QACAse,EAAAtf,KAAAN,IAAA,EAAA4f,EAAAD,EAAAre,QACA,CAAAoe,EAAAG,OAAA,EAAAD,GAAAD,EAAAC,IAGA,CAAAF,IAAApe,QAGAJ,qBAAA6J,EAAAuC,EAAA,EAAAwS,GAAA,GACA,IAAA9d,EAAA8d,EAAA,IACAhR,EAAA/D,EAAA,GAAA/I,GAAA+I,EAAA,GAAA/I,GACAgM,EAAAV,EAAAwB,EACA,gBAAAtL,GACA,IAAAuc,GAAAvc,EAAA,GAAAxB,GAAAwB,EAAA,GAAAxB,IAAA8M,EACA,OAAAd,EAAA+R,GAGA7e,2BAAAsH,EAAAqL,EAAA,GACA,gBAAAmM,EAAAhN,GACA,IAAAzO,EAAAyb,EAAAhN,EAAAxK,EACA,OAAAqL,EAAA,EACAvT,KAAAH,IAAAoE,EAAAyb,GACAnM,EAAA,EACAvT,KAAAN,IAAAuE,EAAAyb,GACAzb,IC3BO,MAAM0b,UAAoBpE,EACjC3a,YAAAgf,EAAAlc,GACAyR,QACA3W,KAAAqhB,YAAA,EACArhB,KAAAshB,aAAA,EACAthB,KAAAuhB,SAAA,UACAvhB,KAAAwhB,YAAA,EACAxhB,KAAAyhB,gBAAA,EACA,IAAAC,EAAA,KAGA,GADA1hB,KAAAgX,GAAA,KACAoK,aAAAO,QACAD,EAAAN,EACAphB,KAAAgX,GAAA,yBAEA,CACA,IAAAA,EAAAoK,EACApK,EAAA,MAAAoK,EAAA,UAAAA,EAAA,GAAAA,EAAA,IAAAA,EACAM,EAAAE,SAAAC,cAAA7K,IACA,EACAhX,KAAAgX,KAAA+J,OAAA,GAEAW,EAOA,UAAAA,EAAAI,SAAAC,eACA/hB,KAAAgiB,WAAAN,EACA1hB,KAAAud,QAAAvd,KAAAiiB,eAAA,SAAAjiB,KAAAgX,GAAA,WACAhX,KAAAgiB,WAAAE,YAAAliB,KAAAud,SACAvd,KAAAyhB,gBAAA,IAGAzhB,KAAAud,QAAAmE,EACA1hB,KAAAgiB,WAAAN,EAAAS,cACAniB,KAAAshB,aAAA,IAfAthB,KAAAgiB,WAAAhiB,KAAAiiB,eAAA,MAAAjiB,KAAAgX,GAAA,cACAhX,KAAAud,QAAAvd,KAAAiiB,eAAA,SAAAjiB,KAAAgX,IACAhX,KAAAgiB,WAAAE,YAAAliB,KAAAud,SACAqE,SAAAQ,KAAAF,YAAAliB,KAAAgiB,aAcAK,WAAAriB,KAAAif,OAAAhD,KAAAjc,KAAAkF,GAAA,KACAlF,KAAAsiB,KAAAtiB,KAAAud,QAAAgF,WAAA,MAEAngB,eAAAgf,EAAA,MAAApK,GACA,IAAAvR,EAAAmc,SAAAY,cAAApB,GAEA,OADA3b,EAAAgd,aAAA,KAAAzL,GACAvR,EAEArD,OAAA8C,GACA,IAAAlF,KAAAgiB,WACA,UAAAze,0BAAgDvD,KAAAgX,cAChDhX,KAAAub,UAAA,EACAvb,KAAA0iB,eAAA,MACA1iB,KAAAqc,MAAArc,KAAAuhB,UACAvhB,KAAAud,QAAAoF,cAAA,IAAAC,MAAA,UACA,QAAA9d,KAAA9E,KAAAib,QACAjb,KAAAib,QAAAwD,eAAA3Z,IACA9E,KAAAib,QAAAnW,GAAAnB,OACA3D,KAAAib,QAAAnW,GAAAnB,MAAA3D,KAAA4a,MAAA7K,QAAA/P,MAGAA,KAAAsb,SAAAtb,KAAA0N,OACA1N,KAAAyhB,gBAAA,EACAvc,GACAA,EAAAlF,KAAA4a,MAAA5a,KAAAud,SAEAnb,MAAAygB,GAIA,GAHAA,EAAAC,UACA9iB,KAAAuhB,SAAAsB,EAAAC,SACA9iB,KAAA+iB,WAAAljB,MAAAgjB,EAAAhH,QAAAgH,EAAAhH,QACA,IAAAgH,EAAAG,OAAA,CACA,IAAAC,EAAAC,OAAAC,kBAAA,EACAC,EAAApjB,KAAAsiB,KAAAe,8BAAArjB,KAAAsiB,KAAAgB,2BAAAtjB,KAAAsiB,KAAAiB,0BAAAvjB,KAAAsiB,KAAAkB,yBAAAxjB,KAAAsiB,KAAAmB,wBAAA,EACAzjB,KAAAqhB,YAAA7f,KAAAN,IAAA,EAAA+hB,EAAAG,GAUA,OARAP,EAAAa,WACA1jB,KAAAwhB,YAAA,EACAxhB,KAAA2jB,WAAA3jB,KAAAiiB,eAAA,SAAAjiB,KAAAgX,GAAA,cACAhX,KAAA4jB,QAAA5jB,KAAA2jB,WAAApB,WAAA,OAGAviB,KAAAwhB,YAAA,EAEAxhB,KAEA+iB,eAAAc,GACA7jB,KAAAshB,YAAAuC,EACAA,EACAX,OAAA1F,iBAAA,SAAAxd,KAAA0iB,eAAAzG,KAAAjc,OAGAkjB,OAAAzF,oBAAA,SAAAzd,KAAA0iB,eAAAzG,KAAAjc,OAGA+iB,iBAAsB,OAAA/iB,KAAAshB,YACtBlf,OAAAsC,EAAA4Y,GACAtd,KAAA4a,MAAAlW,EACA1E,KAAAud,QAAA5D,MAAA3Z,KAAA4a,MAAA7W,KAAA2D,EAAA1H,KAAAqhB,YACArhB,KAAAud,QAAA/P,OAAAxN,KAAA4a,MAAA7W,KAAA4D,EAAA3H,KAAAqhB,YACArhB,KAAAud,QAAA+C,MAAA3G,MAAAnY,KAAAoC,MAAA5D,KAAA4a,MAAA7W,KAAA2D,GAAA,KACA1H,KAAAud,QAAA+C,MAAA9S,OAAAhM,KAAAoC,MAAA5D,KAAA4a,MAAA7W,KAAA4D,GAAA,KACA3H,KAAAwhB,aACAxhB,KAAA2jB,WAAAhK,MAAA3Z,KAAA4a,MAAA7W,KAAA2D,EAAA1H,KAAAqhB,YACArhB,KAAA2jB,WAAAnW,OAAAxN,KAAA4a,MAAA7W,KAAA4D,EAAA3H,KAAAqhB,aAEA,GAAArhB,KAAAqhB,cACArhB,KAAAsiB,KAAA/M,MAAAvV,KAAAqhB,YAAArhB,KAAAqhB,aACArhB,KAAAsiB,KAAAwB,UAAA,OACA9jB,KAAAwhB,aACAxhB,KAAA4jB,QAAArO,MAAAvV,KAAAqhB,YAAArhB,KAAAqhB,aACArhB,KAAA4jB,QAAAE,UAAA,SAGA,QAAAhf,KAAA9E,KAAAib,QACA,GAAAjb,KAAAib,QAAAwD,eAAA3Z,GAAA,CACA,IAAA7B,EAAAjD,KAAAib,QAAAnW,GACA7B,EAAA4Y,QACA5Y,EAAA4Y,OAAA7b,KAAA4a,MAAA0C,GAMA,OAHAtd,KAAA+jB,OAAA/jB,KAAAsiB,MACAhF,IAAAtd,KAAA4c,WACA5c,KAAAgkB,SAAA,GACAhkB,KAEAoC,eAAAkb,GACA,IAAA5Y,EAAA1E,KAAAshB,aAAAthB,KAAAyhB,eAAAzhB,KAAAgiB,WAAAiC,wBAAAjkB,KAAAud,QAAA0G,wBACA,GAAAvf,EAAA,CACA,IAAAuH,EAAsBoN,EAAK6K,iBAAAxf,GAC3BuH,EAAAyB,OAAAzB,EAAAyB,OAAAP,IAAA+V,OAAAiB,YAAAjB,OAAAkB,aACApkB,KAAA6b,OAAA5P,EAAAqR,IAGA+G,eAAAC,GAAwBtkB,KAAAuhB,SAAA+C,EACxBD,iBAAsB,OAAArkB,KAAAuhB,SACtBgD,iBACA,OAAAvkB,KAAAqhB,YAEAmD,mBACA,OAAAxkB,KAAAwhB,WAEAiD,mBAAwB,OAAAzkB,KAAA4jB,QACxBc,sBAA2B,OAAA1kB,KAAA2jB,WAC3BvhB,UAAe,WAAYuiB,EAAU3kB,MACrC4kB,cACA,OAAA5kB,KAAAud,QAEAsH,aACA,OAAA7kB,KAAAgiB,WAEA9C,YACA,OAAAlf,KAAAub,SAEAuJ,UAAe,OAAA9kB,KAAAsiB,KACflgB,MAAAkiB,GACAA,IACAtkB,KAAAuhB,SAAA+C,GACA,IAAAS,EAAA/kB,KAAAsiB,KAAA0C,UASA,OARAhlB,KAAAuhB,UAAA,eAAAvhB,KAAAuhB,UACAvhB,KAAAsiB,KAAA0C,UAAAhlB,KAAAuhB,SACAvhB,KAAAsiB,KAAA2C,UAAA,KAAAjlB,KAAAud,QAAA5D,MAAA,EAAA3Z,KAAAud,QAAA/P,OAAA,IAGAxN,KAAAsiB,KAAA4C,WAAA,KAAAllB,KAAAud,QAAA5D,MAAA,EAAA3Z,KAAAud,QAAA/P,OAAA,GAEAxN,KAAAsiB,KAAA0C,UAAAD,EACA/kB,KAEAoC,eAAAkiB,GAUA,OATAtkB,KAAAwhB,aACA8C,GACAtkB,KAAA4jB,QAAAoB,UAAAV,EACAtkB,KAAA4jB,QAAAqB,UAAA,KAAAjlB,KAAAud,QAAA5D,MAAA,EAAA3Z,KAAAud,QAAA/P,OAAA,IAGAxN,KAAA4jB,QAAAsB,WAAA,KAAAllB,KAAA2jB,WAAAhK,MAAA,EAAA3Z,KAAA2jB,WAAAnW,OAAA,IAGAxN,KAEAoC,UAAA0Z,GACA9b,KAAAub,WACAvb,KAAAsiB,KAAA6C,OACAnlB,KAAAwhB,YACAxhB,KAAA4jB,QAAAuB,OACAxO,MAAAuF,UAAAJ,GACA9b,KAAAsiB,KAAA8C,UACAplB,KAAAwhB,YACAxhB,KAAA4jB,QAAAwB,UACAplB,KAAA+jB,OAAA/jB,KAAAsiB,QAIO,MAAMqC,UAAmBvF,EAChChd,YAAAijB,GACA1O,QACA3W,KAAAslB,OAAA,CACAN,UAAA,OAAAO,YAAA,OACAC,UAAA,EAAAC,SAAA,QAAAC,QAAA,QAEA1lB,KAAA2lB,OAAAN,EACArlB,KAAA2lB,OAAAxY,IAAA,CAAyBxJ,MAAA,KACzB3D,KAAAsiB,KAAAtiB,KAAA2lB,OAAAb,IACA9kB,KAAAsiB,KAAA0C,UAAAhlB,KAAAslB,OAAAN,UACAhlB,KAAAsiB,KAAAiD,YAAAvlB,KAAAslB,OAAAC,YACAvlB,KAAAsiB,KAAAmD,SAAA,QACAzlB,KAAAsiB,KAAAsD,KAAA5lB,KAAAuf,MAAAlZ,MACArG,KAAAif,QAAA,KAGAoG,YAAiB,OAAArlB,KAAA2lB,OACjBvjB,aAAAyjB,GAAA,EAAAxJ,GAAA,GAIA,OAHAA,GACArc,KAAA2lB,OAAAG,eAAA,iBAAAzJ,IAAA,MACArc,KAAAsiB,KAAAtiB,KAAA2lB,OAAAnB,cAAAqB,EAAA7lB,KAAA2lB,OAAAlB,aAAAzkB,KAAA2lB,OAAAb,IACA9kB,KAEAoC,gBAAA2jB,EAAA,OACA/lB,KAAA2lB,OAAAnB,cACAxkB,KAAA2lB,OAAAb,IAAAkB,UAAAhmB,KAAA2lB,OAAAjB,gBAAAqB,EAAA,GAAAA,EAAA,GAAA/lB,KAAA2lB,OAAAhM,MAAA3Z,KAAA2lB,OAAAnY,QAGApL,KAAA+C,GASA,MARA,kBAAAA,EACAnF,KAAAyf,OAAAta,GAGAnF,KAAAyf,QAAA,EACAzf,KAAAslB,OAAAN,UAAA7f,EACAnF,KAAAsiB,KAAA0C,UAAA7f,GAEAnF,KAEAoC,OAAA+C,EAAAwU,EAAAqG,EAAAC,GAqBA,MApBA,kBAAA9a,EACAnF,KAAA0f,QAAAva,GAGAnF,KAAA0f,SAAA,EACA1f,KAAAslB,OAAAC,YAAApgB,EACAnF,KAAAsiB,KAAAiD,YAAApgB,EACAwU,IACA3Z,KAAAsiB,KAAAkD,UAAA7L,EACA3Z,KAAAslB,OAAAE,UAAA7L,GAEAqG,IACAhgB,KAAAsiB,KAAAmD,SAAAzF,EACAhgB,KAAAslB,OAAAG,SAAAzF,GAEAC,IACAjgB,KAAAsiB,KAAAoD,QAAAzF,EACAjgB,KAAAslB,OAAAI,QAAAzF,IAGAjgB,KAEAoC,KAAA6jB,EAAA5F,EAAAC,EAAAC,EAAA2F,GAkBA,MAjBA,iBAAAD,GACAjmB,KAAAuf,MAAAxb,KAAAkiB,EACAC,IACAlmB,KAAAuf,MAAAa,KAAA8F,GACA7F,IACArgB,KAAAuf,MAAAc,UACAC,IACAtgB,KAAAuf,MAAAe,SACAC,IACAvgB,KAAAuf,MAAAgB,cACAvgB,KAAAsiB,KAAAsD,KAAA5lB,KAAAuf,MAAAlZ,OAGArG,KAAAuf,MAAA0G,EAEAjmB,KAAAmmB,oBACAnmB,KAAAomB,mBAAA,GACApmB,KAEAoC,kBAAAikB,GAAA,GAEA,OADArmB,KAAAmmB,mBAAA,EAA+C3F,EAAI8F,mBAAAnhB,GAAAnF,KAAAsiB,KAAAiE,YAAAphB,GAAAwU,YAAA9Z,EACnDG,KAEAoC,aAAA+C,GACA,OAAAnF,KAAAmmB,mBAAAnmB,KAAAmmB,mBAAAhhB,GAAAnF,KAAAsiB,KAAAiE,YAAAphB,EAAA,MAAAwU,MAEAvX,cAAAwe,EAAAjH,EAAAkH,EAAA,IACA,OAAeL,EAAIgG,SAAAxmB,KAAAymB,aAAAxK,KAAAjc,MAAA4gB,EAAAjH,EAAAkH,GAEnBze,WAAA6J,EAAA1L,EAAAwlB,EAAArY,GACAA,IACAA,EAAqBtB,EAASsB,OAAAzB,IAC9B,IAAAxB,EAAAwB,EAAA,MACA,OAAAjM,KAAAsiB,KAAAoE,WAAA,SAAA1mB,KAAAsiB,KAAAoE,UACAjc,EAAAwB,EAAA,MAEA,UAAAjM,KAAAsiB,KAAAoE,WAAA,UAAA1mB,KAAAsiB,KAAAoE,YACAjc,EAAAiD,EAAA,IAEA,IAAAhD,EAAAgD,EAAA,GAOA,MANA,OAAAnN,GAAA,SAAAA,EACAmK,EAAAuB,EAAA,MAEA,OAAA1L,GAAA,UAAAA,IACAmK,EAAAuB,EAAA,OAEA,MAA8BvG,EAAE+E,EAAAsb,EAAA,GAAArb,EAAAqb,EAAA,QAAuCrgB,EAAE+E,EAAAC,GAEzEtI,QACA,QAAA0C,KAAA9E,KAAAslB,OACAtlB,KAAAslB,OAAA7G,eAAA3Z,KACA9E,KAAAsiB,KAAAxd,GAAA9E,KAAAslB,OAAAxgB,IAKA,OAFA9E,KAAAuf,MAAA,IAAyBC,EACzBxf,KAAAsiB,KAAAsD,KAAA5lB,KAAAuf,MAAAlZ,MACArG,KAEAoC,SACApC,KAAAqf,SACArf,KAAAsiB,KAAAvL,OACA/W,KAAAsf,UACAtf,KAAAsiB,KAAAvC,SAEA3d,MAAAa,EAAAgM,EAAA,EAAA4Q,EAAA,UACA,GAAA5c,EAAA,CAEA,IAAa0hB,EAAU9E,GACvB,UAAAtc,SAA+Bsc,4CAG/B,OAFQ8E,EAAU9E,GAAA7f,KAAAsiB,KAAArf,EAAAgM,GAClBjP,KAAA2mB,SACA3mB,MAEAoC,cAAA0iB,EAAArd,EAAAwH,EAAA,IACAxH,IAEAqd,EAAA8B,YACA9B,EAAA+B,IAAApf,EAAA,GAAAA,EAAA,GAAAwH,EAAA,EAAyChP,EAAKyB,QAAA,GAC9CojB,EAAAzT,aAEAjP,OAAA0B,GAGA,OAFQ6gB,EAAUpV,OAAAvP,KAAAsiB,KAAAxe,EAAA,GAAAA,EAAA,OAClB9D,KAAA2mB,SACA3mB,KAEAoC,WAAA0iB,EAAArd,EAAAwH,EAAA6X,EAAAC,EAAAC,GACAvf,IAEAqd,EAAA8B,YACA9B,EAAA+B,IAAApf,EAAA,GAAAA,EAAA,GAAAwH,EAAA6X,EAAAC,EAAAC,IAEA5kB,IAAAqF,EAAAwH,EAAA6X,EAAAC,EAAAC,GAGA,OAFQrC,EAAUkC,IAAA7mB,KAAAsiB,KAAA7a,EAAAwH,EAAA6X,EAAAC,EAAAC,GAClBhnB,KAAA2mB,SACA3mB,KAEAoC,cAAA0iB,EAAArd,EAAAwf,GACA,IAAAxf,EACA,OACA,IAAAyf,EAAAzf,EAAA,GAAAwf,EACAzc,EAAA/C,EAAA,GAAAwf,EACAE,EAAA1f,EAAA,GAAAwf,EACAG,EAAA3f,EAAA,GAAAwf,EACAnC,EAAA8B,YACA9B,EAAAuC,OAAAH,EAAA1c,GACAsa,EAAAwC,OAAAJ,EAAAE,GACAtC,EAAAwC,OAAAH,EAAAC,GACAtC,EAAAwC,OAAAH,EAAA3c,GACAsa,EAAAzT,YAEAjP,OAAAqF,EAAAwf,GAGA,OAFQtC,EAAU4C,OAAAvnB,KAAAsiB,KAAA7a,EAAAwf,GAClBjnB,KAAA2mB,SACA3mB,KAEAoC,YAAA0iB,EAAAhhB,GACA,KAAAA,EAAAtB,OAAA,IAEAsiB,EAAA8B,YACA9B,EAAAuC,OAAAvjB,EAAA,MAAAA,EAAA,OACA,QAAAZ,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAClDY,EAAAZ,IACA4hB,EAAAwC,OAAAxjB,EAAAZ,GAAA,GAAAY,EAAAZ,GAAA,KAGAd,KAAA0B,GAGA,OAFQ6gB,EAAUnb,KAAAxJ,KAAAsiB,KAAAxe,GAClB9D,KAAA2mB,SACA3mB,KAEAoC,eAAA0iB,EAAAhhB,GACA,KAAAA,EAAAtB,OAAA,IAEAsiB,EAAA8B,YACA9B,EAAAuC,OAAAvjB,EAAA,MAAAA,EAAA,OACA,QAAAZ,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAClDY,EAAAZ,IACA4hB,EAAAwC,OAAAxjB,EAAAZ,GAAA,GAAAY,EAAAZ,GAAA,IAEA4hB,EAAAzT,aAEAjP,QAAA0B,GAGA,OAFQ6gB,EAAU6C,QAAAxnB,KAAAsiB,KAAAxe,GAClB9D,KAAA2mB,SACA3mB,KAEAoC,YAAA0iB,EAAAhhB,GACAA,EAAAtB,OAAA,IAEAsiB,EAAA8B,YACA9B,EAAAuC,OAAAvjB,EAAA,MAAAA,EAAA,OACAghB,EAAAwC,OAAAxjB,EAAA,MAAAA,EAAA,OACAghB,EAAAwC,OAAAxjB,EAAA,MAAAA,EAAA,OACAghB,EAAAwC,OAAAxjB,EAAA,MAAAA,EAAA,OACAghB,EAAAzT,aAEAjP,KAAA0B,GAGA,OAFQ6gB,EAAU3Y,KAAAhM,KAAAsiB,KAAAxe,GAClB9D,KAAA2mB,SACA3mB,KAEAoC,aAAA0iB,EAAA2C,EAAAC,EAAA,IAAwChiB,EAAEiiB,GAC1C,oBAAAD,EAAA,GACA5C,EAAAkB,UAAAyB,EAAAC,EAAA,GAAAA,EAAA,QAEA,CACA,IAAA9b,EAAA8b,EACAC,EACA7C,EAAAkB,UAAAyB,EAAAE,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAA/b,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,OAGAkZ,EAAAkB,UAAAyB,EAAA7b,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,MAAAA,EAAA,QAIAxJ,MAAAqlB,EAAAC,EAAAE,GAEA,OADQjD,EAAUkD,MAAA7nB,KAAAsiB,KAAAmF,EAAAC,EAAAE,GAClB5nB,KAEAoC,YAAA0iB,EAAArd,EAAAqgB,EAAAC,GACAtgB,GAEAqd,EAAAkD,SAAAF,EAAArgB,EAAA,GAAAA,EAAA,GAAAsgB,GAEA3lB,KAAAqF,EAAAqgB,EAAAC,GAEA,OADQpD,EAAUsD,KAAAjoB,KAAAsiB,KAAA7a,EAAAqgB,EAAAC,GAClB/nB,KAEAoC,QAAA6J,EAAA6b,EAAAI,EAAA,SAAArH,EAAA,GAAAsH,GAAA,GACAA,IACAnoB,KAAAsiB,KAAA8F,aAAAF,GACA,IAAAnkB,EAAmBqI,EAASrI,KAAAkI,GAC5BL,EAAA5L,KAAAqoB,cAAAP,EAAA/jB,EAAA,GAAA8c,GAEA,OADA7gB,KAAAioB,KAAAjoB,KAAAsoB,WAAArc,EAAAic,GAAAtc,EAAA,IACA5L,KAEAoC,aAAA6J,EAAA6b,EAAAvH,EAAA,IAAA2H,EAAA,MAAAK,GAAA,GACA,IAAAxkB,EAAmBqI,EAASrI,KAAAkI,GAC5BjM,KAAAsiB,KAAA8F,aAAA,MACA,IAAAI,EAAAxoB,KAAAuf,MAAAxb,KAAAwc,EACAkI,EAAA,CAAAC,EAAAC,EAAA,GAAA3B,EAAA,KACA,IAAA0B,EACA,OAAAC,EACA,GAAAJ,GAAAvB,EAAAwB,EAAAzkB,EAAA,KAAAykB,EACA,OAAAG,EACA,GAAA3B,EAAA,IACA,UAAAzjB,MAAA,iCACA,IAAAqI,EAAA5L,KAAAqoB,cAAAK,EAAA3kB,EAAA,OACA6kB,EAAAhd,EAAA,GAAAid,QAAA,MACA,GAAAD,GAAA,EAEA,OADAD,EAAAxlB,KAAAyI,EAAA,GAAAmV,OAAA,EAAA6H,IACAH,EAAAC,EAAA3H,OAAA6H,EAAA,GAAAD,EAAA3B,EAAA,GAEA,IAAA8B,EAAAld,EAAA,GAAAmd,YAAA,QACAD,GAAA,GAAAld,EAAA,KAAA8c,EAAAlmB,UACAsmB,OAAAjpB,GACA,IAAA2J,EAAAoC,EAAA,GAAAmV,OAAA,EAAA+H,GAEA,OADAH,EAAAxlB,KAAAqG,GACAoC,EAAA,OAAAA,EAAA,KAAA8c,EAAAlmB,OAAAmmB,EAAAF,EAAAC,EAAA3H,OAAA+H,GAAAld,EAAA,IAAA+c,EAAA3B,EAAA,IAEAxV,EAAAiX,EAAAX,GACAkB,EAAAxX,EAAAhP,OAAAgmB,EACAS,EAAAhd,EACA,aAAAic,GAAA,UAAAA,EAAA,CACA,IAAAgB,GAAAnlB,EAAA,GAAAilB,GAAA,EACAT,IACAW,EAAA1nB,KAAAN,IAAA,EAAAgoB,IACAD,EAAA,IAAuBzkB,EAAKyH,EAAA,GAAAxF,KAAA,EAAAyiB,GAAAjd,EAAA,GAAArC,UAAA,EAAAsf,SAG5BD,EADA,UAAAf,EACA,IAAuB1jB,EAAKyH,EAAA,GAAAxF,KAAA,EAAA1C,EAAA,GAAAilB,GAAA/c,EAAA,IAG5B,IAAuBzH,EAAKyH,EAAA,GAAAA,EAAA,GAAAxF,KAAA1C,EAAA,GAAAilB,IAE5B,IAAAtb,EAAqBtB,EAASsB,OAAAub,GAC9B,QAAA/lB,EAAA,EAAA2B,EAAA2M,EAAAhP,OAA2CU,EAAA2B,EAAS3B,IACpDlD,KAAAioB,KAAAjoB,KAAAsoB,WAAAW,EAAA,SAAA/lB,EAAAslB,GAAA9a,GAAA8D,EAAAtO,IAEA,OAAAlD,KAEAoC,UAAA+mB,EAAA,OAAAC,EAAA,cAOA,MANA,UAAAA,IACAA,EAAA,UACA,YAAAA,IACAA,EAAA,cACAppB,KAAAsiB,KAAAoE,UAAAyC,EACAnpB,KAAAsiB,KAAA8F,aAAAgB,EACAppB,KAEAoC,IAAA0lB,GACA,IAAA5Q,EAAAlX,KAAAsiB,KAAAiE,YAAAuB,GAAAnO,MAAA,GAGA,OAFA3Z,KAAA+f,QAAA,GAAAhJ,KAAA,kBAAA/K,KAAA,QAAAkL,EAAA,MACAlX,KAAA+W,KAAA,QAAAkR,KAAA,QAAAH,GACA9nB,MChgBO,MAAMqpB,EACbjnB,wBAAAwY,EAAAjC,EAAA9B,EAAA,GACA,IAAA/S,EAAA,IAAsBU,EACtB,QAAAtB,EAAA,EAAuBA,EAAAyV,EAAWzV,IAAA,CAClC,IAAAD,EAAA,CAAA2X,EAAAlT,EAAAlG,KAAAqC,SAAA+W,EAAAjB,OACA9C,EAAA,GACA5T,EAAAE,KAAAyX,EAAAjT,EAAAnG,KAAAqC,SAAA+W,EAAApN,QACAqJ,EAAA,GACA5T,EAAAE,KAAAyX,EAAA3V,EAAAzD,KAAAqC,SAAA+W,EAAAX,OACAnW,EAAAX,KAAA,IAAyBuC,EAAEzC,IAE3B,OAAAa,EAEA1B,wBAAAoH,EAAAmP,GACA,IAAAjG,EAAiBjK,EAAI6gB,UAAA9f,EAAAmP,EAAA,GAGrB,OAFAjG,EAAAuB,QAAAzK,EAAA,IACAkJ,EAAAvP,KAAAqG,IAAAhH,OAAA,IACAkQ,EAEAtQ,eAAAwY,EAAA2O,EAAAC,EAAAC,EAAA,SACA,OAAAF,GAAA,IAAAC,EACA,UAAAjmB,MAAA,qCACA,IAAAqJ,EAAAgO,EAAA7W,KAAA6F,UAAA,GAAA8f,QAAAH,EAAAC,GACAzD,EAAAnZ,EAAA9F,UAAA2iB,GACArlB,EAAA,IAAoBI,EACpB,QAAAwK,EAAA,EAAuBA,EAAAwa,EAAUxa,IACjC,QAAA7J,EAAA,EAA2BA,EAAAokB,EAAapkB,IACxCf,EAAAjB,KAAAyX,EAAAtN,QAAA7G,KAAAmG,EAAA9F,UAAA3B,EAAA6J,IAAA7B,IAAA4Y,IAGA,OAAA3hB,EAEAhC,iBAAAwY,EAAA2O,EAAAC,GACA,OAAAD,GAAA,IAAAC,EACA,UAAAjmB,MAAA,qCACA,IAAAqJ,EAAAgO,EAAA7W,KAAA6F,UAAA,GAAA7D,OAAAwjB,EAAAC,GACAplB,EAAA,GACA,QAAA4K,EAAA,EAAuBA,EAAAwa,EAAUxa,IACjC,QAAA7J,EAAA,EAA2BA,EAAAokB,EAAapkB,IACxCf,EAAAjB,KAAA,IAA2BqB,EAAKoW,EAAAtN,QAAA7G,KAAAmG,EAAA9F,UAAA3B,EAAA6J,IAAA4L,EAAAtN,QAAA7G,KAAAmG,EAAA9F,UAAA3B,EAAA6J,GAAA7B,IAAAP,MAGhC,OAAAxI,EAEAhC,iBAAAsL,EAAAuB,EAAA0J,GACA,IAAAvU,EAAA,IAAoBI,EACpBxB,EAAgB/C,EAAKyB,OAAAiX,EACrB,QAAAzV,EAAA,EAAuBA,EAAAyV,EAAWzV,IAClCkB,EAAAjB,KAAA,IAAuBuC,EAAEgI,GAAApE,QAAAtG,EAAAE,EAAyBjD,EAAK0B,QAAAsN,GAAA,IAEvD,OAAA7K,EAEAhC,gBAAA0B,EAAA6lB,EAAA,IAAAC,EAAA,IAAAJ,EAAA,EAAAD,EAAA,GACA,IAAAM,EAAAroB,KAAAqC,SACAO,EAAA,IAAoBI,EACpB,QAAAtB,EAAA,EAAA2B,EAAAf,EAAAtB,OAAyCU,EAAA2B,EAAS3B,IAAA,CAClD,IAAA4mB,EAAA,IAAyBC,EAAKjmB,EAAAZ,IAC9B8L,EAAAwa,KAAA,EAAAhoB,KAAAoC,MAAAV,EAAAsmB,GAAAtmB,EACAiC,EAAAokB,KAAA,EAAArmB,EAAAqmB,EAAArmB,EACA4mB,EAAAE,UAAAL,EAAAxkB,EAAAykB,EAAA5a,GACA8a,EAAAD,QACAzlB,EAAAjB,KAAA2mB,GAEA,OAAA1lB,EAEAhC,gBAAA0B,GACA,OAAemmB,EAAQzR,KAAA1U,IAGvB,MAAAomB,EAAA,CACA,oCACA,oCACA,qCAEAC,EAAA,sBACA,4EACA,2EACA,2EACA,4EACA,yEACA,2EACA,4EACA,yEACA,yEACA,2EACA,yEACA,yEAEO,MAAMJ,UAAcrkB,EAC3BtD,eAAAG,GACAoU,SAAApU,GACAvC,KAAAoqB,KAAA,GACApqB,KAAAqqB,GAAA,IAAsB3kB,EAAE,SACxB1F,KAAAoqB,KAAAD,EAAA9lB,OAAA8lB,GAEA/nB,aAAAG,GACAvC,KAAAqqB,GAAA,IAAsB3kB,KAAEnD,GAExBH,KAAAsF,EAAA,EAAAC,EAAA,GACA3H,KAAAqqB,GAAAld,IAAAzF,EAAAC,GAEAvF,KAAAkE,GACAA,EAAA,GAAAA,EAAA,IACAA,GAAA,QACAA,EAAA9E,KAAAoC,MAAA0C,IACA,MACAA,MAAA,GACA,QAAApD,EAAA,EAAuBA,EAAA,IAASA,IAAA,CAChC,IAAAwb,EAAA,EAAAxb,EAAAinB,EAAAjnB,GAAA,IAAAoD,EAAA6jB,EAAAjnB,GAAAoD,GAAA,MACAtG,KAAAoqB,KAAAlnB,GAAAlD,KAAAoqB,KAAAlnB,EAAA,KAAAwb,GAGAtc,UACA,IAAAc,EAAA1B,KAAAN,IAAA,EAAAM,KAAAoC,MAAA5D,KAAAqqB,GAAA,SACAC,EAAA9oB,KAAAN,IAAA,EAAAM,KAAAoC,MAAA5D,KAAAqqB,GAAA,SACA3iB,EAAA1H,KAAAqqB,GAAA,OAAAnnB,EACAyE,EAAA3H,KAAAqqB,GAAA,OAAAC,EACAC,EAAkBhlB,EAAGK,IAAAskB,GAAAhnB,EAAAlD,KAAAoqB,KAAAE,IAAA,KAAA5iB,EAAAC,EAAA,IACrB6iB,EAAkBjlB,EAAGK,IAAAskB,GAAAhnB,EAAAlD,KAAAoqB,KAAAE,EAAA,SAAA5iB,EAAAC,EAAA,MACrB8iB,EAAkBllB,EAAGK,IAAAskB,GAAAhnB,EAAA,EAAAlD,KAAAoqB,KAAAE,IAAA,KAAA5iB,EAAA,EAAAC,EAAA,IACrB+iB,EAAkBnlB,EAAGK,IAAAskB,GAAAhnB,EAAA,EAAAlD,KAAAoqB,KAAAE,EAAA,SAAA5iB,EAAA,EAAAC,EAAA,MACrBgjB,EAAAzb,aAAA,EAAAA,EAAA,QACA0b,EAAAD,EAAAjjB,GACA,OAAeiH,EAAGC,KAAMD,EAAGC,KAAA2b,EAAAE,EAAAG,GAAqBjc,EAAGC,KAAA4b,EAAAE,EAAAE,GAAAD,EAAAhjB,KAG5C,MAAMsiB,UAAiBzlB,EAC9BpC,cACAuU,SAAAqG,WACAhd,KAAA6qB,MAAA,GAEAzoB,SAAA0oB,GAAA,GACA,GAAA9qB,KAAAwC,OAAA,EACA,SACAxC,KAAA6qB,MAAA,GACA,IAAAvY,EAAAtS,KAAAwC,OACAuoB,EAAA,GACA,QAAA7nB,EAAA,EAAuBA,EAAAoP,EAAOpP,IAC9B6nB,EAAA7nB,KACA6nB,EAAAtrB,KAAA,CAAAyD,EAAAonB,IAAAtqB,KAAAsqB,GAAA,GAAAtqB,KAAAkD,GAAA,IACA,IAAAY,EAAA9D,KAAA+C,QACAmB,EAAAlE,KAAAgrB,iBACAlnB,IAAAO,OAAAH,GACA,IAAA+mB,EAAA,CAAAjrB,KAAAkrB,QAAA5Y,IAAA,EAAAA,EAAA,EAAApO,IACAinB,EAAA,GACAC,EAAA,GACA,QAAAloB,EAAA,EAAA2B,EAAAkmB,EAAAvoB,OAA6CU,EAAA2B,EAAS3B,IAAA,CACtD,IAAAiC,EAAA4lB,EAAA7nB,GACAmoB,EAAA,GACAf,EAAAW,EAAAzoB,OAGA,IAFAxC,KAAA6qB,MAAA1lB,KACAnF,KAAA6qB,MAAA1lB,GAAA,IACAmlB,KAAA,CACA,IAAAgB,EAAAL,EAAAX,GACArb,EAAAqc,EAAA/b,OAAA,MACA9J,EAAA3B,EAAAqB,GAAAyE,UAAA0hB,EAAA/b,OAAA,IACA9J,EAAA,MAAAA,EAAA,GAAAA,EAAA,GAAAwJ,KACAkc,EAAAhoB,KAAAmoB,GACAF,EAAAjoB,KAAAmoB,EAAAC,UACAN,EAAAvS,OAAA4R,EAAA,IAGA7kB,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAwJ,IAAkEhP,EAAKgB,UAGvEoqB,EAAAloB,KAAAmoB,EAAApoB,EAAAooB,EAAAhB,EAAAgB,EAAAhB,EAAAgB,EAAAxmB,EAAAwmB,EAAAxmB,EAAAwmB,EAAApoB,GACA+nB,EAAAvS,OAAA4R,EAAA,IAIA,IAFYL,EAAQuB,QAAAH,GACpBf,EAAAe,EAAA7oB,OACA8nB,EAAA,GACAW,EAAA9nB,KAAAnD,KAAAkrB,QAAAG,IAAAf,GAAAe,IAAAf,GAAAnlB,GAAA,EAAArB,IAGA,QAAAZ,EAAA,EAAA2B,EAAAomB,EAAAzoB,OAA4CU,EAAA2B,EAAS3B,IAAA,CACrD,IAAAuoB,EAAAR,EAAA/nB,GACAuoB,EAAAvoB,EAAAoP,GAAAmZ,EAAAnB,EAAAhY,GAAAmZ,EAAA3mB,EAAAwN,IACA6Y,EAAAhoB,KAAAsoB,GACAL,EAAAjoB,KAAAsoB,EAAAF,UACAvrB,KAAA0rB,OAAAD,IAGA,SAAAL,EAAAD,EAEA/oB,UACA,IAAAupB,EAAA,GAEA,QAAAzoB,EAAA,EAAA2B,EADA7E,KAAA6qB,MACAroB,OAAuCU,EAAA2B,EAAS3B,IAChDyoB,EAAAxoB,KAAAnD,KAAA4rB,YAAA1oB,GAAA,IAEA,OAAAyoB,EAEAvpB,OACA,OAAApC,KAAA6qB,MAEAzoB,YAAAc,EAAAzD,GAAA,GACA,IAAAosB,EAAA,IAAqBrnB,EACrB8N,EAAAtS,KAAA6qB,MACA,QAAA/lB,KAAAwN,EAAApP,GACAoP,EAAApP,GAAAub,eAAA3Z,IACA+mB,EAAA1oB,KAAAmP,EAAApP,GAAA4B,GAAAyK,OAAA,IAEA,SAAwB3E,EAAIkhB,UAAAD,KAE5BzpB,UAAAc,GACA,IAAA2oB,EAAA,GACAvZ,EAAAtS,KAAA6qB,MACA,QAAA/lB,KAAAwN,EAAApP,GACAoP,EAAApP,GAAAub,eAAA3Z,IACA+mB,EAAA1oB,KAAAmP,EAAApP,GAAA4B,IAEA,OAAA+mB,EAEAzpB,OAAAqpB,GACAzrB,KAAA6qB,MAAAY,EAAAvoB,MAA2B1B,KAAAH,IAAAoqB,EAAAnB,EAAAmB,EAAA3mB,MAAsBtD,KAAAN,IAAAuqB,EAAAnB,EAAAmB,EAAA3mB,MAAmB2mB,EACpEzrB,KAAA6qB,MAAAY,EAAAnB,MAA2B9oB,KAAAH,IAAAoqB,EAAAvoB,EAAAuoB,EAAA3mB,MAAsBtD,KAAAN,IAAAuqB,EAAAvoB,EAAAuoB,EAAA3mB,MAAmB2mB,EACpEzrB,KAAA6qB,MAAAY,EAAA3mB,MAA2BtD,KAAAH,IAAAoqB,EAAAvoB,EAAAuoB,EAAAnB,MAAsB9oB,KAAAN,IAAAuqB,EAAAvoB,EAAAuoB,EAAAnB,MAAmBmB,EAEpErpB,iBACA,IAAAuS,EAAA3U,KAAA,GACA4U,EAAA5U,KAAA,GACA,QAAAkD,EAAA,EAAA2B,EAAA7E,KAAAwC,OAA0CU,EAAA2B,EAAS3B,IACnDyR,IAAAvH,KAAApN,KAAAkD,IACA0R,IAAAvH,KAAArN,KAAAkD,IAEA,IAAAuC,EAAAmP,EAAAhL,UAAA+K,GACAjG,EAAAiG,EAAAlO,KAAAmO,GAAA7O,OAAA,GACAgmB,EAAAvqB,KAAAN,IAAAuE,EAAA,GAAAA,EAAA,IACA,WAAmBjB,EAAKkK,EAAA9E,UAAA,GAAAmiB,KAAArd,EAAAjI,KAAA,KAAAslB,GAAArd,EAAAjI,KAAA,GAAAslB,OAExB3pB,UAAAc,EAAAonB,EAAAxlB,EAAAhB,EAAA9D,MACA,WAAmBwE,EAAKV,EAAAZ,GAAAY,EAAAwmB,GAAAxmB,EAAAgB,IAExB1C,QAAAc,EAAAonB,EAAAxlB,EAAAknB,EAAAloB,EAAA9D,MACA,IAAA4L,EAAAogB,GAAAhsB,KAAAisB,UAAA/oB,EAAAonB,EAAAxlB,EAAAhB,GACA,OACAZ,IACAonB,IACAxlB,IACAymB,SAAA3f,EACA2D,OAAoBY,EAAQ+b,aAAAtgB,IAG5BxJ,eAAAipB,GACA,IAAAf,EAAAe,EAAA7oB,OACA,KAAA8nB,EAAA,IACA,IAAA5lB,EAAA2mB,IAAAf,GACAtnB,EAAAqoB,IAAAf,GACApnB,EAAAonB,EACA,KAAApnB,EAAA,IACA,IAAAoP,EAAA+Y,IAAAnoB,GACA4C,EAAAulB,IAAAnoB,GACA,GAAAF,GAAA8C,GAAApB,GAAA4N,GAAAtP,GAAAsP,GAAA5N,GAAAoB,EAAA,CACAulB,EAAA3S,OAAA4R,EAAA,GACAe,EAAA3S,OAAAxV,EAAA,GACA,QAIA,OAAAmoB,GCrQO,MAAMc,UAAczmB,EAC3BtD,eAAAG,GACAoU,SAAApU,GACAvC,KAAAosB,MAAA,MACApsB,KAAAqsB,SAAA,EAEAjqB,eAAAG,GACA,IAAAU,EAAA,UACAkC,EAAgBhD,EAAIyU,QAAArU,GACpB,QAAAW,EAAA,EAAA2B,EAAA5B,EAAAT,OAAuCU,EAAA2B,EAAS3B,IAChDA,EAAAiC,EAAA3C,SACAS,EAAAC,GAAAiC,EAAAjC,IAEA,WAAmBipB,EAAKlpB,GAExBb,eAAAkqB,GAGA,GAFA,KAAAA,EAAA,KACAA,IAAAvL,OAAA,IACAuL,EAAA9pB,QAAA,GACA,IAAA4C,EAAAlC,GAAAopB,EAAAppB,IAAA,IACAopB,KAAqBlnB,EAAA,KAAQA,EAAA,KAAQA,EAAA,KAAQA,EAAA,KAAQA,EAAA,KAAQA,EAAA,KAE7D,IAAAmnB,EAAA,EACA,IAAAD,EAAA9pB,SACA+pB,EAAAD,EAAAvL,OAAA,MACAuL,IAAAE,UAAA,MAEA,IAAAC,EAAAC,SAAAJ,EAAA,IACA,WAAmBH,EAAKM,GAAA,GAAAA,GAAA,UAAAA,EAAAF,GAExBnqB,cAAAG,GAAyB,OAAQ4pB,EAAK3T,QAAAjW,GAAAoqB,OAAA,OACtCvqB,cAAAG,GAAyB,OAAQ4pB,EAAK3T,QAAAjW,GAAAoqB,OAAA,OACtCvqB,cAAAG,GAAyB,OAAQ4pB,EAAK3T,QAAAjW,GAAAoqB,OAAA,OACtCvqB,cAAAG,GAAyB,OAAQ4pB,EAAK3T,QAAAjW,GAAAoqB,OAAA,OACtCvqB,cAAAG,GAAyB,OAAQ4pB,EAAK3T,QAAAjW,GAAAoqB,OAAA,OACtCvqB,cAAAG,GAAyB,OAAQ4pB,EAAK3T,QAAAjW,GAAAoqB,OAAA,OACtCvqB,cAAAG,GAAyB,OAAQ4pB,EAAK3T,QAAAjW,GAAAoqB,OAAA,OACtCvqB,iBAAAwqB,GAA4B,OAAQT,EAAKU,OAAAD,GAAArlB,SAAA,GAAAoO,MAAA,SACzC2W,UAAe,OAAAtsB,KAAAwF,SAAA,OACfsnB,UAAe,OAAA9sB,KAAAwF,SAAA,OACfunB,WAAgB,OAAA/sB,KAAAwF,SAAA,QAChBpD,QACA,IAAA+C,EAAA,IAAoBgnB,EAAKnsB,MAEzB,OADAmF,EAAAwnB,OAAA3sB,KAAAosB,OACAjnB,EAEA/C,OAAAwqB,EAAAI,GAAA,GACA,GAAAA,EAAA,CACA,IAAAC,EAAAjtB,KAAAosB,MAAAc,cAAA,KAAAN,EAAAM,cACA,IAAgBf,EAAKc,GAIrB,UAAA1pB,MAAA,6BAAA0pB,GAHAjtB,KAAA2J,GAAwBwiB,EAAKc,GAAAjtB,UAAAqsB,QAAArsB,KAAAqsB,UAO7B,OADArsB,KAAAosB,MAAAQ,EACA5sB,KAEA4sB,WAAgB,OAAA5sB,KAAAosB,MAChBpd,QAAa,OAAAhP,KAAA,GACbgP,MAAAsD,GAActS,KAAA,GAAAsS,EACdlO,QAAa,OAAApE,KAAA,GACboE,MAAAkO,GAActS,KAAA,GAAAsS,EACd5N,QAAa,OAAA1E,KAAA,GACb0E,MAAA4N,GAActS,KAAA,GAAAsS,EACdtC,QAAa,aAAAhQ,KAAAosB,MAAApsB,KAAA,GAAAA,KAAA,GACbgQ,MAAAsC,GAEAtS,KADA,OAAAA,KAAAosB,MAAA,KACA9Z,EAEAhM,QAAa,OAAAtG,KAAA,GACbsG,MAAAgM,GAActS,KAAA,GAAAsS,EACd6a,QAAa,aAAAntB,KAAAosB,MAAApsB,KAAA,GAAAA,KAAA,GACbmtB,MAAA7a,GAEAtS,KADA,OAAAA,KAAAosB,MAAA,KACA9Z,EAEAtP,QAAa,OAAAhD,KAAA,GACbgD,MAAAsP,GAActS,KAAA,GAAAsS,EACdnN,QAAa,OAAAnF,KAAA,GACbmF,MAAAmN,GAActS,KAAA,GAAAsS,EACd8a,QAAa,OAAAptB,KAAA,GACbotB,MAAA9a,GAActS,KAAA,GAAAsS,EACdoM,QAAa,OAAA1e,KAAA,GACb0e,MAAApM,GAActS,KAAA,GAAAsS,EACdia,YAAiB,OAAAvsB,KAAAwC,OAAA,EAAAxC,KAAA,KACjBqtB,iBAAsB,OAAArtB,KAAAqsB,QACtBgB,eAAA3oB,GAAuB1E,KAAAqsB,QAAA3nB,EACvBtC,UAAAkrB,GAAA,GACA,GAAAttB,KAAAqsB,SAAAiB,EACA,OAAAttB,KACA,IAAA6sB,EAAqBV,EAAKU,OAAA7sB,KAAAosB,OAC1B,QAAAlpB,EAAA,EAAuBA,EAAA,EAAOA,IAC9BlD,KAAAkD,GAAAoqB,EAEkB3e,EAAG4e,WAAAvtB,KAAAkD,GAAA2pB,EAAA3pB,GAAA,GAAA2pB,EAAA3pB,GAAA,QADHyL,EAAG4e,WAAAvtB,KAAAkD,GAAA,IAAA2pB,EAAA3pB,GAAA,GAAA2pB,EAAA3pB,GAAA,IAIrB,OADAlD,KAAAqsB,QAAAiB,EACAttB,KAEAoC,WAAAkrB,GAAA,GAA+B,OAAAttB,KAAA+P,QAAAyd,UAAAF,GAC/BlrB,SAAAqrB,EAAA,QACA,UAAAA,EAAA,CACA,IAAAC,EAAApb,IACA,IAAAhM,EAAA9E,KAAAoC,MAAA0O,GAAA9M,SAAA,IACA,OAAAc,EAAA9D,OAAA,MAAA8D,KAEA,UAAuBonB,EAAA1tB,KAAA,MAAgB0tB,EAAA1tB,KAAA,MAAgB0tB,EAAA1tB,KAAA,MAEvD,cAAAytB,UAC2BjsB,KAAAoC,MAAA5D,KAAA,OAAuBwB,KAAAoC,MAAA5D,KAAA,OAAuBwB,KAAAoC,MAAA5D,KAAA,OAAuBA,KAAAusB,QAEhG,OAAAkB,SAC0BjsB,KAAAoC,MAAA5D,KAAA,OAAuBwB,KAAAoC,MAAA5D,KAAA,OAAuBwB,KAAAoC,MAAA5D,KAAA,SAGlDA,KAAAosB,SAAcpsB,KAAA,MAAWA,KAAA,MAAWA,KAAA,MAAWA,KAAAusB,SAGrEnqB,gBAAA0qB,EAAAa,GAAA,EAAAC,GAAA,GACA,IAAA5e,EAAA5K,EAAAM,GAAAipB,EAAAb,IAAAe,aACA3sB,EAAAM,KAAAN,IAAA8N,EAAA5K,EAAAM,GACArD,EAAAG,KAAAH,IAAA2N,EAAA5K,EAAAM,GACAsL,GAAA9O,EAAAG,GAAA,EACAiF,EAAA0J,EACAmd,EAAAnd,EACA,GAAA9O,GAAAG,EACA2O,EAAA,EACA1J,EAAA,MAEA,CACA,IAAAb,EAAAvE,EAAAG,EACAiF,EAAA6mB,EAAA,GAAA1nB,GAAA,EAAAvE,EAAAG,GAAAoE,GAAAvE,EAAAG,GACA2O,EAAA,EACA9O,IAAA8N,EACAgB,GAAA5L,EAAAM,GAAAe,GAAArB,EAAAM,EAAA,KAEAxD,IAAAkD,EACA4L,GAAAtL,EAAAsK,GAAAvJ,EAAA,EAEAvE,IAAAwD,IACAsL,GAAAhB,EAAA5K,GAAAqB,EAAA,GAGA,OAAe0mB,EAAK2B,IAAA,EAAA9d,EAAA,MAAAA,EAAA1J,EAAA6mB,EAAAL,EAAAP,OAEpBnqB,gBAAA0rB,EAAAH,GAAA,EAAAC,GAAA,GACA,IAAA5d,EAAA1J,EAAA6mB,GAAAW,EAGA,GAFAH,IACA3d,GAAA,KACA,GAAA1J,EACA,OAAmB6lB,EAAKW,IAAA,IAAAK,EAAA,IAAAA,EAAA,IAAAA,EAAAW,EAAAvB,OACxB,IAAAwB,EAAAZ,GAAA,GAAAA,GAAA,EAAA7mB,GAAA6mB,EAAA7mB,EAAA6mB,EAAA7mB,EACArD,EAAA,EAAAkqB,EAAAY,EACAf,EAAAphB,GAEA,GADAA,IAAA,EAAAA,EAAA,EAAAA,EAAA,EAAAA,EAAA,EAAAA,GACA,EACA3I,GAAA8qB,EAAA9qB,GAAA2I,EAAA,EAEA,EAAAA,EAAA,EACAmiB,EAEA,EAAAniB,EAAA,EACA3I,GAAA8qB,EAAA9qB,IAAA,IAAA2I,GAAA,EAGA3I,EAGA+qB,EAAA,QACA,OAAe7B,EAAKW,IAAAkB,EAAAhB,EAAAhd,EAAA,KAAAge,EAAAhB,EAAAhd,GAAAge,EAAAhB,EAAAhd,EAAA,KAAA8d,EAAAvB,OAEpBnqB,gBAAA0qB,EAAAa,GAAA,EAAAC,GAAA,GACA,IAAA5e,EAAA5K,EAAAM,GAAAipB,EAAAb,IAAAe,aACA3sB,EAAAM,KAAAN,IAAA8N,EAAA5K,EAAAM,GACArD,EAAAG,KAAAH,IAAA2N,EAAA5K,EAAAM,GACAe,EAAAvE,EAAAG,EACA2O,EAAA,EACA1J,EAAA,IAAApF,EAAA,EAAAuE,EAAAvE,EACAwd,EAAAxd,EAYA,OAXAA,GAAAG,IACAH,IAAA8N,EACAgB,GAAA5L,EAAAM,GAAAe,GAAArB,EAAAM,EAAA,KAEAxD,IAAAkD,EACA4L,GAAAtL,EAAAsK,GAAAvJ,EAAA,EAEAvE,IAAAwD,IACAsL,GAAAhB,EAAA5K,GAAAqB,EAAA,IAGe0mB,EAAK8B,IAAA,EAAAje,EAAA,MAAAA,EAAA1J,EAAAoY,EAAAoO,EAAAP,OAEpBnqB,gBAAA6rB,EAAAN,GAAA,EAAAC,GAAA,GACA,IAAA5d,EAAA1J,EAAAoY,GAAAuP,EACAN,IACA3d,GAAA,KACA,IAAA9M,EAAA1B,KAAAoC,MAAA,EAAAoM,GACAd,EAAA,EAAAc,EAAA9M,EACAD,EAAAyb,GAAA,EAAApY,GACAynB,EAAArP,GAAA,EAAAxP,EAAA5I,GACAsF,EAAA8S,GAAA,KAAAxP,GAAA5I,GAKAnB,EAJA,CACA,CAAAuZ,EAAA9S,EAAA3I,GAAA,CAAA8qB,EAAArP,EAAAzb,GAAA,CAAAA,EAAAyb,EAAA9S,GACA,CAAA3I,EAAA8qB,EAAArP,GAAA,CAAA9S,EAAA3I,EAAAyb,GAAA,CAAAA,EAAAzb,EAAA8qB,IAEA7qB,EAAA,GACA8qB,EAAA,QACA,OAAe7B,EAAKW,IAAAkB,EAAA7oB,EAAA,GAAA6oB,EAAA7oB,EAAA,GAAA6oB,EAAA7oB,EAAA,GAAA8oB,EAAA1B,OAEpBnqB,gBAAA0qB,EAAAa,GAAA,EAAAC,GAAA,GACA,IAAAzoB,EAAA,EAAA2nB,EAAAe,YAAA,GAAAf,EACA,OAAeX,EAAK+B,SAAU/B,EAAKgC,SAAAhpB,IAAA,EAAAyoB,GAEnCxrB,gBAAAgsB,EAAAT,GAAA,EAAAC,GAAA,GACA,IAAAzoB,EAAA,EAAAipB,EAAAP,YAAA,GAAAO,EACA,OAAejC,EAAKkC,SAAUlC,EAAKmC,SAAAnpB,IAAA,EAAAyoB,GAEnCxrB,gBAAA0qB,EAAAa,GAAA,EAAAC,GAAA,GACA,IAAAzoB,EAAA,EAAA2nB,EAAAe,YAAA,GAAAf,EACA,OAAeX,EAAKoC,SAAUpC,EAAKqC,SAAArpB,IAAA,EAAAyoB,GAEnCxrB,gBAAAqsB,EAAAd,GAAA,EAAAC,GAAA,GACA,IAAAzoB,EAAA,EAAAspB,EAAAZ,YAAA,GAAAY,EACA,OAAetC,EAAKuC,SAAUvC,EAAKwC,SAAAxpB,IAAA,EAAAyoB,GAEnCxrB,gBAAA0qB,EAAAa,GAAA,EAAAC,GAAA,GACA,IAAAzoB,EAAA,EAAA2nB,EAAAe,YAAA,GAAAf,EACA,OAAeX,EAAKyC,SAAUzC,EAAKgC,SAAAhpB,IAAA,EAAAyoB,GAEnCxrB,gBAAAysB,EAAAlB,GAAA,EAAAC,GAAA,GACA,IAAAzoB,EAAA,EAAA0pB,EAAAhB,YAAA,GAAAgB,EACA,OAAe1C,EAAKkC,SAAUlC,EAAK2C,SAAA3pB,IAAA,EAAAyoB,GAEnCxrB,gBAAA0qB,EAAAa,GAAA,EAAAC,GAAA,GACA,IAAAzoB,EAAAwoB,EAAAb,EAAA/c,QAAA+c,EAAAe,aACA,QAAA3qB,EAAA,EAAuBA,EAAA,EAAOA,IAC9BiC,EAAAjC,GAAAiC,EAAAjC,GAAA,OAAA1B,KAAAutB,KAAA5pB,EAAAjC,GAAA,iBAAAiC,EAAAjC,GAAA,MACA0qB,IACAzoB,EAAAjC,GAAA,IAAAiC,EAAAjC,IAEA,IAAA8jB,EAAiBmF,EAAK9rB,IAAA,SAAA8E,EAAA,YAAAA,EAAA,YAAAA,EAAA,YAAAA,EAAA,YAAAA,EAAA,WAAAA,EAAA,YAAAA,EAAA,WAAAA,EAAA,YAAAA,EAAA,GAAA2nB,EAAAP,OACtB,SAAAvF,EAAAwG,YAAAxG,EAEA5kB,gBAAA/B,EAAAstB,GAAA,EAAAC,GAAA,GACA,IAAAlmB,EAAAC,EAAA1C,GAAA0oB,EAAAttB,IAAAwtB,aACAf,EAAA,CACA,UAAAplB,GAAA,UAAAC,GAAA,SAAA1C,GACA,QAAAyC,EAAA,UAAAC,EAAA,QAAA1C,EACA,SAAAyC,GAAA,SAAAC,EAAA,UAAA1C,GAEA,QAAA/B,EAAA,EAAuBA,EAAA,EAAOA,IAC9B4pB,EAAA5pB,GAAA4pB,EAAA5pB,GAAA,IAAA4pB,EAAA5pB,GAAA,eAAA1B,KAAAutB,IAAAjC,EAAA5pB,GAAA,kBAAA4pB,EAAA5pB,GACA4pB,EAAA5pB,GAAA1B,KAAAN,IAAA,EAAAM,KAAAH,IAAA,EAAAyrB,EAAA5pB,KACA0qB,IACAd,EAAA5pB,GAAA1B,KAAA2E,MAAA,IAAA2mB,EAAA5pB,KAEA,IAAA8jB,EAAiBmF,EAAKW,MAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAzsB,EAAAksB,OACtB,SAAAvF,EAAAwG,YAAAxG,EAEA5kB,gBAAA/B,EAAAstB,GAAA,EAAAC,GAAA,GACA,IAAAzoB,EAAA,EAAA9E,EAAAwtB,YAAA,GAAAxtB,EAAA0P,QACA5K,EAAAY,OAAiBomB,EAAK6C,KACtB,IAAA5pB,EAAAkN,KAAA,QAAA9Q,KAAAutB,IAAAzc,EAAA,WAAAA,EAAA,OACA2c,EAAA7pB,EAAAD,EAAA,IACA6hB,EAAiBmF,EAAKiC,IAAA,IAAAa,EAAA,QAAA7pB,EAAAD,EAAA,IAAA8pB,GAAA,KAAAA,EAAA7pB,EAAAD,EAAA,KAAA9E,EAAAksB,OACtB,SAAAvF,EAAAwG,YAAAxG,EAEA5kB,gBAAAgsB,EAAAT,GAAA,EAAAC,GAAA,GACA,IAAAzoB,EAAA,EAAAipB,EAAAP,YAAA,GAAAO,EACAzmB,GAAAxC,EAAA,WACAuC,EAAAvC,EAAA,OAAAwC,EACA1C,EAAA0C,EAAAxC,EAAA,OACAC,EAAAkN,IACA,IAAA4c,EAAA5c,MACA,OAAA4c,EAAA,QAAAA,GAAA5c,EAAA,eAEA7M,EAAgB0mB,EAAK6C,IACrBhI,EAAiBmF,EAAK9rB,IAAAmB,KAAAN,IAAA,EAAAuE,EAAA,GAAAL,EAAAsC,IAAAlG,KAAAN,IAAA,EAAAuE,EAAA,GAAAL,EAAAuC,IAAAnG,KAAAN,IAAA,EAAAuE,EAAA,GAAAL,EAAAH,IAAAmpB,EAAA7B,OACtB,SAAAvF,EAAAwG,YAAAxG,EAEA5kB,gBAAA/B,EAAAstB,GAAA,EAAAC,GAAA,GACA,IAAAlmB,EAAAC,EAAA1C,GAAA,EAAA5E,EAAAwtB,YAAA,GAAAxtB,EACA+sB,EAAA,EAAA1lB,KAAA,GAAAC,EAAA,EAAA1C,GACAyZ,EAAA,EAAA/W,GAAAD,EAAA,GAAAC,EAAA,EAAA1C,GAEA0C,GADAA,GAAA,KACA,QAAAnG,KAAAutB,IAAApnB,EAAA,WAAAA,EAAA,OACA,IAAAwnB,EAAA,EAAwBhD,EAAK6C,IAAA,IAAY7C,EAAK6C,IAAA,MAAgB7C,EAAK6C,IAAA,KAAgB7C,EAAK6C,IAAA,IACxFI,EAAA,EAAwBjD,EAAK6C,IAAA,IAAY7C,EAAK6C,IAAA,MAAgB7C,EAAK6C,IAAA,KAAgB7C,EAAK6C,IAAA,IACxFK,EAAA,IAAA1nB,EAAA,GACA,OAAewkB,EAAK0C,IAAAQ,EAAA,GAAAA,GAAAjC,EAAA+B,GAAA,GAAAE,GAAA3Q,EAAA0Q,GAAA/uB,EAAAksB,OAEpBnqB,gBAAAysB,EAAAlB,GAAA,EAAAC,GAAA,GACA,IAAAT,EAAAC,EAAA1O,GAAA,EAAAmQ,EAAAhB,YAAA,GAAAgB,EACAlnB,GAAAwlB,EAAA,QACAmC,EAAA3nB,MACAA,EAAA2nB,EAAA,QAAAA,GAAA3nB,EAAA,cAMA,IAAAD,EAAA,GADAC,GAAA,MAFAylB,KAAA,GAAAD,GAFA,EAAwBhB,EAAK6C,IAAA,IAAY7C,EAAK6C,IAAA,MAAgB7C,EAAK6C,IAAA,KAAgB7C,EAAK6C,IAAA,MAKxF,IAAA5B,EAAA,IAFA1O,KAAA,GAAAyO,GAFA,EAAwBhB,EAAK6C,IAAA,IAAY7C,EAAK6C,IAAA,MAAgB7C,EAAK6C,IAAA,KAAgB7C,EAAK6C,IAAA,KAIxF5B,EAAA1O,GACAzZ,GAAA,EAAA0C,EAAA,GAAA+W,EAAA/W,EAAA+W,EAAAhX,IAAA,EAAAgX,GACA,OAAeyN,EAAK9rB,IAAAqH,EAAAC,EAAA1C,EAAA4pB,EAAAtC,OAEpBnqB,gBAAAgsB,EAAAT,GAAA,EAAAC,GAAA,GACA,IAAAzoB,EAAA,EAAAipB,EAAAP,YAAA,GAAAO,EACApe,EAAgBpF,EAAI2L,SAAU3L,EAAIiN,YAAArW,KAAAoW,MAAAzS,EAAA,GAAAA,EAAA,MAClC,OAAegnB,EAAKsC,IAAAtpB,EAAA,GAAA3D,KAAAmE,KAAAR,EAAA,GAAAA,EAAA,GAAAA,EAAA,GAAAA,EAAA,IAAA6K,EAAAoe,EAAA7B,OAEpBnqB,gBAAAqsB,EAAAd,GAAA,EAAAC,GAAA,GACA,IAAAzoB,EAAA,EAAAspB,EAAAZ,YAAA,GAAAY,EACApY,EAAkBzL,EAAI2kB,SAAApqB,EAAA,IACtB,OAAegnB,EAAKiC,IAAAjpB,EAAA,GAAA3D,KAAAsH,IAAAuN,GAAAlR,EAAA,GAAA3D,KAAAuH,IAAAsN,GAAAlR,EAAA,GAAAspB,EAAAlC,QAGpBJ,EAAK6C,IAAA,IAAWtpB,EAAE,sBAClBymB,EAAKU,OAAA,CACLC,IAAA,IAAatoB,EAAK,IAAKkB,EAAE,WAAcA,EAAE,WAAcA,EAAE,QACzDooB,IAAA,IAAatpB,EAAK,IAAKkB,EAAE,WAAcA,EAAE,SAAYA,EAAE,MACvDuoB,IAAA,IAAazpB,EAAK,IAAKkB,EAAE,WAAcA,EAAE,SAAYA,EAAE,MACvD0oB,IAAA,IAAa5pB,EAAK,IAAKkB,EAAE,WAAcA,GAAE,aAAiBA,GAAE,UAC5D+oB,IAAA,IAAajqB,EAAK,IAAKkB,EAAE,WAAcA,EAAE,WAAcA,EAAE,QACzDmpB,IAAA,IAAarqB,EAAK,IAAKkB,EAAE,WAAcA,GAAE,aAAiBA,GAAE,UAC5DrF,IAAA,IAAamE,EAAK,IAAKkB,EAAE,WAAcA,EAAE,WAAcA,EAAE,SCrUlD,MAAM8pB,UAAiBzS,EAC9B3a,YAAAgf,EAAAlc,GACAyR,QACA3W,KAAAgX,GAAA,WACAhX,KAAAshB,aAAA,EACAthB,KAAAuhB,SAAA,UACAvhB,KAAAyvB,KAAA,GACA,IAAA/N,EAAA,KAEA1hB,KAAAgX,GAAA,MACAoK,aAAAO,SACAD,EAAAN,EACAphB,KAAAgX,GAAA,uBAGA0K,EAAAE,SAAAC,cAAAT,IACA,EACAphB,KAAAgX,GAAAoK,EAAAL,OAAA,IAEAW,GAQA1hB,KAAAud,QAAAmE,EACA1hB,KAAAgiB,WAAAN,EAAAS,gBARAniB,KAAAgiB,WAA8BwN,EAAQhN,cAAA,uBACtCxiB,KAAAud,QAA2BiS,EAAQhN,cAAA,qBACnCxiB,KAAAgiB,WAAAE,YAAAliB,KAAAud,SACAqE,SAAAQ,KAAAF,YAAAliB,KAAAgiB,aAOAK,WAAAriB,KAAAif,OAAAhD,KAAAjc,KAAAkF,GAAA,IAEA9C,qBAAAgf,EAAA,MAAApK,EAAA0Y,GACA,IAAAjqB,EAAAmc,SAAAY,cAAApB,GAKA,OAJApK,GACAvR,EAAAgd,aAAA,KAAAzL,GACA0Y,KAAAxN,aACAwN,EAAAxN,YAAAzc,GACAA,EAEArD,OAAA8C,GACA,IAAAlF,KAAAgiB,WACA,UAAAze,0BAAgDvD,KAAAgX,cAChDhX,KAAAub,UAAA,EACAvb,KAAA0iB,eAAA,MACA1iB,KAAAqc,MAAArc,KAAAuhB,UACAvhB,KAAAud,QAAAoF,cAAA,IAAAC,MAAA,UACA,QAAA9d,KAAA9E,KAAAib,QACAjb,KAAAib,QAAAwD,eAAA3Z,IACA9E,KAAAib,QAAAnW,GAAAnB,OACA3D,KAAAib,QAAAnW,GAAAnB,MAAA3D,KAAA4a,MAAA7K,QAAA/P,MAGAA,KAAAsb,SAAAtb,KAAA0N,OACA1N,KAAA2vB,SAAA,GACAzqB,GACAA,EAAAlF,KAAA4a,MAAA5a,KAAAud,SAEAnb,MAAAygB,GAKA,OAJAA,EAAAC,UACA9iB,KAAAuhB,SAAAsB,EAAAC,SAEA9iB,KAAA+iB,WAAAljB,MAAAgjB,EAAAhH,QAAAgH,EAAAhH,OACA7b,KAEAoC,UACA,YAEA2gB,eAAAc,GACA7jB,KAAAshB,YAAAuC,EACAA,EACAX,OAAA1F,iBAAA,SAAAxd,KAAA0iB,eAAAzG,KAAAjc,eAGAA,KAAAyvB,KAAA,aACAzvB,KAAAyvB,KAAA,OACAvM,OAAAzF,oBAAA,SAAAzd,KAAA0iB,eAAAzG,KAAAjc,QAGA+iB,iBAAsB,OAAA/iB,KAAAshB,YACtBlf,OAAAsC,EAAA4Y,GACAtd,KAAA4a,MAAAlW,EACA1E,KAAA4vB,OAAA,CAAqBjW,SAAWjV,EAAAiV,UAAQnM,UAAgB9I,EAAA8I,aAAc,GACtE,QAAA1I,KAAA9E,KAAAib,QACA,GAAAjb,KAAAib,QAAAwD,eAAA3Z,GAAA,CACA,IAAA7B,EAAAjD,KAAAib,QAAAnW,GACA7B,EAAA4Y,QACA5Y,EAAA4Y,OAAA7b,KAAA4a,MAAA0C,GAGA,OAAAtd,KAEAoC,eAAAkb,GACA,IAAA5Y,EAAgB2U,EAAK6K,iBAAAlkB,KAAAgiB,WAAAiC,yBACrBjkB,KAAAshB,YACAthB,KAAA4vB,OAAA,CAAyBjW,MAAA,OAAAnM,OAAA,SAAgC,GAGzDxN,KAAA4vB,OAAA,CAAyBjW,SAAWjV,EAAAiV,UAAQnM,UAAgB9I,EAAA8I,aAAc,GAE1ExN,KAAA6b,OAAAnX,EAAA4Y,GAEAsH,cACA,OAAA5kB,KAAAud,QAEAsH,aACA,OAAA7kB,KAAAgiB,WAEA9C,YAAiB,OAAAlf,KAAAub,SACjBnZ,MAAAkiB,GAIA,OAHAA,IACAtkB,KAAAqkB,WAAAC,GACAtkB,KAAAud,QAAAsS,UAAA,GACA7vB,KAEAqkB,eAAAC,GACAtkB,KAAAuhB,SAAA+C,EACAtkB,KAAAgiB,WAAA1B,MAAAwP,gBAAA9vB,KAAAuhB,SAEA8C,iBAAsB,OAAArkB,KAAAuhB,SACtBnf,MAAA2tB,EAAA7b,EAAA8b,GAAA,GAIA,OAHAhwB,KAAAyvB,KAAAM,GAAA7b,EACA8b,IACAhwB,KAAAud,QAAA+C,MAAAyP,GAAA7b,GACAlU,KAEAoC,OAAAwtB,EAAAI,GAAA,GACA,QAAAlrB,KAAA8qB,EACAA,EAAAnR,eAAA3Z,IACA9E,KAAAsgB,MAAAxb,EAAA8qB,EAAA9qB,GAAAkrB,GAEA,OAAAhwB,KAEAoC,eAAAgf,EAAA6O,GACA,QAAAnrB,KAAAmrB,EACAA,EAAAxR,eAAA3Z,IACAsc,EAAAqB,aAAA3d,EAAAmrB,EAAAnrB,IAGA,OAAAsc,EAEAhf,uBAAA6tB,GACA,IAAArP,EAAA,GACA,QAAA9b,KAAAmrB,EACAA,EAAAxR,eAAA3Z,IACAmrB,EAAAnrB,KACA8b,MAA8B9b,MAAMmrB,EAAAnrB,QAGpC,OAAA8b,GAGO,MAAAsP,UAAwBV,EAC/BptB,UACA,WAAmB+tB,EAAQnwB,MAE3BoC,mBAAAyiB,EAAAuL,EAAApZ,EAAAqZ,GAAA,GACA,IAAAxL,MAAA3C,YACA,UAAA3e,MAAA,qCACA,IAAA6d,EAAAQ,SAAAC,kBAA8C7K,KAQ9C,OAPAoK,KACAA,EAAAQ,SAAAY,cAAA4N,IACA3N,aAAA,KAAAzL,GACAqZ,GACAjP,EAAAqB,aAAA,QAAAzL,EAAAwV,UAAA,EAAAxV,EAAA6R,QAAA,OACAhE,EAAA3C,YAAAd,IAEAA,EAEAhf,OAAAqZ,GAKA,OAJAzb,KAAAgiB,WAAAsO,iBAAA,IAA0DH,EAAQI,QAAA9U,IAClE+U,QAAAC,IACAA,EAAAC,WAAAC,YAAAF,KAEA9Z,MAAAia,OAAAnV,GAEArZ,YAEA,OADApC,KAAAgiB,WAAA6N,UAAA,GACAlZ,MAAAka,aAGO,MAAMV,UAAiB/Q,EAC9Bhd,YAAAijB,GACA1O,QACA3W,KAAAsiB,KAAA,CACA9W,MAAA,KACAslB,QAAA,MACAC,WAAA,EACAC,UAAA,OACAC,aAAA,GACA3Q,MAAA,CACAb,QAAA,EACAC,SAAA,EACA2E,WAAA,OACA6M,eAAA,OACAC,MAAA,OACAC,eAAA,MACAC,gBAAA,IACAC,eAAA,QACAC,SAAA,WACAxwB,IAAA,EACAF,KAAA,EACA8Y,MAAA,EACAnM,OAAA,GAEAoY,KAAA,kBACA4L,SAAA,GACAC,WAAA,cAEAzxB,KAAAif,QAAA,EACAjf,KAAA2lB,OAAAN,EACArlB,KAAA2lB,OAAAxY,IAAA,CAAyBxJ,MAAA,KACzB3D,KAAAsiB,KAAA9W,MAAAxL,KAAA2lB,OAAAf,QACA5kB,KAAAsiB,KAAAwO,QAAA,WAAkDX,EAAQW,UAC1D9wB,KAAAif,QAAA,KAGAoG,YAAiB,OAAArlB,KAAA2lB,OACjBvjB,QAAA0C,EAAA4Z,EAAA9R,EAAA,IACA,QAAA/M,IAAAG,KAAAsiB,KAAAhC,MAAAxb,GACA,UAAAvB,SAA+BuB,kCAC/B9E,KAAAsiB,KAAAhC,MAAAxb,MAAgC4Z,IAAI9R,IAEpCxK,KAAA+C,GAUA,MATA,kBAAAA,GACAnF,KAAA0xB,QAAA,SAAAvsB,GACAA,GACAnF,KAAA0xB,QAAA,8BAGA1xB,KAAA0xB,QAAA,aACA1xB,KAAA0xB,QAAA,aAAAvsB,IAEAnF,KAEAoC,OAAA+C,EAAAwU,EAAAqG,EAAAC,GAWA,MAVA,kBAAA9a,GACAnF,KAAA0xB,QAAA,UAAAvsB,GACAA,GACAnF,KAAA0xB,QAAA,oBAGA1xB,KAAA0xB,QAAA,cACA1xB,KAAA0xB,QAAA,eAAAvsB,GACAnF,KAAA0xB,QAAA,gBAAA/X,GAAA,UAEA3Z,KAEAoC,SAAA+C,GAEA,OADAnF,KAAA0xB,QAAA,QAAAvsB,GACAnF,KAEAoC,IAAA+C,GAOA,OALAnF,KAAAsiB,KAAA2O,aADA,kBAAA9rB,EACA,GAGAA,EAEAnF,KAEAoC,KAAA6jB,EAAA5F,EAAAC,EAAAC,EAAA2F,GAgBA,MAfA,iBAAAD,GACAjmB,KAAAuf,MAAAxb,KAAAkiB,EACAC,IACAlmB,KAAAuf,MAAAa,KAAA8F,GACA7F,IACArgB,KAAAuf,MAAAc,UACAC,IACAtgB,KAAAuf,MAAAe,SACAC,IACAvgB,KAAAuf,MAAAgB,cACAvgB,KAAAsiB,KAAAsD,KAAA5lB,KAAAuf,MAAAlZ,OAGArG,KAAAuf,MAAA0G,EAEAjmB,KAEAoC,QAQA,OAPApC,KAAAsiB,KAAAhC,MAAA,CACAb,QAAA,EAAAC,SAAA,EACA2E,WAAA,OAAA6M,eAAA,OACAE,eAAA,OAEApxB,KAAAuf,MAAA,IAAyBC,EAAI,iBAC7Bxf,KAAAsiB,KAAAsD,KAAA5lB,KAAAuf,MAAAlZ,MACArG,KAEAoC,YAAAuvB,EAAAnmB,GAKA,OAJAxL,KAAAsiB,KAAA9W,QACAxL,KAAAsiB,KAAAwO,QAAAa,EACA3xB,KAAAsiB,KAAAyO,WAAA,EACA/wB,KAAA4xB,SACA5xB,KAAAsiB,KAEAlgB,MAAAgc,GACA,IAAAA,GAAA,MAAAA,EAAAxC,UACA,UAAArY,MAAA,8CACA,OAAAvD,KAAA6xB,YAAgC1B,EAAQI,QAAAnS,GAAApe,KAAAqlB,MAAAT,SAExCxiB,SAGA,OAFApC,KAAAsiB,KAAAyO,aACA/wB,KAAAsiB,KAAA0O,aAAiChxB,KAAAsiB,KAAAwO,WAAqB9wB,KAAAsiB,KAAAyO,aACtD/wB,KAAAsiB,KAAA0O,UAEA5uB,aAAA0iB,GACA,OAAAA,EAAAkM,gBAAqCb,EAAQ2B,UAE7C1vB,eAAAgc,GACA,cAAuBA,EAAAxC,YAEvBxZ,aAAAgf,EAAAwO,GACA,IAAA1rB,EAAA,GACA0rB,EAAA,QACA1rB,EAAAf,KAAA,oBACAysB,EAAA,SACA1rB,EAAAf,KAAA,gBACA,QAAA2B,KAAA8qB,EACA,GAAAA,EAAAnR,eAAA3Z,IAAA,UAAAA,GAAA,WAAAA,EAAA,CACA,IAAA4Z,EAAAkR,EAAA9qB,GACA,GAAA4Z,EAAA,CACA,IAAAkR,EAAA,YAAA9qB,EAAA+jB,QAAA,cACA,SAEA,IAAA+G,EAAA,aAAA9qB,EAAA+jB,QAAA,gBACA,SAGA3kB,EAAAf,QAAmC2B,MAAM4Z,MAKzC,OAAAwR,EAAA6B,QAAA3Q,EAAA,CAAwCd,MAAApc,EAAA+T,KAAA,OAExC7V,iBAAA0iB,EAAArd,EAAA1D,GAKA,OAJA+gB,EAAAxE,MAAA,KAAA7Y,EAAA,QACAqd,EAAAxE,MAAA,IAAA7Y,EAAA,QACAqd,EAAAxE,MAAA,MAAAvc,EAAA,QACA+gB,EAAAxE,MAAA,OAAAvc,EAAA,QACA+gB,EAEA1iB,aAAA0iB,EAAArd,EAAAwH,EAAA,EAAA4Q,EAAA,UACA,iBAAAA,EACmBsQ,EAAQ5gB,OAAAuV,EAAArd,EAAAwH,GAGRkhB,EAAQ5I,OAAAzC,EAAArd,EAAAwH,GAG3B7M,MAAAqF,EAAAwH,EAAA,EAAA4Q,EAAA,UAKA,OAJA7f,KAAA4xB,SACA,UAAA/R,GACA7f,KAAA0xB,QAAA,wBACQvB,EAAQjQ,MAAAlgB,KAAAsiB,KAAA7a,EAAAwH,EAAA4Q,GAChB7f,KAEAoC,cAAA0iB,EAAArd,EAAAwH,EAAA,IACA,IAAAmS,EAAA8O,EAAA8B,YAAAlN,EAAAtZ,MAAA,MAA2D2kB,EAAQ8B,MAAAnN,IAInE,OAHAoL,EAAA6B,QAAA3Q,EAAA,CAAiC8Q,6BAA+BpN,EAAAmM,iBACxDd,EAAQgC,UAAArN,EAAA,IAAoBpf,EAAE+B,GAAAmC,UAAAqF,GAAA,IAA4BvJ,EAAE,EAAAuJ,EAAA,EAAAA,IAC5DkhB,EAAQ7P,MAAAc,EAAA0D,EAAAxE,OAChBc,EAEAhf,OAAA0B,GAIA,OAHA9D,KAAA4xB,SACA5xB,KAAA0xB,QAAA,wBACQvB,EAAQ5gB,OAAAvP,KAAAsiB,KAAAxe,EAAA,GAAAA,EAAA,OAChB9D,KAEAoC,cAAA0iB,EAAArd,EAAAwf,GACA,IAAA7F,EAAA8O,EAAA8B,YAAAlN,EAAAtZ,MAAA,MAA2D2kB,EAAQ8B,MAAAnN,IAInE,OAHAoL,EAAA6B,QAAA3Q,EAAA,CAAiC8Q,6BAA+BpN,EAAAmM,iBACxDd,EAAQgC,UAAArN,EAAA,IAAoBpf,EAAE+B,GAAAmC,UAAAqd,GAAA,IAA8BvhB,EAAE,EAAAuhB,EAAA,EAAAA,IAC9DkJ,EAAQ7P,MAAAc,EAAA0D,EAAAxE,OAChBc,EAEAhf,OAAAqF,EAAAwf,GAGA,OAFAjnB,KAAA4xB,SACQzB,EAAQ5I,OAAAvnB,KAAAsiB,KAAA7a,EAAAwf,GAChBjnB,KAEAoC,YAAA0iB,EAAAhhB,GACA,IAAA9D,KAAAoyB,WAAAtuB,GACA,OACA,IAAAsd,EAAA8O,EAAA8B,YAAAlN,EAAAtZ,MAAA,MAA2D2kB,EAAQ8B,MAAAnN,IAInE,OAHAoL,EAAA6B,QAAA3Q,EAAA,CAAiC8Q,2BAA6BpN,EAAAmM,iBACtDd,EAAQgC,UAAArN,EAAAhhB,EAAA,GAAAA,EAAA,IACRqsB,EAAQ7P,MAAAc,EAAA0D,EAAAxE,OAChBc,EAEAhf,KAAA0B,GAIA,OAHA9D,KAAA4xB,SACA5xB,KAAA0xB,QAAA,qBACQvB,EAAQnkB,KAAAhM,KAAAsiB,KAAAxe,GAChB9D,KAEAoC,YAAA0iB,EAAArd,EAAAqgB,GACA,IAAA1G,EAAA8O,EAAA8B,YAAAlN,EAAAtZ,MAAA,MAA2D2kB,EAAQ8B,MAAAnN,IASnE,OARAoL,EAAA6B,QAAA3Q,EAAA,CACAmQ,SAAA,WACAW,2BAAwCpN,EAAAmM,eACxCpwB,KAAA4G,EAAA,GACA1G,IAAA0G,EAAA,KAEA2Z,EAAAiR,YAAAvK,EACQqI,EAAQ7P,MAAAc,EAAA0D,EAAAxE,OAChBc,EAEAhf,KAAAqF,EAAAqgB,GAGA,OAFA9nB,KAAA4xB,SACQzB,EAAQlI,KAAAjoB,KAAAsiB,KAAA7a,EAAAqgB,GAChB9nB,KAEAoC,IAAA0lB,GAEA,OADA9nB,KAAA+W,KAAA,QAAAgJ,OAAA,WAAAkI,KAAA,QAAAH,GACA9nB,KAEAoC,IAAAqF,EAAAwH,EAAA6X,EAAAC,EAAAC,GAEA,OADQ7kB,EAAIsB,KAAA,sCACZzD,KAEAoC,KAAA0B,GAEA,OADQ3B,EAAIsB,KAAA,uCACZzD,KAEAoC,QAAA0B,GAEA,OADQ3B,EAAIsB,KAAA,0CACZzD,MAGAmwB,EAAQW,QAAA,EACRX,EAAQ2B,MAAA,EC/aD,MAAMQ,UAAiB9C,EAC9BptB,YAAAgf,EAAAlc,GAIA,GAHAyR,MAAAyK,EAAAlc,GACAlF,KAAAgX,GAAA,WACAhX,KAAAuhB,SAAA,OACA,OAAAvhB,KAAAud,QAAAuE,SAAAC,cAAA,CACA,IAAAzb,EAAoBgsB,EAAQC,WAAAvyB,KAAAud,QAAA,SAAoCvd,KAAAgX,UAChEhX,KAAAgiB,WAAAhiB,KAAAud,QACAvd,KAAAud,QAAAjX,GAGAlE,UAAe,WAAYowB,EAAOxyB,MAClC4kB,cACA,OAAA5kB,KAAAud,QAEAnb,OAAAsC,EAAA4Y,GASA,OARA3G,MAAAkF,OAAAnX,EAAA4Y,GACQgV,EAAQP,QAAA/xB,KAAA4kB,QAAA,CAChB6N,eAA8BzyB,KAAA4a,MAAAjB,SAAoB3Z,KAAA4a,MAAApN,SAClDmM,SAAwB3Z,KAAA4a,MAAAjB,QACxBnM,UAAyBxN,KAAA4a,MAAApN,SACzBklB,MAAA,6BACAC,QAAA,QAEA3yB,KAEAoC,kBAAAyiB,EAAAuL,EAAApZ,GACA,IAAA6N,MAAA3C,YACA,UAAA3e,MAAA,qCACA,IAAA6d,EAAAQ,SAAAC,kBAA8C7K,KAM9C,OALAoK,KACAA,EAAAQ,SAAAgR,gBAAA,6BAAAxC,IACA3N,aAAA,KAAAzL,GACA6N,EAAA3C,YAAAd,IAEAA,EAEAhf,OAAAqZ,GAKA,OAJAzb,KAAAgiB,WAAAsO,iBAAA,IAA0DkC,EAAOjC,QAAA9U,IACjE+U,QAAAC,IACAA,EAAAC,WAAAC,YAAAF,KAEA9Z,MAAAia,OAAAnV,GAEArZ,YAEA,OADApC,KAAAgiB,WAAA6N,UAAA,GACAlZ,MAAAka,aAGO,MAAM2B,UAAgBpT,EAC7Bhd,YAAAijB,GACA1O,QACA3W,KAAAsiB,KAAA,CACA9W,MAAA,KACAslB,QAAA,MACAC,WAAA,EACAC,UAAA,OACAC,aAAA,GACA3Q,MAAA,CACAb,QAAA,EACAC,SAAA,EACA3I,KAAA,OACAgJ,OAAA,OACA8S,eAAA,EACAC,kBAAA,QACAC,iBAAA,UAEAnN,KAAA,kBACA4L,SAAA,GACAC,WAAA,cAEAzxB,KAAAif,QAAA,EACAjf,KAAA2lB,OAAAN,EACArlB,KAAA2lB,OAAAxY,IAAA,CAAyBxJ,MAAA,KACzB3D,KAAAsiB,KAAA9W,MAAAxL,KAAA2lB,OAAAf,QACA5kB,KAAAsiB,KAAAwO,QAAA,WAAkD0B,EAAO1B,UACzD9wB,KAAAif,QAAA,KAGAoG,YAAiB,OAAArlB,KAAA2lB,OACjBvjB,QAAA0C,EAAA4Z,GACA,QAAA7e,IAAAG,KAAAsiB,KAAAhC,MAAAxb,GACA,UAAAvB,SAA+BuB,kCAC/B9E,KAAAsiB,KAAAhC,MAAAxb,GAAA4Z,EAEAtc,KAAA+C,GAQA,MAPA,kBAAAA,EACAnF,KAAA0xB,QAAA,SAAAvsB,IAGAnF,KAAA0xB,QAAA,aACA1xB,KAAA0xB,QAAA,OAAAvsB,IAEAnF,KAEAoC,OAAA+C,EAAAwU,EAAAqG,EAAAC,GAcA,MAbA,kBAAA9a,EACAnF,KAAA0xB,QAAA,UAAAvsB,IAGAnF,KAAA0xB,QAAA,cACA1xB,KAAA0xB,QAAA,SAAAvsB,GACAwU,GACA3Z,KAAA0xB,QAAA,eAAA/X,GACAqG,GACAhgB,KAAA0xB,QAAA,kBAAA1R,GACAC,GACAjgB,KAAA0xB,QAAA,iBAAAzR,IAEAjgB,KAEAoC,IAAA+C,GAOA,OALAnF,KAAAsiB,KAAA2O,aADA,kBAAA9rB,EACA,GAGAA,EAEAnF,KAEAoC,KAAA6jB,EAAA5F,EAAAC,EAAAC,EAAA2F,GAgBA,MAfA,iBAAAD,GACAjmB,KAAAuf,MAAAxb,KAAAkiB,EACAC,IACAlmB,KAAAuf,MAAAa,KAAA8F,GACA7F,IACArgB,KAAAuf,MAAAc,UACAC,IACAtgB,KAAAuf,MAAAe,SACAC,IACAvgB,KAAAuf,MAAAgB,cACAvgB,KAAAsiB,KAAAsD,KAAA5lB,KAAAuf,MAAAlZ,OAGArG,KAAAuf,MAAA0G,EAEAjmB,KAEAoC,QAUA,OATApC,KAAAsiB,KAAAhC,MAAA,CACAb,QAAA,EAAAC,SAAA,EACA3I,KAAA,OAAAgJ,OAAA,OACA8S,eAAA,EACAC,kBAAA,QACAC,iBAAA,UAEA/yB,KAAAuf,MAAA,IAAyBC,EAAI,iBAC7Bxf,KAAAsiB,KAAAsD,KAAA5lB,KAAAuf,MAAAlZ,MACArG,KAEAoC,YAAAuvB,EAAAnmB,GAKA,OAJAxL,KAAAsiB,KAAA9W,QACAxL,KAAAsiB,KAAAwO,QAAAa,EACA3xB,KAAAsiB,KAAAyO,WAAA,EACA/wB,KAAA4xB,SACA5xB,KAAAsiB,KAEAlgB,MAAAgc,GACA,IAAAA,GAAA,MAAAA,EAAAxC,UACA,UAAArY,MAAA,8CACA,OAAAvD,KAAA6xB,YAAgCW,EAAOjC,QAAAnS,GAAApe,KAAAqlB,MAAAT,SAEvCxiB,SAGA,OAFApC,KAAAsiB,KAAAyO,aACA/wB,KAAAsiB,KAAA0O,aAAiChxB,KAAAsiB,KAAAwO,WAAqB9wB,KAAAsiB,KAAAyO,aACtD/wB,KAAAsiB,KAAA0O,UAEA5uB,aAAA0iB,GACA,OAAAA,EAAAkM,gBAAqCwB,EAAOV,UAE5C1vB,eAAAgc,GACA,cAAuBA,EAAAxC,YAEvBxZ,aAAAgf,EAAAwO,GACA,IAAA1rB,EAAA,GACA0rB,EAAA,QACA1rB,EAAAf,KAAA,cACAysB,EAAA,SACA1rB,EAAAf,KAAA,gBACA,QAAA2B,KAAA8qB,EACA,GAAAA,EAAAnR,eAAA3Z,IAAA,UAAAA,GAAA,WAAAA,EAAA,CACA,IAAA4Z,EAAAkR,EAAA9qB,GACA,GAAA4Z,EAAA,CACA,IAAAkR,EAAA,YAAA9qB,EAAA+jB,QAAA,QACA,SAEA,IAAA+G,EAAA,aAAA9qB,EAAA+jB,QAAA,UACA,SAGA3kB,EAAAf,QAAmC2B,MAAM4Z,MAKzC,OAAe8Q,EAAQuC,QAAA3Q,EAAA,CAAgBd,MAAApc,EAAA+T,KAAA,OAEvC7V,aAAA0iB,EAAArd,EAAAwH,EAAA,EAAA4Q,EAAA,UACA,iBAAAA,EACmB2S,EAAOjjB,OAAAuV,EAAArd,EAAAwH,GAGPujB,EAAOjL,OAAAzC,EAAArd,EAAAwH,GAG1B7M,MAAAqF,EAAAwH,EAAA,EAAA4Q,EAAA,UAGA,OAFA7f,KAAA4xB,SACQY,EAAOtS,MAAAlgB,KAAAsiB,KAAA7a,EAAAwH,EAAA4Q,GACf7f,KAEAoC,cAAA0iB,EAAArd,EAAAwH,EAAA,IACA,IAAAmS,EAAmBkR,EAAQC,WAAAzN,EAAAtZ,MAAA,SAAiCgnB,EAAOP,MAAAnN,IAQnE,OAPQ0K,EAAQuC,QAAA3Q,EAAA,CAChB4R,GAAAvrB,EAAA,GACAwnB,GAAAxnB,EAAA,GACAuH,EAAAC,EACAijB,gCAA+CpN,EAAAmM,iBAEvCuB,EAAOlS,MAAAc,EAAA0D,EAAAxE,OACfc,EAEAhf,OAAA0B,GAGA,OAFA9D,KAAA4xB,SACQY,EAAOjjB,OAAAvP,KAAAsiB,KAAAxe,EAAA,GAAAA,EAAA,OACf9D,KAEAoC,WAAA0iB,EAAArd,EAAAwH,EAAA6X,EAAAC,EAAAC,GACA,IAAA5F,EAAmBkR,EAAQC,WAAAzN,EAAAtZ,MAAA,OAA+BgnB,EAAOP,MAAAnN,IACjE,MAAAnhB,EAAA,IAA0B+B,EAAE+B,GAAA6B,QAAAwd,EAAA7X,GAAA,GAC5B+L,EAAA,IAAwBtV,EAAE+B,GAAA6B,QAAAyd,EAAA9X,GAAA,GAE1B,IAAAgkB,EADqBroB,EAAI0L,WAAAyQ,GAAwBnc,EAAI0L,WAAAwQ,GACtB7mB,EAAKsB,GACpCylB,IACAiM,MACA,MAAAC,EAAA,UACAztB,OAAuB9B,EAAA,MAAYA,EAAA,QAAcsL,KAAUA,OAAYgkB,EAAA,WAAwBC,KAASlY,EAAA,MAAUA,EAAA,KAMlH,OALQwU,EAAQuC,QAAA3Q,EAAA,CAChB3b,IACAysB,6BAA4CpN,EAAAmM,iBAEpCuB,EAAOlS,MAAAc,EAAA0D,EAAAxE,OACfc,EAEAhf,IAAAqF,EAAAwH,EAAA6X,EAAAC,EAAAC,GAGA,OAFAhnB,KAAA4xB,SACQY,EAAO3L,IAAA7mB,KAAAsiB,KAAA7a,EAAAwH,EAAA6X,EAAAC,EAAAC,GACfhnB,KAEAoC,cAAA0iB,EAAArd,EAAAwf,GACA,IAAA7F,EAAmBkR,EAAQC,WAAAzN,EAAAtZ,MAAA,OAA+BgnB,EAAOP,MAAAnN,IASjE,OARQ0K,EAAQuC,QAAA3Q,EAAA,CAChB1Z,EAAAD,EAAA,GAAAwf,EACAtf,EAAAF,EAAA,GAAAwf,EACAtN,MAAA,EAAAsN,EACAzZ,OAAA,EAAAyZ,EACAiL,gCAA+CpN,EAAAmM,iBAEvCuB,EAAOlS,MAAAc,EAAA0D,EAAAxE,OACfc,EAEAhf,OAAAqF,EAAAwf,GAGA,OAFAjnB,KAAA4xB,SACQY,EAAOjL,OAAAvnB,KAAAsiB,KAAA7a,EAAAwf,GACfjnB,KAEAoC,YAAA0iB,EAAAhhB,GACA,IAAA9D,KAAAoyB,WAAAtuB,GACA,OACA,GAAAA,EAAAtB,OAAA,EACA,OAAmBgwB,EAAOW,MAAArO,EAAAhhB,GAAA,GAC1B,IAAAsd,EAAmBkR,EAAQC,WAAAzN,EAAAtZ,MAAA,OAA+BgnB,EAAOP,MAAAnN,IASjE,OARQ0K,EAAQuC,QAAA3Q,EAAA,CAChB8F,GAAApjB,EAAA,MACA0G,GAAA1G,EAAA,MACAqjB,GAAArjB,EAAA,MACAsjB,GAAAtjB,EAAA,MACAouB,8BAA6CpN,EAAAmM,iBAErCuB,EAAOlS,MAAAc,EAAA0D,EAAAxE,OACfc,EAEAhf,KAAA0B,GAGA,OAFA9D,KAAA4xB,SACQY,EAAOhpB,KAAAxJ,KAAAsiB,KAAAxe,GACf9D,KAEAoC,aAAA0iB,EAAAhhB,EAAAuN,GAAA,GACA,IAAArR,KAAAoyB,WAAAtuB,GACA,OACA,IAAAsd,EAAmBkR,EAAQC,WAAAzN,EAAAtZ,MAAA,uBAA+DgnB,EAAOP,MAAAnN,IACjGsO,EAAAtvB,EAAAwD,OAAA,CAAAtE,EAAAC,IAAAD,KAAiDC,EAAA,MAAQA,EAAA,MAAK,IAM9D,OALQusB,EAAQuC,QAAA3Q,EAAA,CAChBgS,SACAlB,iCAAgDpN,EAAAmM,iBAExCuB,EAAOlS,MAAAc,EAAA0D,EAAAxE,OACfc,EAEAhf,eAAA0iB,EAAAhhB,GACA,OAAe0uB,EAAOW,MAAArO,EAAAhhB,GAAA,GAEtB1B,QAAA0B,GAGA,OAFA9D,KAAA4xB,SACQY,EAAOhL,QAAAxnB,KAAAsiB,KAAAxe,GACf9D,KAEAoC,YAAA0iB,EAAAhhB,GACA,IAAA9D,KAAAoyB,WAAAtuB,GACA,OACA,IAAAsd,EAAmBkR,EAAQC,WAAAzN,EAAAtZ,MAAA,OAA+BgnB,EAAOP,MAAAnN,IACjElK,EAAoBpW,EAAK6uB,UAAAvvB,GAAAoI,cACzBnI,EAAmBqI,EAASrI,KAAA6W,GAS5B,OARQ4U,EAAQuC,QAAA3Q,EAAA,CAChB1Z,EAAAkT,EAAA,MACAjT,EAAAiT,EAAA,MACAjB,MAAA5V,EAAA,GACAyJ,OAAAzJ,EAAA,GACAmuB,8BAA6CpN,EAAAmM,iBAErCuB,EAAOlS,MAAAc,EAAA0D,EAAAxE,OACfc,EAEAhf,KAAA0B,GAGA,OAFA9D,KAAA4xB,SACQY,EAAOxmB,KAAAhM,KAAAsiB,KAAAxe,GACf9D,KAEAoC,YAAA0iB,EAAArd,EAAAqgB,GACA,IAAA1G,EAAmBkR,EAAQC,WAAAzN,EAAAtZ,MAAA,OAA+BgnB,EAAOP,MAAAnN,IAUjE,OATQ0K,EAAQuC,QAAA3Q,EAAA,CAChBkS,iBAAA,OACA5rB,EAAAD,EAAA,GACAE,EAAAF,EAAA,GACAkiB,GAAA,EAAAC,GAAA,EACAsI,8BAA6CpN,EAAAmM,iBAE7C7P,EAAAiR,YAAAvK,EACQ0K,EAAOlS,MAAAc,EAAA0D,EAAAxE,OACfc,EAEAhf,KAAAqF,EAAAqgB,GAGA,OAFA9nB,KAAA4xB,SACQY,EAAOvK,KAAAjoB,KAAAsiB,KAAA7a,EAAAqgB,GACf9nB,KAEAoC,IAAA0lB,GAEA,OADA9nB,KAAA+W,KAAA,QAAAgJ,OAAA,WAAAkI,KAAA,QAAAH,GACA9nB,MAGAwyB,EAAO1B,QAAA,EACP0B,EAAOV,MAAA,ECnWA,MAAMyB,EACbnxB,YAAAwY,EAAA4Y,EAAA,EAAAxxB,EAAA,GAWA,OAVAhC,KAAAyzB,UAAA,KACAzzB,KAAA0zB,SAAA,IAA4BhuB,EAC5B1F,KAAA2zB,UAAA,EACA3zB,KAAA4zB,SAAA,IACA5zB,KAAA6zB,WAAA,GACA7zB,KAAA8zB,QAAA,GACA9zB,KAAA+zB,OAAA,CAAuB9wB,EAAA,GAAMyB,EAAA,IAC7B1E,KAAAg0B,OAAsB3a,EAAK4a,UAAArZ,GAC3B5a,KAAA2zB,UAAAH,EACAxzB,KAAA0zB,SAAA,iBAAA1xB,EAAA,IAA4D0D,EAAE,EAAA1D,GAAA,IAAmB0D,EAAE1D,GACnFhC,KAEAgC,cAAmB,OAAAhC,KAAA0zB,SACnB1xB,YAAAoC,GAAoBpE,KAAA0zB,SAAAtvB,EACpBovB,eAAoB,OAAAxzB,KAAA2zB,UACpBH,aAAAtkB,GAAqBlP,KAAA2zB,UAAAzkB,EACrBglB,cAAmB,OAAAl0B,KAAA4zB,SACnBM,YAAAhlB,GAAoBlP,KAAA4zB,SAAA1kB,EACpBilB,gBAAqB,OAAAn0B,KAAA8zB,QAAAtxB,OACrB4xB,oBAAyB,OAAAp0B,KAAA6zB,WAAArxB,OACzBJ,KAAA4U,GAAc,OAAAhX,KAAA8zB,QAAA,iBAAA9c,EAAAhX,KAAA+zB,OAAArvB,EAAAsS,MACd5U,SAAA4U,GAAkB,OAAAhX,KAAA6zB,WAAA,iBAAA7c,EAAAhX,KAAA+zB,OAAA9wB,EAAA+T,MAClB5U,OAAAiyB,GACA,IAAAvL,EAAAuL,EAAA,IACAr0B,KAAAs0B,iBAAAxL,GACA9oB,KAAAu0B,cAAAzL,GAEA1mB,cAAAgD,GACApF,KAAAw0B,eAAApvB,EAEAhD,WAAAgD,GACApF,KAAAy0B,YAAArvB,EAEAhD,IAAAa,EAAAmtB,GAWA,OAVAntB,aAAyByxB,GACzB10B,KAAA8zB,QAAA3wB,KAAAF,GACAmtB,IACApwB,KAAA+zB,OAAArvB,EAAA0rB,GAAApwB,KAAA8zB,QAAAtxB,OAAA,KAGAxC,KAAA6zB,WAAA1wB,KAAAF,GACAmtB,IACApwB,KAAA+zB,OAAA9wB,EAAAmtB,GAAApwB,KAAA6zB,WAAArxB,OAAA,IAEAxC,KAEAoC,OAAAyQ,EAAAzM,EAAAuS,EAAA,GACA,IAAAzP,EAAA9C,EAAA,MAAAA,EAAA,EAAAuS,GAAA,CAAAvS,EAAAuS,GAOA,MANA,QAAA9F,EACA7S,KAAA8zB,QAAApb,OAAAxP,EAAA,GAAAA,EAAA,IAGAlJ,KAAA6zB,WAAAnb,OAAAxP,EAAA,GAAAA,EAAA,IAEAlJ,KAEAoC,sBAAAkG,EAAAC,EAAAuK,EAAA6hB,EAAA,EAAAC,GAAA,GACA,MAAAC,EAAA,GAAAvsB,EAAAwsB,MAAA,GACAC,EAAA,GAAAxsB,EAAAusB,MAAA,GACAE,EAAAH,EAAAE,EACA,IAAAE,EAAA1sB,EAAAqB,UAAAtB,GACA4sB,EAAApiB,IACArN,EAAA,EAAAqN,EAAAmiB,EAAApvB,YAAA,EAAAqvB,GAAAD,EAAArvB,IAAAqvB,GAAAC,GAAA,GACAhmB,EAAA+lB,EAAAnuB,UAAArB,EAAAkvB,GAGA,OAFArsB,EAAAuD,SAAAqD,EAAApI,UAAA+tB,EAAAG,IACAzsB,EAAA4E,IAAA+B,EAAApI,UAAAiuB,EAAAC,IACA1sB,EAEAlG,uBAAAa,EAAA+I,EAAAkoB,EAAA,KACA,IAAAtZ,EAAA5O,EAAAE,cACA4d,EAAA7mB,EAAAmK,KAAAwN,EAAA,GAAA/O,SAAA5I,EAAAgM,SAAA5B,KAAAuN,EAAA,GAAAzN,IAAAlK,EAAAgM,SACA,GAAA6a,EAAA,KAAAlP,EAAA,OAAAkP,EAAA,KAAAlP,EAAA,OACA,IAAAzV,EAAAlC,EAAAkyB,QAAAruB,UAAAotB,GACAjxB,EAAAmyB,SAAAtL,EAAAlgB,UAAA,IAA0ClE,GAAEP,EAAA,GAAAA,EAAA,UAE5C,GAAA2kB,EAAA,KAAAlP,EAAA,OAAAkP,EAAA,KAAAlP,EAAA,OACA,IAAAzV,EAAAlC,EAAAkyB,QAAAruB,UAAAotB,GACAjxB,EAAAmyB,SAAAtL,EAAAlgB,UAAA,IAA0ClE,EAAEP,EAAA,IAAAA,EAAA,KAE5ClC,EAAA0G,GAAAmgB,GAEA1nB,UAAAa,EAAA6lB,EAAAuM,GAGA,OAFApyB,EAAAqyB,SAAAt1B,KAAA0zB,UACAzwB,EAAAsyB,OAAAzM,EAAA9oB,KAAA2zB,UAAA0B,GACApyB,EAEAb,iBAAA0mB,GACA,QAAA5lB,EAAA,EAAA2B,EAAA7E,KAAA6zB,WAAArxB,OAAqDU,EAAA2B,EAAS3B,IAAA,CAC9D,IAAAD,EAAAjD,KAAA6zB,WAAA3wB,GACAlD,KAAAw1B,UAAAvyB,EAAA6lB,EAAA9oB,KAAAyzB,WACYF,EAAKkC,gBAAAxyB,EAAAjD,KAAAg0B,OAAAh0B,KAAA4zB,UACjB,QAAA9uB,EAAA5B,EAAA,EAA+B4B,EAAAD,EAASC,IACxC,GAAA5B,IAAA4B,EAAA,CACA,IAAAyD,EAAAvI,KAAA6zB,WAAA/uB,GACA7B,EAAAyyB,QAAAntB,EAAAvI,KAAA4zB,UAGA5zB,KAAAw0B,gBACAx0B,KAAAw0B,eAAAvxB,EAAAC,GAEAlD,KAAAyzB,UAAA3K,EAEA1mB,cAAA0mB,GACA,QAAA5lB,EAAA,EAAA2B,EAAA7E,KAAA8zB,QAAAtxB,OAAkDU,EAAA2B,EAAS3B,IAAA,CAC3D,IAAAwB,EAAA1E,KAAA8zB,QAAA5wB,GACA,QAAA4B,EAAA,EAAA6wB,EAAAjxB,EAAAlC,OAA4CsC,EAAA6wB,EAAU7wB,IAAA,CACtD,IAAA8wB,EAAAlxB,EAAAI,GACgByuB,EAAKkC,gBAAAG,EAAA51B,KAAAg0B,OAAAh0B,KAAA4zB,UACrB5zB,KAAAw1B,UAAAI,EAAA9M,EAAA9oB,KAAAyzB,WAEA,QAAA3uB,EAAA5B,EAAA,EAA+B4B,EAAAD,EAASC,IACxCJ,EAAAmxB,YAAA71B,KAAA8zB,QAAAhvB,IAEA,QAAAgB,EAAA,EAAAgwB,EAAA91B,KAAA6zB,WAAArxB,OAA0DsD,EAAAgwB,EAAUhwB,IACpEpB,EAAAqxB,gBAAA/1B,KAAA6zB,WAAA/tB,IAEApB,EAAAsxB,eACAh2B,KAAAy0B,aACAz0B,KAAAy0B,YAAA/vB,EAAAxB,KAIO,MAAM+yB,UAAiBvwB,EAC9BtD,eAAAG,GACAoU,SAAApU,GACAvC,KAAAk2B,MAAA,EACAl2B,KAAAm2B,QAAA,EACAn2B,KAAAo2B,OAAA,IAA0B1wB,EAC1B1F,KAAAq2B,MAAA,IAAyB3wB,EACzB1F,KAAAs2B,OAAA,EACAt2B,KAAAq2B,MAAAr2B,KAAA+P,QAEA+kB,WAAgB,OAAA90B,KAAAk2B,MAChBpB,SAAAhvB,GAAiB9F,KAAAk2B,MAAApwB,EACjBmJ,aAAkB,OAAAjP,KAAAm2B,QAClBlnB,WAAAC,GAAmBlP,KAAAm2B,QAAAjnB,EACnBkmB,eAAoB,OAAAp1B,KAAAq2B,MACpBjB,aAAAnyB,GAAqBjD,KAAAq2B,MAAApzB,EACrBszB,YAAiB,OAAAv2B,KAAAo2B,OACjBG,UAAAnyB,GAAkBpE,KAAAo2B,OAAAhyB,EAClBge,WAAgB,OAAApiB,KAAAw2B,MAChBpU,SAAA1d,GAAiB1E,KAAAw2B,MAAA9xB,EACjB+xB,WAAgB,OAAAz2B,KAAAs2B,MAChBG,SAAA/xB,GACA1E,KAAAs2B,MAAA5xB,EACA1E,KAAA02B,QAAA,IAA2BhxB,EAAE1F,MAE7Bm1B,cAAmB,OAAAn1B,KAAA4J,UAAA5J,KAAAq2B,OACnB9E,aAAAtuB,GACAjD,KAAAo1B,SAAAzrB,GAAA3J,MACAA,KAAAs2B,QACAt2B,KAAA02B,QAAAzzB,GACAjD,KAAA2J,GAAA1G,GAEAb,KAAA4M,GAGA,OAFAhP,KAAAk2B,MAAAlnB,EACAhP,KAAAm2B,QAAAnnB,EACAhP,KAEAoC,YAAAG,GAEA,OADAvC,KAAAo2B,OAAAjpB,OAAA5K,GACAvC,KAAAo2B,OAEAh0B,OAAA0mB,EAAA0K,EAAAmD,GACA,GAAA32B,KAAAs2B,MACAt2B,KAAA2J,GAAA3J,KAAA02B,aAEA,CACA,IAAAE,EAAA,GAAA9N,EACA9lB,EAAAhD,KAAAo2B,OAAAvpB,SAAAic,KAAA8N,GAAA,GACAlY,EAAA1e,KAAAm1B,QAAAtoB,SAAA2mB,EAAA1K,EAAA8N,GAAAzpB,IAAAnK,GACAhD,KAAAq2B,MAAAr2B,KAAA+P,QACA/P,KAAAmN,IAAAuR,GACA1e,KAAAo2B,OAAA,IAA8B1wB,EAE9B,OAAA1F,KAEAoC,OAAAG,GAEA,OADAvC,KAAAq2B,MAAAxqB,SAAA,IAAgCnG,KAAEnD,GAAAmnB,QAAAloB,KAAAmE,KAAA3F,KAAAk2B,SAClCl2B,KAEAoC,QAAAmG,EAAAsuB,EAAA,GACA,IAAAvuB,EAAAtI,KACA82B,EAAAxuB,EAAAsB,UAAArB,GACA2sB,EAAA4B,EAAA/sB,cACA2F,EAAApH,EAAA2G,OAAA1G,EAAA0G,OACA,GAAAimB,EAAAxlB,IAAA,CACA,IAAA+D,EAAAnL,EAAA6sB,QACAzhB,EAAAnL,EAAA4sB,QACAriB,EAAAtR,KAAAmE,KAAAuvB,GACAzvB,EAAAqxB,EAAAhwB,WAAAgM,EAAApD,GAAAoD,EAAA,GACAikB,EAAAzuB,EAAAsB,UAAAnE,GACAuxB,EAAAzuB,EAAA9B,KAAAhB,GACA6C,EAAAqB,GAAAotB,GACAxuB,EAAAoB,GAAAqtB,GACA,IAAAC,EAAAJ,EAAAC,EAAAlxB,IAAA6N,GAAAyhB,EACAgC,EAAAL,EAAAC,EAAAlxB,IAAA8N,GAAAwhB,EACAiC,EAAA7uB,EAAAwsB,MAAAxsB,EAAAwsB,KAAAvsB,EAAAusB,MACAsC,EAAA7uB,EAAAusB,MAAAxsB,EAAAwsB,KAAAvsB,EAAAusB,MACArhB,EAAAtG,IAAA,IAAuBzH,EAAEwxB,EAAAJ,EAAA,GAAAG,EAAAH,EAAA,GAAAI,EAAAJ,EAAA,GAAAG,EAAAH,EAAA,IAAAhwB,UAAAswB,IACzB1jB,EAAAvG,IAAA,IAAuBzH,EAAEuxB,EAAAH,EAAA,GAAAI,EAAAJ,EAAA,GAAAG,EAAAH,EAAA,GAAAI,EAAAJ,EAAA,IAAAhwB,UAAAqwB,IACzB7uB,EAAA8sB,SAAA9sB,EAAAsB,UAAA6J,GACAlL,EAAA6sB,SAAA7sB,EAAAqB,UAAA8J,IAGAtR,WACA,mBAA4BpC,KAAA,MAAWA,KAAA,iBAAsBA,KAAAq2B,MAAA,MAAiBr2B,KAAAq2B,MAAA,aAAwBr2B,KAAAk2B,SAG/F,MAAMxB,UAAalwB,EAC1BpC,cACAuU,QACA3W,KAAAq3B,IAAA,GACAr3B,KAAAs3B,OAAA,EACAt3B,KAAAu3B,OAAA,GACAv3B,KAAAk2B,MAAA,EAEA9zB,iBAAAmW,EAAAoc,EAAA,EAAA6C,GAAA,EAAAC,GAAA,GACA,IAAA/yB,GAAA,IAAoBgwB,GAAIhb,KAAAnB,GAKxB,OAJAif,GACA9yB,EAAAgzB,QAAA/C,GACA8C,GACA/yB,EAAA+yB,WACA/yB,EAEAtC,KAAAmW,EAAAoc,EAAA,GACA,IAAAxvB,EAAA,IAAoBO,EACpB,QAAAxC,EAAA,EAAA2B,EAAA0T,EAAA/V,OAA0CU,EAAA2B,EAAS3B,IAAA,CACnD,IAAAD,EAAA,IAAwBgzB,EAAQ1d,EAAArV,IAChCD,EAAAmf,KAAApiB,KACAmF,EAAAgI,IAAAoL,EAAArV,IACAlD,KAAAmD,KAAAF,GAGA,OADAjD,KAAAs3B,OAAA3C,EACA30B,KAEA80B,WAAgB,OAAA90B,KAAAk2B,MAChBpB,SAAAhvB,GACA9F,KAAAk2B,MAAApwB,EACA,QAAA5C,EAAA,EAAA2B,EAAA7E,KAAAwC,OAA0CU,EAAA2B,EAAS3B,IACnDlD,KAAAkD,GAAA4xB,KAAA90B,KAAAk2B,MAGA9zB,WAEA,OADApC,KAAA80B,KAAAtzB,KAAAmE,KAA8B2K,EAAOO,KAAA7Q,OAAA,GACrCA,KAEAoC,KAAAu1B,EAAAC,EAAAjD,GACA,GAAAgD,EAAA,GAAAA,GAAA33B,KAAAwC,OACA,UAAAe,MAAA,wCACA,GAAAq0B,EAAA,GAAAA,GAAA53B,KAAAwC,OACA,UAAAe,MAAA,wCACA,IAAAkC,EAAAzF,KAAA23B,GAAA/tB,UAAA5J,KAAA43B,IAAA/xB,YAEA,OADA7F,KAAAq3B,IAAAl0B,KAAA,CAAAw0B,EAAAC,EAAAnyB,EAAAkvB,GAAA30B,KAAAs3B,SACAt3B,KAEAoC,QAAAuyB,GACA,IAAAhnB,EAAA3N,KAAAwC,OAAA,EACA,QAAAU,EAAA,EAAA2B,EAAA7E,KAAAwC,OAA0CU,EAAA2B,EAAS3B,IAAA,CACnD,IAAAoP,EAAApP,GAAA2B,EAAA,IAAA3B,EAAA,EAEA,GADAlD,KAAA63B,KAAA30B,EAAAoP,EAAAqiB,GACA9vB,EAAA,GACA,IAAAizB,EAAAt2B,KAAAoC,MAAA+J,EAAA,KACAoqB,EAAA70B,GAAA2B,EAAAizB,EAAA50B,EAAA2B,EAAA3B,EAAA40B,EACA93B,KAAA63B,KAAA30B,EAAA60B,EAAApD,GAEAzxB,GAAAyK,EAAA,GACA3N,KAAA63B,KAAA30B,EAAA1B,KAAAH,IAAArB,KAAAwC,OAAA,EAAAU,EAAA1B,KAAAoC,MAAA+J,MAIAvL,eACA,IAAAqP,EAAA,GACA,QAAAvO,EAAA,EAAA2B,EAAA7E,KAAAq3B,IAAA70B,OAA8CU,EAAA2B,EAAS3B,IAAA,CACvD,IAAAwP,EAAA1S,KAAAq3B,IAAAn0B,GACAuO,EAAAtO,KAAA,IAAwBqB,EAAKxE,KAAA0S,EAAA,IAAA1S,KAAA0S,EAAA,MAE7B,OAAAjB,EAEArP,eACA,QAAAc,EAAA,EAAA2B,EAAA7E,KAAAq3B,IAAA70B,OAA8CU,EAAA2B,EAAS3B,IAAA,CACvD,IAAA4C,EAAAwM,EAAA7M,EAAAa,GAAAtG,KAAAq3B,IAAAn0B,GACYqwB,EAAKyE,eAAAh4B,KAAA8F,GAAA9F,KAAAsS,GAAA7M,EAAAa,IAGjBlE,YAAAsC,GACA,IACA8O,EAAA9O,EACAuzB,EAAkB3nB,EAAO4nB,oBAFzBl4B,KAEyBwT,GACzB,GAAAykB,EAAA,CACA,IACArsB,EADAusB,EAAAF,EAAAllB,OAAAjM,UAAAmxB,EAAAnlB,MAEAslB,EAAAH,EAAAjlB,KAOAqlB,EAAA,IALAzsB,EADApK,KAAAyE,IAAAmyB,EAAA,MAAAA,EAAA,OAAA52B,KAAAyE,IAAAmyB,EAAA,MAAAA,EAAA,QACAH,EAAAhlB,OAAA,GAAAklB,EAAA,GAAAC,EAAA,QAAAA,EAAA,MAAAA,EAAA,QAGAH,EAAAhlB,OAAA,GAAAklB,EAAA,GAAAC,EAAA,QAAAA,EAAA,MAAAA,EAAA,QAEAxsB,GAAA,EAAAA,IAAA,EAAAA,IACA0sB,EAAAL,EAAAhlB,OAAAmP,KAAA0S,MAAA,EACAD,EAAAoD,EAAAjlB,KAAA,GAAAoP,KAAA0S,MAAA,EACAyD,EAAAD,KAAAzD,GACA2D,EAAA3D,GAAAyD,EAAAzD,GACAuD,EAAA,GAAAvsB,SAAAssB,EAAArxB,UAAAyxB,GAAA,EAAA3sB,GAAAysB,EAAA,IACAD,EAAA,GAAAvsB,SAAAssB,EAAArxB,UAAAyxB,EAAA3sB,EAAAysB,EAAA,IACAJ,EAAAhlB,OAAA9F,IAAAgrB,EAAArxB,UAAA0xB,KAGAp2B,gBAAAsC,GACA,IACA8O,EAAA9O,EACAuzB,EAAkB3nB,EAAOmoB,mBAFzBz4B,KAEiD6N,EAAMf,WAAApI,IAAAuK,SACvD,GAAAgpB,EAAA,CACA,IACArsB,EADAusB,EAAAF,EAAAllB,OAAAjM,UAAAmxB,EAAAnlB,MAEAslB,EAAAH,EAAAjlB,KAOAqlB,EAAA,IALAzsB,EADApK,KAAAyE,IAAAmyB,EAAA,MAAAA,EAAA,OAAA52B,KAAAyE,IAAAmyB,EAAA,MAAAA,EAAA,QACAH,EAAAhlB,OAAA,GAAAklB,EAAA,GAAAC,EAAA,QAAAA,EAAA,MAAAA,EAAA,QAGAH,EAAAhlB,OAAA,GAAAklB,EAAA,GAAAC,EAAA,QAAAA,EAAA,MAAAA,EAAA,QAEAxsB,GAAA,EAAAA,IAAA,EAAAA,IACA0sB,EAAAL,EAAAhlB,OAAA6hB,MAAAthB,EAAAshB,MAAA,EACAD,EAAAoD,EAAAjlB,KAAA,GAAAoP,KAAA0S,MAAA,EACAyD,EAAAD,KAAAzD,GACA2D,EAAA3D,GAAAyD,EAAAzD,GACAuD,EAAA,GAAAvsB,SAAAssB,EAAArxB,UAAAyxB,GAAA,EAAA3sB,GAAAysB,EAAA,IACAD,EAAA,GAAAvsB,SAAAssB,EAAArxB,UAAAyxB,EAAA3sB,EAAAysB,EAAA,IACA,IAAA5kB,EAAA/O,EAAAywB,QAAAhoB,IAAAgrB,EAAArxB,UAAA0xB,IACA9zB,EAAA0wB,SAAA1wB,EAAAkF,UAAA6J,KC/UArU,EAAAqG,EAAAizB,EAAA,sBAAAvX,IAAA/hB,EAAAqG,EAAAizB,EAAA,sBAAArP,IAAAjqB,EAAAqG,EAAAizB,EAAA,sBAAA/pB,IAAAvP,EAAAqG,EAAAizB,EAAA,sBAAAhzB,IAAAtG,EAAAqG,EAAAizB,EAAA,sBAAAnF,IAAAn0B,EAAAqG,EAAAizB,EAAA,sBAAAzC","file":"17-af2deb64eeef1c674c95.js","sourcesContent":["'use strict';\nvar $export = require('./_export');\nvar aFunction = require('./_a-function');\nvar toObject = require('./_to-object');\nvar fails = require('./_fails');\nvar $sort = [].sort;\nvar test = [1, 2, 3];\n\n$export($export.P + $export.F * (fails(function () {\n  // IE8-\n  test.sort(undefined);\n}) || !fails(function () {\n  // V8 bug\n  test.sort(null);\n  // Old WebKit\n}) || !require('./_strict-method')($sort)), 'Array', {\n  // 22.1.3.25 Array.prototype.sort(comparefn)\n  sort: function sort(comparefn) {\n    return comparefn === undefined\n      ? $sort.call(toObject(this))\n      : $sort.call(toObject(this), aFunction(comparefn));\n  }\n});\n","import { Group } from \"./Pt\";\nexport const Const = {\n    xy: \"xy\",\n    yz: \"yz\",\n    xz: \"xz\",\n    xyz: \"xyz\",\n    horizontal: 0,\n    vertical: 1,\n    identical: 0,\n    right: 4,\n    bottom_right: 5,\n    bottom: 6,\n    bottom_left: 7,\n    left: 8,\n    top_left: 1,\n    top: 2,\n    top_right: 3,\n    epsilon: 0.0001,\n    max: Number.MAX_VALUE,\n    min: Number.MIN_VALUE,\n    pi: Math.PI,\n    two_pi: 6.283185307179586,\n    half_pi: 1.5707963267948966,\n    quarter_pi: 0.7853981633974483,\n    one_degree: 0.017453292519943295,\n    rad_to_deg: 57.29577951308232,\n    deg_to_rad: 0.017453292519943295,\n    gravity: 9.81,\n    newton: 0.10197,\n    gaussian: 0.3989422804014327\n};\nexport class Util {\n    static warnLevel(lv) {\n        if (lv) {\n            Util._warnLevel = lv;\n        }\n        return Util._warnLevel;\n    }\n    static getArgs(args) {\n        if (args.length < 1)\n            return [];\n        let pos = [];\n        let isArray = Array.isArray(args[0]) || ArrayBuffer.isView(args[0]);\n        if (typeof args[0] === 'number') {\n            pos = Array.prototype.slice.call(args);\n        }\n        else if (typeof args[0] === 'object' && !isArray) {\n            let a = [\"x\", \"y\", \"z\", \"w\"];\n            let p = args[0];\n            for (let i = 0; i < a.length; i++) {\n                if ((p.length && i >= p.length) || !(a[i] in p))\n                    break;\n                pos.push(p[a[i]]);\n            }\n        }\n        else if (isArray) {\n            pos = [].slice.call(args[0]);\n        }\n        return pos;\n    }\n    static warn(message = \"error\", defaultReturn = undefined) {\n        if (Util.warnLevel() == \"error\") {\n            throw new Error(message);\n        }\n        else if (Util.warnLevel() == \"warn\") {\n            console.warn(message);\n        }\n        return defaultReturn;\n    }\n    static randomInt(range, start = 0) {\n        return Math.floor(Math.random() * range) + start;\n    }\n    static split(pts, size, stride, loopBack = false) {\n        let st = stride || size;\n        let chunks = [];\n        for (let i = 0; i < pts.length; i++) {\n            if (i * st + size > pts.length) {\n                if (loopBack) {\n                    let g = pts.slice(i * st);\n                    g = g.concat(pts.slice(0, (i * st + size) % size));\n                    chunks.push(g);\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                chunks.push(pts.slice(i * st, i * st + size));\n            }\n        }\n        return chunks;\n    }\n    static flatten(pts, flattenAsGroup = true) {\n        let arr = (flattenAsGroup) ? new Group() : new Array();\n        return arr.concat.apply(arr, pts);\n    }\n    static combine(a, b, op) {\n        let result = [];\n        for (let i = 0, len = a.length; i < len; i++) {\n            for (let k = 0, lenB = b.length; k < lenB; k++) {\n                result.push(op(a[i], b[k]));\n            }\n        }\n        return result;\n    }\n    static zip(arrays) {\n        let z = [];\n        for (let i = 0, len = arrays[0].length; i < len; i++) {\n            let p = [];\n            for (let k = 0; k < arrays.length; k++) {\n                p.push(arrays[k][i]);\n            }\n            z.push(p);\n        }\n        return z;\n    }\n    static stepper(max, min = 0, stride = 1, callback) {\n        let c = min;\n        return function () {\n            c += stride;\n            if (c >= max) {\n                c = min + (c - max);\n            }\n            if (callback)\n                callback(c);\n            return c;\n        };\n    }\n    static forRange(fn, range, start = 0, step = 1) {\n        let temp = [];\n        for (let i = start, len = range; i < len; i += step) {\n            temp[i] = fn(i);\n        }\n        return temp;\n    }\n}\nUtil._warnLevel = \"mute\";\n//# sourceMappingURL=Util.js.map","import { Pt, Group } from \"./Pt\";\nimport { Line } from \"./Op\";\nexport class Vec {\n    static add(a, b) {\n        if (typeof b == \"number\") {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] += b;\n        }\n        else {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] += b[i] || 0;\n        }\n        return a;\n    }\n    static subtract(a, b) {\n        if (typeof b == \"number\") {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] -= b;\n        }\n        else {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] -= b[i] || 0;\n        }\n        return a;\n    }\n    static multiply(a, b) {\n        if (typeof b == \"number\") {\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] *= b;\n        }\n        else {\n            if (a.length != b.length) {\n                throw new Error(`Cannot do element-wise multiply since the array lengths don't match: ${a.toString()} multiply-with ${b.toString()}`);\n            }\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] *= b[i];\n        }\n        return a;\n    }\n    static divide(a, b) {\n        if (typeof b == \"number\") {\n            if (b === 0)\n                throw new Error(\"Cannot divide by zero\");\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] /= b;\n        }\n        else {\n            if (a.length != b.length) {\n                throw new Error(`Cannot do element-wise divide since the array lengths don't match. ${a.toString()} divide-by ${b.toString()}`);\n            }\n            for (let i = 0, len = a.length; i < len; i++)\n                a[i] /= b[i];\n        }\n        return a;\n    }\n    static dot(a, b) {\n        if (a.length != b.length)\n            throw new Error(\"Array lengths don't match\");\n        let d = 0;\n        for (let i = 0, len = a.length; i < len; i++) {\n            d += a[i] * b[i];\n        }\n        return d;\n    }\n    static cross2D(a, b) {\n        return a[0] * b[1] - a[1] * b[0];\n    }\n    static cross(a, b) {\n        return new Pt((a[1] * b[2] - a[2] * b[1]), (a[2] * b[0] - a[0] * b[2]), (a[0] * b[1] - a[1] * b[0]));\n    }\n    static magnitude(a) {\n        return Math.sqrt(Vec.dot(a, a));\n    }\n    static unit(a, magnitude = undefined) {\n        let m = (magnitude === undefined) ? Vec.magnitude(a) : magnitude;\n        if (m === 0)\n            throw new Error(\"Cannot calculate unit vector because magnitude is 0\");\n        return Vec.divide(a, m);\n    }\n    static abs(a) {\n        return Vec.map(a, Math.abs);\n    }\n    static floor(a) {\n        return Vec.map(a, Math.floor);\n    }\n    static ceil(a) {\n        return Vec.map(a, Math.ceil);\n    }\n    static round(a) {\n        return Vec.map(a, Math.round);\n    }\n    static max(a) {\n        let m = Number.MIN_VALUE;\n        let index = 0;\n        for (let i = 0, len = a.length; i < len; i++) {\n            m = Math.max(m, a[i]);\n            if (m === a[i])\n                index = i;\n        }\n        return { value: m, index: index };\n    }\n    static min(a) {\n        let m = Number.MAX_VALUE;\n        let index = 0;\n        for (let i = 0, len = a.length; i < len; i++) {\n            m = Math.min(m, a[i]);\n            if (m === a[i])\n                index = i;\n        }\n        return { value: m, index: index };\n    }\n    static sum(a) {\n        let s = 0;\n        for (let i = 0, len = a.length; i < len; i++)\n            s += a[i];\n        return s;\n    }\n    static map(a, fn) {\n        for (let i = 0, len = a.length; i < len; i++) {\n            a[i] = fn(a[i], i, a);\n        }\n        return a;\n    }\n}\nexport class Mat {\n    static add(a, b) {\n        if (typeof b != \"number\") {\n            if (a[0].length != b[0].length)\n                throw new Error(\"Cannot add matrix if rows' and columns' size don't match.\");\n            if (a.length != b.length)\n                throw new Error(\"Cannot add matrix if rows' and columns' size don't match.\");\n        }\n        let g = new Group();\n        let isNum = typeof b == \"number\";\n        for (let i = 0, len = a.length; i < len; i++) {\n            g.push(a[i].$add((isNum) ? b : b[i]));\n        }\n        return g;\n    }\n    static multiply(a, b, transposed = false, elementwise = false) {\n        let g = new Group();\n        if (typeof b != \"number\") {\n            if (elementwise) {\n                if (a.length != b.length)\n                    throw new Error(\"Cannot multiply matrix element-wise because the matrices' sizes don't match.\");\n                for (let ai = 0, alen = a.length; ai < alen; ai++) {\n                    g.push(a[ai].$multiply(b[ai]));\n                }\n            }\n            else {\n                if (!transposed && a[0].length != b.length)\n                    throw new Error(\"Cannot multiply matrix if rows in matrix-a don't match columns in matrix-b.\");\n                if (transposed && a[0].length != b[0].length)\n                    throw new Error(\"Cannot multiply matrix if transposed and the columns in both matrices don't match.\");\n                if (!transposed)\n                    b = Mat.transpose(b);\n                for (let ai = 0, alen = a.length; ai < alen; ai++) {\n                    let p = Pt.make(b.length, 0);\n                    for (let bi = 0, blen = b.length; bi < blen; bi++) {\n                        p[bi] = Vec.dot(a[ai], b[bi]);\n                    }\n                    g.push(p);\n                }\n            }\n        }\n        else {\n            for (let ai = 0, alen = a.length; ai < alen; ai++) {\n                g.push(a[ai].$multiply(b));\n            }\n        }\n        return g;\n    }\n    static zipSlice(g, index, defaultValue = false) {\n        let z = [];\n        for (let i = 0, len = g.length; i < len; i++) {\n            if (g[i].length - 1 < index && defaultValue === false)\n                throw `Index ${index} is out of bounds`;\n            z.push(g[i][index] || defaultValue);\n        }\n        return new Pt(z);\n    }\n    static zip(g, defaultValue = false, useLongest = false) {\n        let ps = new Group();\n        let len = (useLongest) ? g.reduce((a, b) => Math.max(a, b.length), 0) : g[0].length;\n        for (let i = 0; i < len; i++) {\n            ps.push(Mat.zipSlice(g, i, defaultValue));\n        }\n        return ps;\n    }\n    static transpose(g, defaultValue = false, useLongest = false) {\n        return Mat.zip(g, defaultValue, useLongest);\n    }\n    static transform2D(pt, m) {\n        let x = pt[0] * m[0][0] + pt[1] * m[1][0] + m[2][0];\n        let y = pt[0] * m[0][1] + pt[1] * m[1][1] + m[2][1];\n        return new Pt(x, y);\n    }\n    static scale2DMatrix(x, y) {\n        return new Group(new Pt(x, 0, 0), new Pt(0, y, 0), new Pt(0, 0, 1));\n    }\n    static rotate2DMatrix(cosA, sinA) {\n        return new Group(new Pt(cosA, sinA, 0), new Pt(-sinA, cosA, 0), new Pt(0, 0, 1));\n    }\n    static shear2DMatrix(tanX, tanY) {\n        return new Group(new Pt(1, tanX, 0), new Pt(tanY, 1, 0), new Pt(0, 0, 1));\n    }\n    static translate2DMatrix(x, y) {\n        return new Group(new Pt(1, 0, 0), new Pt(0, 1, 0), new Pt(x, y, 1));\n    }\n    static scaleAt2DMatrix(sx, sy, at) {\n        let m = Mat.scale2DMatrix(sx, sy);\n        m[2][0] = -at[0] * sx + at[0];\n        m[2][1] = -at[1] * sy + at[1];\n        return m;\n    }\n    static rotateAt2DMatrix(cosA, sinA, at) {\n        let m = Mat.rotate2DMatrix(cosA, sinA);\n        m[2][0] = at[0] * (1 - cosA) + at[1] * sinA;\n        m[2][1] = at[1] * (1 - cosA) - at[0] * sinA;\n        return m;\n    }\n    static shearAt2DMatrix(tanX, tanY, at) {\n        let m = Mat.shear2DMatrix(tanX, tanY);\n        m[2][0] = -at[1] * tanY;\n        m[2][1] = -at[0] * tanX;\n        return m;\n    }\n    static reflectAt2DMatrix(p1, p2) {\n        let intercept = Line.intercept(p1, p2);\n        if (intercept == undefined) {\n            return [\n                new Pt([-1, 0, 0]),\n                new Pt([0, 1, 0]),\n                new Pt([p1[0] + p2[0], 0, 1])\n            ];\n        }\n        else {\n            let yi = intercept.yi;\n            let ang2 = Math.atan(intercept.slope) * 2;\n            let cosA = Math.cos(ang2);\n            let sinA = Math.sin(ang2);\n            return [\n                new Pt([cosA, sinA, 0]),\n                new Pt([sinA, -cosA, 0]),\n                new Pt([-yi * sinA, yi + yi * cosA, 1])\n            ];\n        }\n    }\n}\n//# sourceMappingURL=LinearAlgebra.js.map","import { Util } from \"./Util\";\nimport { Geom, Num } from \"./Num\";\nimport { Pt, Group } from \"./Pt\";\nimport { Mat } from \"./LinearAlgebra\";\nlet _errorLength = (obj, param = \"expected\") => Util.warn(\"Group's length is less than \" + param, obj);\nlet _errorOutofBound = (obj, param = \"\") => Util.warn(`Index ${param} is out of bound in Group`, obj);\nexport class Line {\n    static fromAngle(anchor, angle, magnitude) {\n        let g = new Group(new Pt(anchor), new Pt(anchor));\n        g[1].toAngle(angle, magnitude, true);\n        return g;\n    }\n    static slope(p1, p2) {\n        return (p2[0] - p1[0] === 0) ? undefined : (p2[1] - p1[1]) / (p2[0] - p1[0]);\n    }\n    static intercept(p1, p2) {\n        if (p2[0] - p1[0] === 0) {\n            return undefined;\n        }\n        else {\n            let m = (p2[1] - p1[1]) / (p2[0] - p1[0]);\n            let c = p1[1] - m * p1[0];\n            return { slope: m, yi: c, xi: (m === 0) ? undefined : -c / m };\n        }\n    }\n    static sideOfPt2D(line, pt) {\n        return (line[1][0] - line[0][0]) * (pt[1] - line[0][1]) - (pt[0] - line[0][0]) * (line[1][1] - line[0][1]);\n    }\n    static collinear(p1, p2, p3, threshold = 0.01) {\n        let a = new Pt(0, 0, 0).to(p1).$subtract(p2);\n        let b = new Pt(0, 0, 0).to(p1).$subtract(p3);\n        return a.$cross(b).divide(1000).equals(new Pt(0, 0, 0), threshold);\n    }\n    static magnitude(line) {\n        return (line.length >= 2) ? line[1].$subtract(line[0]).magnitude() : 0;\n    }\n    static magnitudeSq(line) {\n        return (line.length >= 2) ? line[1].$subtract(line[0]).magnitudeSq() : 0;\n    }\n    static perpendicularFromPt(line, pt, asProjection = false) {\n        if (line[0].equals(line[1]))\n            return undefined;\n        let a = line[0].$subtract(line[1]);\n        let b = line[1].$subtract(pt);\n        let proj = b.$subtract(a.$project(b));\n        return (asProjection) ? proj : proj.$add(pt);\n    }\n    static distanceFromPt(line, pt) {\n        return Line.perpendicularFromPt(line, pt, true).magnitude();\n    }\n    static intersectRay2D(la, lb) {\n        let a = Line.intercept(la[0], la[1]);\n        let b = Line.intercept(lb[0], lb[1]);\n        let pa = la[0];\n        let pb = lb[0];\n        if (a == undefined) {\n            if (b == undefined)\n                return undefined;\n            let y1 = -b.slope * (pb[0] - pa[0]) + pb[1];\n            return new Pt(pa[0], y1);\n        }\n        else {\n            if (b == undefined) {\n                let y1 = -a.slope * (pa[0] - pb[0]) + pa[1];\n                return new Pt(pb[0], y1);\n            }\n            else if (b.slope != a.slope) {\n                let px = (a.slope * pa[0] - b.slope * pb[0] + pb[1] - pa[1]) / (a.slope - b.slope);\n                let py = a.slope * (px - pa[0]) + pa[1];\n                return new Pt(px, py);\n            }\n            else {\n                if (a.yi == b.yi) {\n                    return new Pt(pa[0], pa[1]);\n                }\n                else {\n                    return undefined;\n                }\n            }\n        }\n    }\n    static intersectLine2D(la, lb) {\n        let pt = Line.intersectRay2D(la, lb);\n        return (pt && Geom.withinBound(pt, la[0], la[1]) && Geom.withinBound(pt, lb[0], lb[1])) ? pt : undefined;\n    }\n    static intersectLineWithRay2D(line, ray) {\n        let pt = Line.intersectRay2D(line, ray);\n        return (pt && Geom.withinBound(pt, line[0], line[1])) ? pt : undefined;\n    }\n    static intersectPolygon2D(lineOrRay, poly, sourceIsRay = false) {\n        let fn = sourceIsRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n        let pts = new Group();\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let next = (i === len - 1) ? 0 : i + 1;\n            let d = fn([poly[i], poly[next]], lineOrRay);\n            if (d)\n                pts.push(d);\n        }\n        return (pts.length > 0) ? pts : undefined;\n    }\n    static intersectLines2D(lines1, lines2, isRay = false) {\n        let group = new Group();\n        let fn = isRay ? Line.intersectLineWithRay2D : Line.intersectLine2D;\n        for (let i = 0, len = lines1.length; i < len; i++) {\n            for (let k = 0, lenk = lines2.length; k < lenk; k++) {\n                let _ip = fn(lines1[i], lines2[k]);\n                if (_ip)\n                    group.push(_ip);\n            }\n        }\n        return group;\n    }\n    static intersectGridWithRay2D(ray, gridPt) {\n        let t = Line.intercept(new Pt(ray[0]).subtract(gridPt), new Pt(ray[1]).subtract(gridPt));\n        let g = new Group();\n        if (t && t.xi)\n            g.push(new Pt(gridPt[0] + t.xi, gridPt[1]));\n        if (t && t.yi)\n            g.push(new Pt(gridPt[0], gridPt[1] + t.yi));\n        return g;\n    }\n    static intersectGridWithLine2D(line, gridPt) {\n        let g = Line.intersectGridWithRay2D(line, gridPt);\n        let gg = new Group();\n        for (let i = 0, len = g.length; i < len; i++) {\n            if (Geom.withinBound(g[i], line[0], line[1]))\n                gg.push(g[i]);\n        }\n        return gg;\n    }\n    static intersectRect2D(line, rect) {\n        let box = Geom.boundingBox(Group.fromPtArray(line));\n        if (!Rectangle.hasIntersectRect2D(box, rect))\n            return new Group();\n        return Line.intersectLines2D([line], Rectangle.sides(rect));\n    }\n    static subpoints(line, num) {\n        let pts = new Group();\n        for (let i = 1; i <= num; i++) {\n            pts.push(Geom.interpolate(line[0], line[1], i / (num + 1)));\n        }\n        return pts;\n    }\n    static crop(line, size, index = 0, cropAsCircle = true) {\n        let tdx = (index === 0) ? 1 : 0;\n        let ls = line[tdx].$subtract(line[index]);\n        if (ls[0] === 0 || size[0] === 0)\n            return line[index];\n        if (cropAsCircle) {\n            let d = ls.unit().multiply(size[1]);\n            return line[index].$add(d);\n        }\n        else {\n            let rect = Rectangle.fromCenter(line[index], size);\n            let sides = Rectangle.sides(rect);\n            let sideIdx = 0;\n            if (Math.abs(ls[1] / ls[0]) > Math.abs(size[1] / size[0])) {\n                sideIdx = (ls[1] < 0) ? 0 : 2;\n            }\n            else {\n                sideIdx = (ls[0] < 0) ? 3 : 1;\n            }\n            return Line.intersectRay2D(sides[sideIdx], line);\n        }\n    }\n    static marker(line, size, graphic = (\"arrow\" || \"line\"), atTail = true) {\n        let h = atTail ? 0 : 1;\n        let t = atTail ? 1 : 0;\n        let unit = line[h].$subtract(line[t]);\n        if (unit.magnitudeSq() === 0)\n            return new Group();\n        unit.unit();\n        let ps = Geom.perpendicular(unit).multiply(size[0]).add(line[t]);\n        if (graphic == \"arrow\") {\n            ps.add(unit.$multiply(size[1]));\n            return new Group(line[t], ps[0], ps[1]);\n        }\n        else {\n            return new Group(ps[0], ps[1]);\n        }\n    }\n    static toRect(line) {\n        return new Group(line[0].$min(line[1]), line[0].$max(line[1]));\n    }\n}\nexport class Rectangle {\n    static from(topLeft, widthOrSize, height) {\n        return Rectangle.fromTopLeft(topLeft, widthOrSize, height);\n    }\n    static fromTopLeft(topLeft, widthOrSize, height) {\n        let size = (typeof widthOrSize == \"number\") ? [widthOrSize, (height || widthOrSize)] : widthOrSize;\n        return new Group(new Pt(topLeft), new Pt(topLeft).add(size));\n    }\n    static fromCenter(center, widthOrSize, height) {\n        let half = (typeof widthOrSize == \"number\") ? [widthOrSize / 2, (height || widthOrSize) / 2] : new Pt(widthOrSize).divide(2);\n        return new Group(new Pt(center).subtract(half), new Pt(center).add(half));\n    }\n    static toCircle(pts, within = true) {\n        return Circle.fromRect(pts, within);\n    }\n    static toSquare(pts, enclose = false) {\n        let s = Rectangle.size(pts);\n        let m = (enclose) ? s.maxValue().value : s.minValue().value;\n        return Rectangle.fromCenter(Rectangle.center(pts), m, m);\n    }\n    static size(pts) {\n        return pts[0].$max(pts[1]).subtract(pts[0].$min(pts[1]));\n    }\n    static center(pts) {\n        let min = pts[0].$min(pts[1]);\n        let max = pts[0].$max(pts[1]);\n        return min.add(max.$subtract(min).divide(2));\n    }\n    static corners(rect) {\n        let p0 = rect[0].$min(rect[1]);\n        let p2 = rect[0].$max(rect[1]);\n        return new Group(p0, new Pt(p2.x, p0.y), p2, new Pt(p0.x, p2.y));\n    }\n    static sides(rect) {\n        let [p0, p1, p2, p3] = Rectangle.corners(rect);\n        return [\n            new Group(p0, p1), new Group(p1, p2),\n            new Group(p2, p3), new Group(p3, p0)\n        ];\n    }\n    static boundingBox(rects) {\n        let merged = Util.flatten(rects, false);\n        let min = Pt.make(2, Number.MAX_VALUE);\n        let max = Pt.make(2, Number.MIN_VALUE);\n        for (let i = 0, len = merged.length; i < len; i++) {\n            for (let k = 0; k < 2; k++) {\n                min[k] = Math.min(min[k], merged[i][k]);\n                max[k] = Math.max(max[k], merged[i][k]);\n            }\n        }\n        return new Group(min, max);\n    }\n    static polygon(rect) {\n        return Rectangle.corners(rect);\n    }\n    static quadrants(rect, center) {\n        let corners = Rectangle.corners(rect);\n        let _center = (center != undefined) ? new Pt(center) : Rectangle.center(rect);\n        return corners.map((c) => new Group(c, _center).boundingBox());\n    }\n    static halves(rect, ratio = 0.5, asRows = false) {\n        let min = rect[0].$min(rect[1]);\n        let max = rect[0].$max(rect[1]);\n        let mid = (asRows) ? Num.lerp(min[1], max[1], ratio) : Num.lerp(min[0], max[0], ratio);\n        return (asRows)\n            ? [new Group(min, new Pt(max[0], mid)), new Group(new Pt(min[0], mid), max)]\n            : [new Group(min, new Pt(mid, max[1])), new Group(new Pt(mid, min[1]), max)];\n    }\n    static withinBound(rect, pt) {\n        return Geom.withinBound(pt, rect[0], rect[1]);\n    }\n    static hasIntersectRect2D(rect1, rect2, resetBoundingBox = false) {\n        if (resetBoundingBox) {\n            rect1 = Geom.boundingBox(rect1);\n            rect2 = Geom.boundingBox(rect2);\n        }\n        if (rect1[0][0] > rect2[1][0] || rect2[0][0] > rect1[1][0])\n            return false;\n        if (rect1[0][1] > rect2[1][1] || rect2[0][1] > rect1[1][1])\n            return false;\n        return true;\n    }\n    static intersectRect2D(rect1, rect2) {\n        if (!Rectangle.hasIntersectRect2D(rect1, rect2))\n            return new Group();\n        return Line.intersectLines2D(Rectangle.sides(rect1), Rectangle.sides(rect2));\n    }\n}\nexport class Circle {\n    static fromRect(pts, enclose = false) {\n        let r = 0;\n        let min = r = Rectangle.size(pts).minValue().value / 2;\n        if (enclose) {\n            let max = Rectangle.size(pts).maxValue().value / 2;\n            r = Math.sqrt(min * min + max * max);\n        }\n        else {\n            r = min;\n        }\n        return new Group(Rectangle.center(pts), new Pt(r, r));\n    }\n    static fromCenter(pt, radius) {\n        return new Group(new Pt(pt), new Pt(radius, radius));\n    }\n    static withinBound(pts, pt, threshold = 0) {\n        let d = pts[0].$subtract(pt);\n        return d.dot(d) + threshold < pts[1].x * pts[1].x;\n    }\n    static intersectRay2D(pts, ray) {\n        let d = ray[0].$subtract(ray[1]);\n        let f = pts[0].$subtract(ray[0]);\n        let a = d.dot(d);\n        let b = f.dot(d);\n        let c = f.dot(f) - pts[1].x * pts[1].x;\n        let p = b / a;\n        let q = c / a;\n        let disc = p * p - q;\n        if (disc < 0) {\n            return new Group();\n        }\n        else {\n            let discSqrt = Math.sqrt(disc);\n            let t1 = -p + discSqrt;\n            let p1 = ray[0].$subtract(d.$multiply(t1));\n            if (disc === 0)\n                return new Group(p1);\n            let t2 = -p - discSqrt;\n            let p2 = ray[0].$subtract(d.$multiply(t2));\n            return new Group(p1, p2);\n        }\n    }\n    static intersectLine2D(pts, line) {\n        let ps = Circle.intersectRay2D(pts, line);\n        let g = new Group();\n        if (ps.length > 0) {\n            for (let i = 0, len = ps.length; i < len; i++) {\n                if (Rectangle.withinBound(line, ps[i]))\n                    g.push(ps[i]);\n            }\n        }\n        return g;\n    }\n    static intersectCircle2D(pts, circle) {\n        let dv = circle[0].$subtract(pts[0]);\n        let dr2 = dv.magnitudeSq();\n        let dr = Math.sqrt(dr2);\n        let ar = pts[1].x;\n        let br = circle[1].x;\n        let ar2 = ar * ar;\n        let br2 = br * br;\n        if (dr > ar + br) {\n            return new Group();\n        }\n        else if (dr < Math.abs(ar - br)) {\n            return new Group(pts[0].clone());\n        }\n        else {\n            let a = (ar2 - br2 + dr2) / (2 * dr);\n            let h = Math.sqrt(ar2 - a * a);\n            let p = dv.$multiply(a / dr).add(pts[0]);\n            return new Group(new Pt(p.x + h * dv.y / dr, p.y - h * dv.x / dr), new Pt(p.x - h * dv.y / dr, p.y + h * dv.x / dr));\n        }\n    }\n    static intersectRect2D(pts, rect) {\n        let sides = Rectangle.sides(rect);\n        let g = [];\n        for (let i = 0, len = sides.length; i < len; i++) {\n            let ps = Circle.intersectLine2D(pts, sides[i]);\n            if (ps.length > 0)\n                g.push(ps);\n        }\n        return Util.flatten(g);\n    }\n    static toRect(pts, within = false) {\n        let r = pts[1][0];\n        if (within) {\n            let half = Math.sqrt(r * r) / 2;\n            return new Group(pts[0].$subtract(half), pts[0].$add(half));\n        }\n        else {\n            return new Group(pts[0].$subtract(r), pts[0].$add(r));\n        }\n    }\n    static toTriangle(pts, within = true) {\n        if (within) {\n            let ang = -Math.PI / 2;\n            let inc = Math.PI * 2 / 3;\n            let g = new Group();\n            for (let i = 0; i < 3; i++) {\n                g.push(pts[0].clone().toAngle(ang, pts[1][0], true));\n                ang += inc;\n            }\n            return g;\n        }\n        else {\n            return Triangle.fromCenter(pts[0], pts[1][0]);\n        }\n    }\n}\nexport class Triangle {\n    static fromRect(rect) {\n        let top = rect[0].$add(rect[1]).divide(2);\n        top.y = rect[0][1];\n        let left = rect[1].clone();\n        left.x = rect[0][0];\n        return new Group(top, rect[1].clone(), left);\n    }\n    static fromCircle(circle) {\n        return Circle.toTriangle(circle, true);\n    }\n    static fromCenter(pt, size) {\n        return Triangle.fromCircle(Circle.fromCenter(pt, size));\n    }\n    static medial(pts) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        return Polygon.midpoints(pts, true);\n    }\n    static oppositeSide(pts, index) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        if (index === 0) {\n            return Group.fromPtArray([pts[1], pts[2]]);\n        }\n        else if (index === 1) {\n            return Group.fromPtArray([pts[0], pts[2]]);\n        }\n        else {\n            return Group.fromPtArray([pts[0], pts[1]]);\n        }\n    }\n    static altitude(pts, index) {\n        let opp = Triangle.oppositeSide(pts, index);\n        if (opp.length > 1) {\n            return new Group(pts[index], Line.perpendicularFromPt(opp, pts[index]));\n        }\n        else {\n            return new Group();\n        }\n    }\n    static orthocenter(pts) {\n        if (pts.length < 3)\n            return _errorLength(undefined, 3);\n        let a = Triangle.altitude(pts, 0);\n        let b = Triangle.altitude(pts, 1);\n        return Line.intersectRay2D(a, b);\n    }\n    static incenter(pts) {\n        if (pts.length < 3)\n            return _errorLength(undefined, 3);\n        let a = Polygon.bisector(pts, 0).add(pts[0]);\n        let b = Polygon.bisector(pts, 1).add(pts[1]);\n        return Line.intersectRay2D(new Group(pts[0], a), new Group(pts[1], b));\n    }\n    static incircle(pts, center) {\n        let c = (center) ? center : Triangle.incenter(pts);\n        let area = Polygon.area(pts);\n        let perim = Polygon.perimeter(pts, true);\n        let r = 2 * area / perim.total;\n        return Circle.fromCenter(c, r);\n    }\n    static circumcenter(pts) {\n        let md = Triangle.medial(pts);\n        let a = [md[0], Geom.perpendicular(pts[0].$subtract(md[0])).p1.$add(md[0])];\n        let b = [md[1], Geom.perpendicular(pts[1].$subtract(md[1])).p1.$add(md[1])];\n        return Line.intersectRay2D(a, b);\n    }\n    static circumcircle(pts, center) {\n        let c = (center) ? center : Triangle.circumcenter(pts);\n        let r = pts[0].$subtract(c).magnitude();\n        return Circle.fromCenter(c, r);\n    }\n}\nexport class Polygon {\n    static centroid(pts) {\n        return Geom.centroid(pts);\n    }\n    static rectangle(center, widthOrSize, height) {\n        return Rectangle.corners(Rectangle.fromCenter(center, widthOrSize, height));\n    }\n    static fromCenter(center, radius, sides) {\n        let g = new Group();\n        for (let i = 0; i < sides; i++) {\n            let ang = Math.PI * 2 * i / sides;\n            g.push(new Pt(Math.cos(ang) * radius, Math.sin(ang) * radius).add(center));\n        }\n        return g;\n    }\n    static lineAt(pts, idx) {\n        if (idx < 0 || idx >= pts.length)\n            throw new Error(\"index out of the Polygon's range\");\n        return new Group(pts[idx], (idx === pts.length - 1) ? pts[0] : pts[idx + 1]);\n    }\n    static lines(pts, closePath = true) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        let sp = Util.split(pts, 2, 1);\n        if (closePath)\n            sp.push(new Group(pts[pts.length - 1], pts[0]));\n        return sp.map((g) => g);\n    }\n    static midpoints(pts, closePath = false, t = 0.5) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        let sides = Polygon.lines(pts, closePath);\n        let mids = sides.map((s) => Geom.interpolate(s[0], s[1], t));\n        return mids;\n    }\n    static adjacentSides(pts, index, closePath = false) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        if (index < 0 || index >= pts.length)\n            return _errorOutofBound(new Group(), index);\n        let gs = [];\n        let left = index - 1;\n        if (closePath && left < 0)\n            left = pts.length - 1;\n        if (left >= 0)\n            gs.push(new Group(pts[index], pts[left]));\n        let right = index + 1;\n        if (closePath && right > pts.length - 1)\n            right = 0;\n        if (right <= pts.length - 1)\n            gs.push(new Group(pts[index], pts[right]));\n        return gs;\n    }\n    static bisector(pts, index) {\n        let sides = Polygon.adjacentSides(pts, index, true);\n        if (sides.length >= 2) {\n            let a = sides[0][1].$subtract(sides[0][0]).unit();\n            let b = sides[1][1].$subtract(sides[1][0]).unit();\n            return a.add(b).divide(2);\n        }\n        else {\n            return undefined;\n        }\n    }\n    static perimeter(pts, closePath = false) {\n        if (pts.length < 2)\n            return _errorLength(new Group(), 2);\n        let lines = Polygon.lines(pts, closePath);\n        let mag = 0;\n        let p = Pt.make(lines.length, 0);\n        for (let i = 0, len = lines.length; i < len; i++) {\n            let m = Line.magnitude(lines[i]);\n            mag += m;\n            p[i] = m;\n        }\n        return {\n            total: mag,\n            segments: p\n        };\n    }\n    static area(pts) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        let det = (a, b) => a[0] * b[1] - a[1] * b[0];\n        let area = 0;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (i < pts.length - 1) {\n                area += det(pts[i], pts[i + 1]);\n            }\n            else {\n                area += det(pts[i], pts[0]);\n            }\n        }\n        return Math.abs(area / 2);\n    }\n    static convexHull(pts, sorted = false) {\n        if (pts.length < 3)\n            return _errorLength(new Group(), 3);\n        if (!sorted) {\n            pts = pts.slice();\n            pts.sort((a, b) => a[0] - b[0]);\n        }\n        let left = (a, b, c) => {\n            return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]) > 0;\n        };\n        let dq = [];\n        let bot = pts.length - 2;\n        let top = bot + 3;\n        dq[bot] = pts[2];\n        dq[top] = pts[2];\n        if (left(pts[0], pts[1], pts[2])) {\n            dq[bot + 1] = pts[0];\n            dq[bot + 2] = pts[1];\n        }\n        else {\n            dq[bot + 1] = pts[1];\n            dq[bot + 2] = pts[0];\n        }\n        for (let i = 3, len = pts.length; i < len; i++) {\n            let pt = pts[i];\n            if (left(dq[bot], dq[bot + 1], pt) && left(dq[top - 1], dq[top], pt)) {\n                continue;\n            }\n            while (!left(dq[bot], dq[bot + 1], pt)) {\n                bot += 1;\n            }\n            bot -= 1;\n            dq[bot] = pt;\n            while (!left(dq[top - 1], dq[top], pt)) {\n                top -= 1;\n            }\n            top += 1;\n            dq[top] = pt;\n        }\n        let hull = new Group();\n        for (let h = 0; h < (top - bot); h++) {\n            hull.push(dq[bot + h]);\n        }\n        return hull;\n    }\n    static network(pts, originIndex = 0) {\n        let g = [];\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (i != originIndex)\n                g.push(new Group(pts[originIndex], pts[i]));\n        }\n        return g;\n    }\n    static nearestPt(pts, pt) {\n        let _near = Number.MAX_VALUE;\n        let _item = -1;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let d = pts[i].$subtract(pt).magnitudeSq();\n            if (d < _near) {\n                _near = d;\n                _item = i;\n            }\n        }\n        return _item;\n    }\n    static projectAxis(poly, unitAxis) {\n        let dot = unitAxis.dot(poly[0]);\n        let d = new Pt(dot, dot);\n        for (let n = 1, len = poly.length; n < len; n++) {\n            dot = unitAxis.dot(poly[n]);\n            d = new Pt(Math.min(dot, d[0]), Math.max(dot, d[1]));\n        }\n        return d;\n    }\n    static _axisOverlap(poly1, poly2, unitAxis) {\n        let pa = Polygon.projectAxis(poly1, unitAxis);\n        let pb = Polygon.projectAxis(poly2, unitAxis);\n        return (pa[0] < pb[0]) ? pb[0] - pa[1] : pa[0] - pb[1];\n    }\n    static hasIntersectPoint(poly, pt) {\n        let c = false;\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let ln = Polygon.lineAt(poly, i);\n            if (((ln[0][1] > pt[1]) != (ln[1][1] > pt[1])) &&\n                (pt[0] < (ln[1][0] - ln[0][0]) * (pt[1] - ln[0][1]) / (ln[1][1] - ln[0][1]) + ln[0][0])) {\n                c = !c;\n            }\n        }\n        return c;\n    }\n    static hasIntersectCircle(poly, circle) {\n        let info = {\n            which: -1,\n            dist: 0,\n            normal: null,\n            edge: null,\n            vertex: null,\n        };\n        let c = circle[0];\n        let r = circle[1][0];\n        let minDist = Number.MAX_SAFE_INTEGER;\n        for (let i = 0, len = poly.length; i < len; i++) {\n            let edge = Polygon.lineAt(poly, i);\n            let axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n            let poly2 = new Group(c.$add(axis.$multiply(r)), c.$subtract(axis.$multiply(r)));\n            let dist = Polygon._axisOverlap(poly, poly2, axis);\n            if (dist > 0) {\n                return null;\n            }\n            else if (Math.abs(dist) < minDist) {\n                let check = Rectangle.withinBound(edge, Line.perpendicularFromPt(edge, c)) || Circle.intersectLine2D(circle, edge).length > 0;\n                if (check) {\n                    info.edge = edge;\n                    info.normal = axis;\n                    minDist = Math.abs(dist);\n                    info.which = i;\n                }\n            }\n        }\n        if (!info.edge)\n            return null;\n        let dir = c.$subtract(Polygon.centroid(poly)).dot(info.normal);\n        if (dir < 0)\n            info.normal.multiply(-1);\n        info.dist = minDist;\n        info.vertex = c;\n        return info;\n    }\n    static hasIntersectPolygon(poly1, poly2) {\n        let info = {\n            which: -1,\n            dist: 0,\n            normal: new Pt(),\n            edge: new Group(),\n            vertex: new Pt()\n        };\n        let minDist = Number.MAX_SAFE_INTEGER;\n        for (let i = 0, plen = (poly1.length + poly2.length); i < plen; i++) {\n            let edge = (i < poly1.length) ? Polygon.lineAt(poly1, i) : Polygon.lineAt(poly2, i - poly1.length);\n            let axis = new Pt(edge[0].y - edge[1].y, edge[1].x - edge[0].x).unit();\n            let dist = Polygon._axisOverlap(poly1, poly2, axis);\n            if (dist > 0) {\n                return null;\n            }\n            else if (Math.abs(dist) < minDist) {\n                info.edge = edge;\n                info.normal = axis;\n                minDist = Math.abs(dist);\n                info.which = (i < poly1.length) ? 0 : 1;\n            }\n        }\n        info.dist = minDist;\n        let b1 = (info.which === 0) ? poly2 : poly1;\n        let b2 = (info.which === 0) ? poly1 : poly2;\n        let c1 = Polygon.centroid(b1);\n        let c2 = Polygon.centroid(b2);\n        let dir = c1.$subtract(c2).dot(info.normal);\n        if (dir < 0)\n            info.normal.multiply(-1);\n        let smallest = Number.MAX_SAFE_INTEGER;\n        for (let i = 0, len = b1.length; i < len; i++) {\n            let d = info.normal.dot(b1[i].$subtract(c2));\n            if (d < smallest) {\n                smallest = d;\n                info.vertex = b1[i];\n            }\n        }\n        return info;\n    }\n    static intersectPolygon2D(poly1, poly2) {\n        let lp = Polygon.lines(poly1);\n        let g = [];\n        for (let i = 0, len = lp.length; i < len; i++) {\n            let ins = Line.intersectPolygon2D(lp[i], poly2, false);\n            if (ins)\n                g.push(ins);\n        }\n        return Util.flatten(g, true);\n    }\n    static toRects(polys) {\n        let boxes = polys.map((g) => Geom.boundingBox(g));\n        let merged = Util.flatten(boxes, false);\n        boxes.unshift(Geom.boundingBox(merged));\n        return boxes;\n    }\n}\nexport class Curve {\n    static getSteps(steps) {\n        let ts = new Group();\n        for (let i = 0; i <= steps; i++) {\n            let t = i / steps;\n            ts.push(new Pt(t * t * t, t * t, t, 1));\n        }\n        return ts;\n    }\n    static controlPoints(pts, index = 0, copyStart = false) {\n        if (index > pts.length - 1)\n            return new Group();\n        let _index = (i) => (i < pts.length - 1) ? i : pts.length - 1;\n        let p0 = pts[index];\n        index = (copyStart) ? index : index + 1;\n        return new Group(p0, pts[_index(index++)], pts[_index(index++)], pts[_index(index++)]);\n    }\n    static _calcPt(ctrls, params) {\n        let x = ctrls.reduce((a, c, i) => a + c.x * params[i], 0);\n        let y = ctrls.reduce((a, c, i) => a + c.y * params[i], 0);\n        if (ctrls[0].length > 2) {\n            let z = ctrls.reduce((a, c, i) => a + c.z * params[i], 0);\n            return new Pt(x, y, z);\n        }\n        return new Pt(x, y);\n    }\n    static catmullRom(pts, steps = 10) {\n        if (pts.length < 2)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let c = Curve.controlPoints(pts, 0, true);\n        for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.catmullRomStep(ts[i], c));\n        }\n        let k = 0;\n        while (k < pts.length - 2) {\n            let cp = Curve.controlPoints(pts, k);\n            if (cp.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.catmullRomStep(ts[i], cp));\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    static catmullRomStep(step, ctrls) {\n        let m = new Group(new Pt(-0.5, 1, -0.5, 0), new Pt(1.5, -2.5, 0, 1), new Pt(-1.5, 2, 0.5, 0), new Pt(0.5, -0.5, 0, 0));\n        return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n    static cardinal(pts, steps = 10, tension = 0.5) {\n        if (pts.length < 2)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let c = Curve.controlPoints(pts, 0, true);\n        for (let i = 0; i <= steps; i++) {\n            ps.push(Curve.cardinalStep(ts[i], c, tension));\n        }\n        let k = 0;\n        while (k < pts.length - 2) {\n            let cp = Curve.controlPoints(pts, k);\n            if (cp.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.cardinalStep(ts[i], cp, tension));\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    static cardinalStep(step, ctrls, tension = 0.5) {\n        let m = new Group(new Pt(-1, 2, -1, 0), new Pt(-1, 1, 0, 0), new Pt(1, -2, 1, 0), new Pt(1, -1, 0, 0));\n        let h = Mat.multiply([step], m, true)[0].multiply(tension);\n        let h2 = (2 * step[0] - 3 * step[1] + 1);\n        let h3 = -2 * step[0] + 3 * step[1];\n        let pt = Curve._calcPt(ctrls, h);\n        pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n        pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n        if (pt.length > 2)\n            pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n        return pt;\n    }\n    static bezier(pts, steps = 10) {\n        if (pts.length < 4)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let k = 0;\n        while (k < pts.length - 3) {\n            let c = Curve.controlPoints(pts, k);\n            if (c.length > 0) {\n                for (let i = 0; i <= steps; i++) {\n                    ps.push(Curve.bezierStep(ts[i], c));\n                }\n                k += 3;\n            }\n        }\n        return ps;\n    }\n    static bezierStep(step, ctrls) {\n        let m = new Group(new Pt(-1, 3, -3, 1), new Pt(3, -6, 3, 0), new Pt(-3, 3, 0, 0), new Pt(1, 0, 0, 0));\n        return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n    static bspline(pts, steps = 10, tension = 1) {\n        if (pts.length < 2)\n            return new Group();\n        let ps = new Group();\n        let ts = Curve.getSteps(steps);\n        let k = 0;\n        while (k < pts.length - 3) {\n            let c = Curve.controlPoints(pts, k);\n            if (c.length > 0) {\n                if (tension !== 1) {\n                    for (let i = 0; i <= steps; i++) {\n                        ps.push(Curve.bsplineTensionStep(ts[i], c, tension));\n                    }\n                }\n                else {\n                    for (let i = 0; i <= steps; i++) {\n                        ps.push(Curve.bsplineStep(ts[i], c));\n                    }\n                }\n                k++;\n            }\n        }\n        return ps;\n    }\n    static bsplineStep(step, ctrls) {\n        let m = new Group(new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt(0.5, -1, 0, 0.6666666666666666), new Pt(-0.5, 0.5, 0.5, 0.16666666666666666), new Pt(0.16666666666666666, 0, 0, 0));\n        return Curve._calcPt(ctrls, Mat.multiply([step], m, true)[0]);\n    }\n    static bsplineTensionStep(step, ctrls, tension = 1) {\n        let m = new Group(new Pt(-0.16666666666666666, 0.5, -0.5, 0.16666666666666666), new Pt(-1.5, 2, 0, -0.3333333333333333), new Pt(1.5, -2.5, 0.5, 0.16666666666666666), new Pt(0.16666666666666666, 0, 0, 0));\n        let h = Mat.multiply([step], m, true)[0].multiply(tension);\n        let h2 = (2 * step[0] - 3 * step[1] + 1);\n        let h3 = -2 * step[0] + 3 * step[1];\n        let pt = Curve._calcPt(ctrls, h);\n        pt.x += h2 * ctrls[1].x + h3 * ctrls[2].x;\n        pt.y += h2 * ctrls[1].y + h3 * ctrls[2].y;\n        if (pt.length > 2)\n            pt.z += h2 * ctrls[1].z + h3 * ctrls[2].z;\n        return pt;\n    }\n}\n//# sourceMappingURL=Op.js.map","import { Const } from \"./Util\";\nimport { Curve } from \"./Op\";\nimport { Pt, Group } from \"./Pt\";\nimport { Vec, Mat } from \"./LinearAlgebra\";\nexport class Num {\n    static equals(a, b, threshold = 0.00001) {\n        return Math.abs(a - b) < threshold;\n    }\n    static lerp(a, b, t) {\n        return (1 - t) * a + t * b;\n    }\n    static clamp(val, min, max) {\n        return Math.max(min, Math.min(max, val));\n    }\n    static boundValue(val, min, max) {\n        let len = Math.abs(max - min);\n        let a = val % len;\n        if (a > max)\n            a -= len;\n        else if (a < min)\n            a += len;\n        return a;\n    }\n    static within(p, a, b) {\n        return p >= Math.min(a, b) && p <= Math.max(a, b);\n    }\n    static randomRange(a, b = 0) {\n        let r = (a > b) ? (a - b) : (b - a);\n        return a + Math.random() * r;\n    }\n    static normalizeValue(n, a, b) {\n        let min = Math.min(a, b);\n        let max = Math.max(a, b);\n        return (n - min) / (max - min);\n    }\n    static sum(pts) {\n        let c = new Pt(pts[0]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            Vec.add(c, pts[i]);\n        }\n        return c;\n    }\n    static average(pts) {\n        return Num.sum(pts).divide(pts.length);\n    }\n    static cycle(t) {\n        return (Math.sin(Math.PI * 2 * t) + 1) / 2;\n    }\n    static mapToRange(n, currA, currB, targetA, targetB) {\n        if (currA == currB)\n            throw new Error(\"[currMin, currMax] must define a range that is not zero\");\n        let min = Math.min(targetA, targetB);\n        let max = Math.max(targetA, targetB);\n        return Num.normalizeValue(n, currA, currB) * (max - min) + min;\n    }\n}\nexport class Geom {\n    static boundAngle(angle) {\n        return Num.boundValue(angle, 0, 360);\n    }\n    static boundRadian(radian) {\n        return Num.boundValue(radian, 0, Const.two_pi);\n    }\n    static toRadian(angle) {\n        return angle * Const.deg_to_rad;\n    }\n    static toDegree(radian) {\n        return radian * Const.rad_to_deg;\n    }\n    static boundingBox(pts) {\n        let minPt = pts.reduce((a, p) => a.$min(p));\n        let maxPt = pts.reduce((a, p) => a.$max(p));\n        return new Group(minPt, maxPt);\n    }\n    static centroid(pts) {\n        return Num.average(pts);\n    }\n    static anchor(pts, ptOrIndex = 0, direction = \"to\") {\n        let method = (direction == \"to\") ? \"subtract\" : \"add\";\n        for (let i = 0, len = pts.length; i < len; i++) {\n            if (typeof ptOrIndex == \"number\") {\n                if (ptOrIndex !== i)\n                    pts[i][method](pts[ptOrIndex]);\n            }\n            else {\n                pts[i][method](ptOrIndex);\n            }\n        }\n    }\n    static interpolate(a, b, t = 0.5) {\n        let len = Math.min(a.length, b.length);\n        let d = Pt.make(len);\n        for (let i = 0; i < len; i++) {\n            d[i] = a[i] * (1 - t) + b[i] * t;\n        }\n        return d;\n    }\n    static perpendicular(pt, axis = Const.xy) {\n        let y = axis[1];\n        let x = axis[0];\n        let p = new Pt(pt);\n        let pa = new Pt(p);\n        pa[x] = -p[y];\n        pa[y] = p[x];\n        let pb = new Pt(p);\n        pb[x] = p[y];\n        pb[y] = -p[x];\n        return new Group(pa, pb);\n    }\n    static isPerpendicular(p1, p2) {\n        return new Pt(p1).dot(p2) === 0;\n    }\n    static withinBound(pt, boundPt1, boundPt2) {\n        for (let i = 0, len = Math.min(pt.length, boundPt1.length, boundPt2.length); i < len; i++) {\n            if (!Num.within(pt[i], boundPt1[i], boundPt2[i]))\n                return false;\n        }\n        return true;\n    }\n    static sortEdges(pts) {\n        let bounds = Geom.boundingBox(pts);\n        let center = bounds[1].add(bounds[0]).divide(2);\n        let fn = (a, b) => {\n            if (a.length < 2 || b.length < 2)\n                throw new Error(\"Pt dimension cannot be less than 2\");\n            let da = a.$subtract(center);\n            let db = b.$subtract(center);\n            if (da[0] >= 0 && db[0] < 0)\n                return 1;\n            if (da[0] < 0 && db[0] >= 0)\n                return -1;\n            if (da[0] == 0 && db[0] == 0) {\n                if (da[1] >= 0 || db[1] >= 0)\n                    return (da[1] > db[1]) ? 1 : -1;\n                return (db[1] > da[1]) ? 1 : -1;\n            }\n            let det = da.$cross2D(db);\n            if (det < 0)\n                return 1;\n            if (det > 0)\n                return -1;\n            return (da[0] * da[0] + da[1] * da[1] > db[0] * db[0] + db[1] * db[1]) ? 1 : -1;\n        };\n        return pts.sort(fn);\n    }\n    static scale(ps, scale, anchor) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let scs = (typeof scale == \"number\") ? Pt.make(pts[0].length, scale) : scale;\n        if (!anchor)\n            anchor = Pt.make(pts[0].length, 0);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = pts[i];\n            for (let k = 0, lenP = p.length; k < lenP; k++) {\n                p[k] = (anchor && anchor[k]) ? anchor[k] + (p[k] - anchor[k]) * scs[k] : p[k] * scs[k];\n            }\n        }\n        return Geom;\n    }\n    static rotate2D(ps, angle, anchor, axis) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let fn = (anchor) ? Mat.rotateAt2DMatrix : Mat.rotate2DMatrix;\n        if (!anchor)\n            anchor = Pt.make(pts[0].length, 0);\n        let cos = Math.cos(angle);\n        let sin = Math.sin(angle);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = (axis) ? pts[i].$take(axis) : pts[i];\n            p.to(Mat.transform2D(p, fn(cos, sin, anchor)));\n        }\n        return Geom;\n    }\n    static shear2D(ps, scale, anchor, axis) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let s = (typeof scale == \"number\") ? [scale, scale] : scale;\n        if (!anchor)\n            anchor = Pt.make(pts[0].length, 0);\n        let fn = (anchor) ? Mat.shearAt2DMatrix : Mat.shear2DMatrix;\n        let tanx = Math.tan(s[0]);\n        let tany = Math.tan(s[1]);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = (axis) ? pts[i].$take(axis) : pts[i];\n            p.to(Mat.transform2D(p, fn(tanx, tany, anchor)));\n        }\n        return Geom;\n    }\n    static reflect2D(ps, line, axis) {\n        let pts = (!Array.isArray(ps)) ? [ps] : ps;\n        let mat = Mat.reflectAt2DMatrix(line[0], line[1]);\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let p = (axis) ? pts[i].$take(axis) : pts[i];\n            p.to(Mat.transform2D(p, mat));\n        }\n        return Geom;\n    }\n    static cosTable() {\n        let cos = new Float64Array(360);\n        for (let i = 0; i < 360; i++)\n            cos[i] = Math.cos(i * Math.PI / 180);\n        let find = (rad) => cos[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\n        return { table: cos, cos: find };\n    }\n    static sinTable() {\n        let sin = new Float64Array(360);\n        for (let i = 0; i < 360; i++)\n            sin[i] = Math.sin(i * Math.PI / 180);\n        let find = (rad) => sin[Math.floor(Geom.boundAngle(Geom.toDegree(rad)))];\n        return { table: sin, sin: find };\n    }\n}\nexport class Shaping {\n    static linear(t, c = 1) {\n        return c * t;\n    }\n    static quadraticIn(t, c = 1) {\n        return c * t * t;\n    }\n    static quadraticOut(t, c = 1) {\n        return -c * t * (t - 2);\n    }\n    static quadraticInOut(t, c = 1) {\n        let dt = t * 2;\n        return (t < 0.5) ? c / 2 * t * t * 4 : -c / 2 * ((dt - 1) * (dt - 3) - 1);\n    }\n    static cubicIn(t, c = 1) {\n        return c * t * t * t;\n    }\n    static cubicOut(t, c = 1) {\n        let dt = t - 1;\n        return c * (dt * dt * dt + 1);\n    }\n    static cubicInOut(t, c = 1) {\n        let dt = t * 2;\n        return (t < 0.5) ? c / 2 * dt * dt * dt : c / 2 * ((dt - 2) * (dt - 2) * (dt - 2) + 2);\n    }\n    static exponentialIn(t, c = 1, p = 0.25) {\n        return c * Math.pow(t, 1 / p);\n    }\n    static exponentialOut(t, c = 1, p = 0.25) {\n        return c * Math.pow(t, p);\n    }\n    static sineIn(t, c = 1) {\n        return -c * Math.cos(t * Const.half_pi) + c;\n    }\n    static sineOut(t, c = 1) {\n        return c * Math.sin(t * Const.half_pi);\n    }\n    static sineInOut(t, c = 1) {\n        return -c / 2 * (Math.cos(Math.PI * t) - 1);\n    }\n    static cosineApprox(t, c = 1) {\n        let t2 = t * t;\n        let t4 = t2 * t2;\n        let t6 = t4 * t2;\n        return c * (4 * t6 / 9 - 17 * t4 / 9 + 22 * t2 / 9);\n    }\n    static circularIn(t, c = 1) {\n        return -c * (Math.sqrt(1 - t * t) - 1);\n    }\n    static circularOut(t, c = 1) {\n        let dt = t - 1;\n        return c * Math.sqrt(1 - dt * dt);\n    }\n    static circularInOut(t, c = 1) {\n        let dt = t * 2;\n        return (t < 0.5) ? -c / 2 * (Math.sqrt(1 - dt * dt) - 1) : c / 2 * (Math.sqrt(1 - (dt - 2) * (dt - 2)) + 1);\n    }\n    static elasticIn(t, c = 1, p = 0.7) {\n        let dt = t - 1;\n        let s = (p / Const.two_pi) * 1.5707963267948966;\n        return c * (-Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p));\n    }\n    static elasticOut(t, c = 1, p = 0.7) {\n        let s = (p / Const.two_pi) * 1.5707963267948966;\n        return c * (Math.pow(2, -10 * t) * Math.sin((t - s) * Const.two_pi / p)) + c;\n    }\n    static elasticInOut(t, c = 1, p = 0.6) {\n        let dt = t * 2;\n        let s = (p / Const.two_pi) * 1.5707963267948966;\n        if (t < 0.5) {\n            dt -= 1;\n            return c * (-0.5 * (Math.pow(2, 10 * dt) * Math.sin((dt - s) * Const.two_pi / p)));\n        }\n        else {\n            dt -= 1;\n            return c * (0.5 * (Math.pow(2, -10 * dt) * Math.sin((dt - s) * Const.two_pi / p))) + c;\n        }\n    }\n    static bounceIn(t, c = 1) {\n        return c - Shaping.bounceOut((1 - t), c);\n    }\n    static bounceOut(t, c = 1) {\n        if (t < (1 / 2.75)) {\n            return c * (7.5625 * t * t);\n        }\n        else if (t < (2 / 2.75)) {\n            t -= 1.5 / 2.75;\n            return c * (7.5625 * t * t + 0.75);\n        }\n        else if (t < (2.5 / 2.75)) {\n            t -= 2.25 / 2.75;\n            return c * (7.5625 * t * t + 0.9375);\n        }\n        else {\n            t -= 2.625 / 2.75;\n            return c * (7.5625 * t * t + 0.984375);\n        }\n    }\n    static bounceInOut(t, c = 1) {\n        return (t < 0.5) ? Shaping.bounceIn(t * 2, c) / 2 : Shaping.bounceOut(t * 2 - 1, c) / 2 + c / 2;\n    }\n    static sigmoid(t, c = 1, p = 10) {\n        let d = p * (t - 0.5);\n        return c / (1 + Math.exp(-d));\n    }\n    static logSigmoid(t, c = 1, p = 0.7) {\n        p = Math.max(Const.epsilon, Math.min(1 - Const.epsilon, p));\n        p = 1 / (1 - p);\n        let A = 1 / (1 + Math.exp(((t - 0.5) * p * -2)));\n        let B = 1 / (1 + Math.exp(p));\n        let C = 1 / (1 + Math.exp(-p));\n        return c * (A - B) / (C - B);\n    }\n    static seat(t, c = 1, p = 0.5) {\n        if ((t < 0.5)) {\n            return c * (Math.pow(2 * t, 1 - p)) / 2;\n        }\n        else {\n            return c * (1 - (Math.pow(2 * (1 - t), 1 - p)) / 2);\n        }\n    }\n    static quadraticBezier(t, c = 1, p = [0.05, 0.95]) {\n        let a = (typeof p != \"number\") ? p[0] : p;\n        let b = (typeof p != \"number\") ? p[1] : 0.5;\n        let om2a = 1 - 2 * a;\n        if (om2a === 0) {\n            om2a = Const.epsilon;\n        }\n        let d = (Math.sqrt(a * a + om2a * t) - a) / om2a;\n        return c * ((1 - 2 * b) * (d * d) + (2 * b) * d);\n    }\n    static cubicBezier(t, c = 1, p1 = [0.1, 0.7], p2 = [0.9, 0.2]) {\n        let curve = new Group(new Pt(0, 0), new Pt(p1), new Pt(p2), new Pt(1, 1));\n        return c * Curve.bezierStep(new Pt(t * t * t, t * t, t, 1), Curve.controlPoints(curve)).y;\n    }\n    static quadraticTarget(t, c = 1, p1 = [0.2, 0.35]) {\n        let a = Math.min(1 - Const.epsilon, Math.max(Const.epsilon, p1[0]));\n        let b = Math.min(1, Math.max(0, p1[1]));\n        let A = (1 - b) / (1 - a) - (b / a);\n        let B = (A * (a * a) - b) / a;\n        let y = A * (t * t) - B * t;\n        return c * Math.min(1, Math.max(0, y));\n    }\n    static cliff(t, c = 1, p = 0.5) {\n        return (t > p) ? c : 0;\n    }\n    static step(fn, steps, t, c, ...args) {\n        let s = 1 / steps;\n        let tt = Math.floor(t / s) * s;\n        return fn(tt, c, ...args);\n    }\n}\nexport class Range {\n    constructor(g) {\n        this._dims = 0;\n        this._source = Group.fromPtArray(g);\n        this.calc();\n    }\n    get max() { return this._max.clone(); }\n    get min() { return this._min.clone(); }\n    get magnitude() { return this._mag.clone(); }\n    calc() {\n        if (!this._source)\n            return;\n        let dims = this._source[0].length;\n        this._dims = dims;\n        let max = new Pt(dims);\n        let min = new Pt(dims);\n        let mag = new Pt(dims);\n        for (let i = 0; i < dims; i++) {\n            max[i] = Const.min;\n            min[i] = Const.max;\n            mag[i] = 0;\n            let s = this._source.zipSlice(i);\n            for (let k = 0, len = s.length; k < len; k++) {\n                max[i] = Math.max(max[i], s[k]);\n                min[i] = Math.min(min[i], s[k]);\n                mag[i] = max[i] - min[i];\n            }\n        }\n        this._max = max;\n        this._min = min;\n        this._mag = mag;\n        return this;\n    }\n    mapTo(min, max, exclude) {\n        let target = new Group();\n        for (let i = 0, len = this._source.length; i < len; i++) {\n            let g = this._source[i];\n            let n = new Pt(this._dims);\n            for (let k = 0; k < this._dims; k++) {\n                n[k] = (exclude && exclude[k]) ? g[k] : Num.mapToRange(g[k], this._min[k], this._max[k], min, max);\n            }\n            target.push(n);\n        }\n        return target;\n    }\n    append(g, update = true) {\n        if (g[0].length !== this._dims)\n            throw new Error(`Dimensions don't match. ${this._dims} dimensions in Range and ${g[0].length} provided in parameter. `);\n        this._source = this._source.concat(g);\n        if (update)\n            this.calc();\n        return this;\n    }\n    ticks(count) {\n        let g = new Group();\n        for (let i = 0; i <= count; i++) {\n            let p = new Pt(this._dims);\n            for (let k = 0, len = this._max.length; k < len; k++) {\n                p[k] = Num.lerp(this._min[k], this._max[k], i / count);\n            }\n            g.push(p);\n        }\n        return g;\n    }\n}\n//# sourceMappingURL=Num.js.map","import { Util, Const } from \"./Util\";\nimport { Geom, Num } from \"./Num\";\nimport { Vec, Mat } from \"./LinearAlgebra\";\nexport var PtBaseArray = Float32Array;\nexport class Pt extends PtBaseArray {\n    constructor(...args) {\n        if (args.length === 1 && typeof args[0] == \"number\") {\n            super(args[0]);\n        }\n        else {\n            super((args.length > 0) ? Util.getArgs(args) : [0, 0]);\n        }\n    }\n    static make(dimensions, defaultValue = 0, randomize = false) {\n        let p = new PtBaseArray(dimensions);\n        if (defaultValue)\n            p.fill(defaultValue);\n        if (randomize) {\n            for (let i = 0, len = p.length; i < len; i++) {\n                p[i] = p[i] * Math.random();\n            }\n        }\n        return new Pt(p);\n    }\n    get id() { return this._id; }\n    set id(s) { this._id = s; }\n    get x() { return this[0]; }\n    set x(n) { this[0] = n; }\n    get y() { return this[1]; }\n    set y(n) { this[1] = n; }\n    get z() { return this[2]; }\n    set z(n) { this[2] = n; }\n    get w() { return this[3]; }\n    set w(n) { this[3] = n; }\n    clone() {\n        return new Pt(this);\n    }\n    equals(p, threshold = 0.000001) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            if (Math.abs(this[i] - p[i]) > threshold)\n                return false;\n        }\n        return true;\n    }\n    to(...args) {\n        let p = Util.getArgs(args);\n        for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n            this[i] = p[i];\n        }\n        return this;\n    }\n    $to(...args) {\n        return this.clone().to(...args);\n    }\n    toAngle(radian, magnitude, anchorFromPt = false) {\n        let m = (magnitude != undefined) ? magnitude : this.magnitude();\n        let change = [Math.cos(radian) * m, Math.sin(radian) * m];\n        return (anchorFromPt) ? this.add(change) : this.to(change);\n    }\n    op(fn) {\n        let self = this;\n        return (...params) => {\n            return fn(self, ...params);\n        };\n    }\n    ops(fns) {\n        let _ops = [];\n        for (let i = 0, len = fns.length; i < len; i++) {\n            _ops.push(this.op(fns[i]));\n        }\n        return _ops;\n    }\n    $take(axis) {\n        let p = [];\n        for (let i = 0, len = axis.length; i < len; i++) {\n            p.push(this[axis[i]] || 0);\n        }\n        return new Pt(p);\n    }\n    $concat(...args) {\n        return new Pt(this.toArray().concat(Util.getArgs(args)));\n    }\n    add(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? Vec.add(this, args[0]) : Vec.add(this, Util.getArgs(args));\n        return this;\n    }\n    $add(...args) { return this.clone().add(...args); }\n    subtract(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? Vec.subtract(this, args[0]) : Vec.subtract(this, Util.getArgs(args));\n        return this;\n    }\n    $subtract(...args) { return this.clone().subtract(...args); }\n    multiply(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? Vec.multiply(this, args[0]) : Vec.multiply(this, Util.getArgs(args));\n        return this;\n    }\n    $multiply(...args) { return this.clone().multiply(...args); }\n    divide(...args) {\n        (args.length === 1 && typeof args[0] == \"number\") ? Vec.divide(this, args[0]) : Vec.divide(this, Util.getArgs(args));\n        return this;\n    }\n    $divide(...args) { return this.clone().divide(...args); }\n    magnitudeSq() { return Vec.dot(this, this); }\n    magnitude() { return Vec.magnitude(this); }\n    unit(magnitude = undefined) {\n        Vec.unit(this, magnitude);\n        return this;\n    }\n    $unit(magnitude = undefined) { return this.clone().unit(magnitude); }\n    dot(...args) { return Vec.dot(this, Util.getArgs(args)); }\n    $cross2D(...args) { return Vec.cross2D(this, Util.getArgs(args)); }\n    $cross(...args) { return Vec.cross(this, Util.getArgs(args)); }\n    $project(...args) {\n        return this.$multiply(this.dot(...args) / this.magnitudeSq());\n    }\n    projectScalar(...args) {\n        return this.dot(...args) / this.magnitude();\n    }\n    abs() {\n        Vec.abs(this);\n        return this;\n    }\n    $abs() {\n        return this.clone().abs();\n    }\n    floor() {\n        Vec.floor(this);\n        return this;\n    }\n    $floor() {\n        return this.clone().floor();\n    }\n    ceil() {\n        Vec.ceil(this);\n        return this;\n    }\n    $ceil() {\n        return this.clone().ceil();\n    }\n    round() {\n        Vec.round(this);\n        return this;\n    }\n    $round() {\n        return this.clone().round();\n    }\n    minValue() {\n        return Vec.min(this);\n    }\n    maxValue() {\n        return Vec.max(this);\n    }\n    $min(...args) {\n        let p = Util.getArgs(args);\n        let m = this.clone();\n        for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n            m[i] = Math.min(this[i], p[i]);\n        }\n        return m;\n    }\n    $max(...args) {\n        let p = Util.getArgs(args);\n        let m = this.clone();\n        for (let i = 0, len = Math.min(this.length, p.length); i < len; i++) {\n            m[i] = Math.max(this[i], p[i]);\n        }\n        return m;\n    }\n    angle(axis = Const.xy) {\n        return Math.atan2(this[axis[1]], this[axis[0]]);\n    }\n    angleBetween(p, axis = Const.xy) {\n        return Geom.boundRadian(this.angle(axis)) - Geom.boundRadian(p.angle(axis));\n    }\n    scale(scale, anchor) {\n        Geom.scale(this, scale, anchor || Pt.make(this.length, 0));\n        return this;\n    }\n    rotate2D(angle, anchor, axis) {\n        Geom.rotate2D(this, angle, anchor || Pt.make(this.length, 0), axis);\n        return this;\n    }\n    shear2D(scale, anchor, axis) {\n        Geom.shear2D(this, scale, anchor || Pt.make(this.length, 0), axis);\n        return this;\n    }\n    reflect2D(line, axis) {\n        Geom.reflect2D(this, line, axis);\n        return this;\n    }\n    toString() {\n        return `Pt(${this.join(\", \")})`;\n    }\n    toArray() {\n        return [].slice.call(this);\n    }\n}\nexport class Group extends Array {\n    constructor(...args) {\n        super(...args);\n    }\n    get id() { return this._id; }\n    set id(s) { this._id = s; }\n    get p1() { return this[0]; }\n    get p2() { return this[1]; }\n    get p3() { return this[2]; }\n    get p4() { return this[3]; }\n    get q1() { return this[this.length - 1]; }\n    get q2() { return this[this.length - 2]; }\n    get q3() { return this[this.length - 3]; }\n    get q4() { return this[this.length - 4]; }\n    clone() {\n        let group = new Group();\n        for (let i = 0, len = this.length; i < len; i++) {\n            group.push(this[i].clone());\n        }\n        return group;\n    }\n    static fromArray(list) {\n        let g = new Group();\n        for (let i = 0, len = list.length; i < len; i++) {\n            let p = (list[i] instanceof Pt) ? list[i] : new Pt(list[i]);\n            g.push(p);\n        }\n        return g;\n    }\n    static fromPtArray(list) {\n        return Group.from(list);\n    }\n    split(chunkSize, stride, loopBack = false) {\n        let sp = Util.split(this, chunkSize, stride, loopBack);\n        return sp;\n    }\n    insert(pts, index = 0) {\n        Group.prototype.splice.apply(this, [index, 0, ...pts]);\n        return this;\n    }\n    remove(index = 0, count = 1) {\n        let param = (index < 0) ? [index * -1 - 1, count] : [index, count];\n        return Group.prototype.splice.apply(this, param);\n    }\n    segments(pts_per_segment = 2, stride = 1, loopBack = false) {\n        return this.split(pts_per_segment, stride, loopBack);\n    }\n    lines() { return this.segments(2, 1); }\n    centroid() {\n        return Geom.centroid(this);\n    }\n    boundingBox() {\n        return Geom.boundingBox(this);\n    }\n    anchorTo(ptOrIndex = 0) { Geom.anchor(this, ptOrIndex, \"to\"); }\n    anchorFrom(ptOrIndex = 0) { Geom.anchor(this, ptOrIndex, \"from\"); }\n    op(fn) {\n        let self = this;\n        return (...params) => {\n            return fn(self, ...params);\n        };\n    }\n    ops(fns) {\n        let _ops = [];\n        for (let i = 0, len = fns.length; i < len; i++) {\n            _ops.push(this.op(fns[i]));\n        }\n        return _ops;\n    }\n    interpolate(t) {\n        t = Num.clamp(t, 0, 1);\n        let chunk = this.length - 1;\n        let tc = 1 / (this.length - 1);\n        let idx = Math.floor(t / tc);\n        return Geom.interpolate(this[idx], this[Math.min(this.length - 1, idx + 1)], (t - idx * tc) * chunk);\n    }\n    moveBy(...args) {\n        return this.add(...args);\n    }\n    moveTo(...args) {\n        let d = new Pt(Util.getArgs(args)).subtract(this[0]);\n        this.moveBy(d);\n        return this;\n    }\n    scale(scale, anchor) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Geom.scale(this[i], scale, anchor || this[0]);\n        }\n        return this;\n    }\n    rotate2D(angle, anchor, axis) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Geom.rotate2D(this[i], angle, anchor || this[0], axis);\n        }\n        return this;\n    }\n    shear2D(scale, anchor, axis) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Geom.shear2D(this[i], scale, anchor || this[0], axis);\n        }\n        return this;\n    }\n    reflect2D(line, axis) {\n        for (let i = 0, len = this.length; i < len; i++) {\n            Geom.reflect2D(this[i], line, axis);\n        }\n        return this;\n    }\n    sortByDimension(dim, desc = false) {\n        return this.sort((a, b) => (desc) ? b[dim] - a[dim] : a[dim] - b[dim]);\n    }\n    forEachPt(ptFn, ...args) {\n        if (!this[0][ptFn]) {\n            Util.warn(`${ptFn} is not a function of Pt`);\n            return this;\n        }\n        for (let i = 0, len = this.length; i < len; i++) {\n            this[i] = this[i][ptFn](...args);\n        }\n        return this;\n    }\n    add(...args) {\n        return this.forEachPt(\"add\", ...args);\n    }\n    subtract(...args) {\n        return this.forEachPt(\"subtract\", ...args);\n    }\n    multiply(...args) {\n        return this.forEachPt(\"multiply\", ...args);\n    }\n    divide(...args) {\n        return this.forEachPt(\"divide\", ...args);\n    }\n    $matrixAdd(g) {\n        return Mat.add(this, g);\n    }\n    $matrixMultiply(g, transposed = false, elementwise = false) {\n        return Mat.multiply(this, g, transposed, elementwise);\n    }\n    zipSlice(index, defaultValue = false) {\n        return Mat.zipSlice(this, index, defaultValue);\n    }\n    $zip(defaultValue = undefined, useLongest = false) {\n        return Mat.zip(this, defaultValue, useLongest);\n    }\n    toString() {\n        return \"Group[ \" + this.reduce((p, c) => p + c.toString() + \" \", \"\") + \" ]\";\n    }\n}\nexport class Bound extends Group {\n    constructor(...args) {\n        super(...args);\n        this._center = new Pt();\n        this._size = new Pt();\n        this._topLeft = new Pt();\n        this._bottomRight = new Pt();\n        this._inited = false;\n        this.init();\n    }\n    static fromBoundingRect(rect) {\n        let b = new Bound(new Pt(rect.left || 0, rect.top || 0), new Pt(rect.right || 0, rect.bottom || 0));\n        if (rect.width && rect.height)\n            b.size = new Pt(rect.width, rect.height);\n        return b;\n    }\n    static fromGroup(g) {\n        if (g.length < 2)\n            throw new Error(\"Cannot create a Bound from a group that has less than 2 Pt\");\n        return new Bound(g[0], g[g.length - 1]);\n    }\n    init() {\n        if (this.p1) {\n            this._size = this.p1.clone();\n            this._inited = true;\n        }\n        if (this.p1 && this.p2) {\n            let a = this.p1;\n            let b = this.p2;\n            this.topLeft = a.$min(b);\n            this._bottomRight = a.$max(b);\n            this._updateSize();\n            this._inited = true;\n        }\n    }\n    clone() {\n        return new Bound(this._topLeft.clone(), this._bottomRight.clone());\n    }\n    _updateSize() {\n        this._size = this._bottomRight.$subtract(this._topLeft).abs();\n        this._updateCenter();\n    }\n    _updateCenter() {\n        this._center = this._size.$multiply(0.5).add(this._topLeft);\n    }\n    _updatePosFromTop() {\n        this._bottomRight = this._topLeft.$add(this._size);\n        this._updateCenter();\n    }\n    _updatePosFromBottom() {\n        this._topLeft = this._bottomRight.$subtract(this._size);\n        this._updateCenter();\n    }\n    _updatePosFromCenter() {\n        let half = this._size.$multiply(0.5);\n        this._topLeft = this._center.$subtract(half);\n        this._bottomRight = this._center.$add(half);\n    }\n    get size() { return new Pt(this._size); }\n    set size(p) {\n        this._size = new Pt(p);\n        this._updatePosFromTop();\n    }\n    get center() { return new Pt(this._center); }\n    set center(p) {\n        this._center = new Pt(p);\n        this._updatePosFromCenter();\n    }\n    get topLeft() { return new Pt(this._topLeft); }\n    set topLeft(p) {\n        this._topLeft = new Pt(p);\n        this[0] = this._topLeft;\n        this._updateSize();\n    }\n    get bottomRight() { return new Pt(this._bottomRight); }\n    set bottomRight(p) {\n        this._bottomRight = new Pt(p);\n        this[1] = this._bottomRight;\n        this._updateSize();\n    }\n    get width() { return (this._size.length > 0) ? this._size.x : 0; }\n    set width(w) {\n        this._size.x = w;\n        this._updatePosFromTop();\n    }\n    get height() { return (this._size.length > 1) ? this._size.y : 0; }\n    set height(h) {\n        this._size.y = h;\n        this._updatePosFromTop();\n    }\n    get depth() { return (this._size.length > 2) ? this._size.z : 0; }\n    set depth(d) {\n        this._size.z = d;\n        this._updatePosFromTop();\n    }\n    get x() { return this.topLeft.x; }\n    get y() { return this.topLeft.y; }\n    get z() { return this.topLeft.z; }\n    get inited() { return this._inited; }\n    update() {\n        this._topLeft = this[0];\n        this._bottomRight = this[1];\n        this._updateSize();\n        return this;\n    }\n}\n//# sourceMappingURL=Pt.js.map","import { Rectangle, Circle } from \"./Op\";\nexport var UIShape;\n(function (UIShape) {\n    UIShape[UIShape[\"Rectangle\"] = 0] = \"Rectangle\";\n    UIShape[UIShape[\"Circle\"] = 1] = \"Circle\";\n    UIShape[UIShape[\"Polygon\"] = 2] = \"Polygon\";\n    UIShape[UIShape[\"Polyline\"] = 3] = \"Polyline\";\n    UIShape[UIShape[\"Line\"] = 4] = \"Line\";\n})(UIShape || (UIShape = {}));\nexport const UIPointerActions = {\n    up: \"up\", down: \"down\", move: \"move\", drag: \"drag\", drop: \"drop\", over: \"over\", out: \"out\"\n};\nexport class UI {\n    constructor(group, shape, states, id) {\n        this.group = group;\n        this.shape = shape;\n        this._id = id;\n        this._states = states;\n        this._actions = {};\n    }\n    get id() { return this._id; }\n    set id(d) { this._id = d; }\n    state(key) {\n        return this._states[key] || false;\n    }\n    on(key, fn) {\n        this._actions[key] = fn;\n        return this;\n    }\n    off(key) {\n        delete this._actions[key];\n        return this;\n    }\n    listen(key, p) {\n        if (this._actions[key] !== undefined) {\n            if (this._trigger(p)) {\n                this._actions[key](p, this, key);\n                return true;\n            }\n        }\n        return false;\n    }\n    render(fn) {\n        fn(this.group, this._states);\n    }\n    _trigger(p) {\n        let fn = null;\n        if (this.shape === UIShape.Rectangle) {\n            fn = Rectangle.withinBound;\n        }\n        else if (this.shape === UIShape.Circle) {\n            fn = Circle.withinBound;\n        }\n        else if (this.shape === UIShape.Polygon) {\n            fn = Rectangle.withinBound;\n        }\n        else {\n            return false;\n        }\n        return fn(this.group, p);\n    }\n}\nexport class UIButton extends UI {\n    constructor(group, shape, states, id) {\n        super(group, shape, states, id);\n        this._clicks = 0;\n    }\n    get clicks() { return this._clicks; }\n    onClick(fn) {\n        this._clicks++;\n        this.on(UIPointerActions.up, fn);\n    }\n    onHover(over, out) {\n        this.on(UIPointerActions.over, over);\n        this.on(UIPointerActions.out, out);\n    }\n}\n//# sourceMappingURL=UI.js.map","import { Pt, Bound } from \"./Pt\";\nimport { UIPointerActions as UIA } from \"./UI\";\nexport class Space {\n    constructor() {\n        this.id = \"space\";\n        this.bound = new Bound();\n        this._time = { prev: 0, diff: 0, end: -1 };\n        this.players = {};\n        this.playerCount = 0;\n        this._animID = -1;\n        this._pause = false;\n        this._refresh = undefined;\n        this._pointer = new Pt();\n        this._isReady = false;\n        this._playing = false;\n    }\n    refresh(b) {\n        this._refresh = b;\n        return this;\n    }\n    add(p) {\n        let player = (typeof p == \"function\") ? { animate: p } : p;\n        let k = this.playerCount++;\n        let pid = this.id + k;\n        this.players[pid] = player;\n        player.animateID = pid;\n        if (player.resize && this.bound.inited)\n            player.resize(this.bound);\n        if (this._refresh === undefined)\n            this._refresh = true;\n        return this;\n    }\n    remove(player) {\n        delete this.players[player.animateID];\n        return this;\n    }\n    removeAll() {\n        this.players = {};\n        return this;\n    }\n    play(time = 0) {\n        this._animID = requestAnimationFrame(this.play.bind(this));\n        if (this._pause)\n            return this;\n        this._time.diff = time - this._time.prev;\n        this._time.prev = time;\n        try {\n            this.playItems(time);\n        }\n        catch (err) {\n            cancelAnimationFrame(this._animID);\n            this._playing = false;\n            throw err;\n        }\n        return this;\n    }\n    replay() {\n        this._time.end = -1;\n        this.play();\n    }\n    playItems(time) {\n        this._playing = true;\n        if (this._refresh)\n            this.clear();\n        if (this._isReady) {\n            for (let k in this.players) {\n                if (this.players[k].animate)\n                    this.players[k].animate(time, this._time.diff, this);\n            }\n        }\n        if (this._time.end >= 0 && time > this._time.end) {\n            cancelAnimationFrame(this._animID);\n            this._playing = false;\n        }\n    }\n    pause(toggle = false) {\n        this._pause = (toggle) ? !this._pause : true;\n        return this;\n    }\n    resume() {\n        this._pause = false;\n        return this;\n    }\n    stop(t = 0) {\n        this._time.end = t;\n        return this;\n    }\n    playOnce(duration = 5000) {\n        this.play();\n        this.stop(duration);\n        return this;\n    }\n    render(context) {\n        if (this._renderFunc)\n            this._renderFunc(context, this);\n        return this;\n    }\n    set customRendering(f) { this._renderFunc = f; }\n    get customRendering() { return this._renderFunc; }\n    get isPlaying() { return this._playing; }\n    get outerBound() { return this.bound.clone(); }\n    get innerBound() { return new Bound(Pt.make(this.size.length, 0), this.size.clone()); }\n    get size() { return this.bound.size.clone(); }\n    get center() { return this.size.divide(2); }\n    get width() { return this.bound.width; }\n    get height() { return this.bound.height; }\n}\nexport class MultiTouchSpace extends Space {\n    constructor() {\n        super(...arguments);\n        this._pressed = false;\n        this._dragged = false;\n        this._hasMouse = false;\n        this._hasTouch = false;\n    }\n    get pointer() {\n        let p = this._pointer.clone();\n        p.id = this._pointer.id;\n        return p;\n    }\n    bindCanvas(evt, callback) {\n        this._canvas.addEventListener(evt, callback);\n    }\n    unbindCanvas(evt, callback) {\n        this._canvas.removeEventListener(evt, callback);\n    }\n    bindMouse(_bind = true) {\n        if (_bind) {\n            this.bindCanvas(\"mousedown\", this._mouseDown.bind(this));\n            this.bindCanvas(\"mouseup\", this._mouseUp.bind(this));\n            this.bindCanvas(\"mouseover\", this._mouseOver.bind(this));\n            this.bindCanvas(\"mouseout\", this._mouseOut.bind(this));\n            this.bindCanvas(\"mousemove\", this._mouseMove.bind(this));\n            this._hasMouse = true;\n        }\n        else {\n            this.unbindCanvas(\"mousedown\", this._mouseDown.bind(this));\n            this.unbindCanvas(\"mouseup\", this._mouseUp.bind(this));\n            this.unbindCanvas(\"mouseover\", this._mouseOver.bind(this));\n            this.unbindCanvas(\"mouseout\", this._mouseOut.bind(this));\n            this.unbindCanvas(\"mousemove\", this._mouseMove.bind(this));\n            this._hasMouse = false;\n        }\n        return this;\n    }\n    bindTouch(_bind = true) {\n        if (_bind) {\n            this.bindCanvas(\"touchstart\", this._mouseDown.bind(this));\n            this.bindCanvas(\"touchend\", this._mouseUp.bind(this));\n            this.bindCanvas(\"touchmove\", this._touchMove.bind(this));\n            this.bindCanvas(\"touchcancel\", this._mouseOut.bind(this));\n            this._hasTouch = true;\n        }\n        else {\n            this.unbindCanvas(\"touchstart\", this._mouseDown.bind(this));\n            this.unbindCanvas(\"touchend\", this._mouseUp.bind(this));\n            this.unbindCanvas(\"touchmove\", this._touchMove.bind(this));\n            this.unbindCanvas(\"touchcancel\", this._mouseOut.bind(this));\n            this._hasTouch = false;\n        }\n        return this;\n    }\n    touchesToPoints(evt, which = \"touches\") {\n        if (!evt || !evt[which])\n            return [];\n        let ts = [];\n        for (var i = 0; i < evt[which].length; i++) {\n            let t = evt[which].item(i);\n            ts.push(new Pt(t.pageX - this.bound.topLeft.x, t.pageY - this.bound.topLeft.y));\n        }\n        return ts;\n    }\n    _mouseAction(type, evt) {\n        let px = 0, py = 0;\n        if (evt instanceof MouseEvent) {\n            for (let k in this.players) {\n                if (this.players.hasOwnProperty(k)) {\n                    let v = this.players[k];\n                    px = evt.pageX - this.outerBound.x;\n                    py = evt.pageY - this.outerBound.y;\n                    if (v.action)\n                        v.action(type, px, py, evt);\n                }\n            }\n        }\n        else {\n            for (let k in this.players) {\n                if (this.players.hasOwnProperty(k)) {\n                    let v = this.players[k];\n                    let c = evt.changedTouches && evt.changedTouches.length > 0;\n                    let touch = evt.changedTouches.item(0);\n                    px = (c) ? touch.pageX - this.outerBound.x : 0;\n                    py = (c) ? touch.pageY - this.outerBound.y : 0;\n                    if (v.action)\n                        v.action(type, px, py, evt);\n                }\n            }\n        }\n        if (type) {\n            this._pointer.to(px, py);\n            this._pointer.id = type;\n        }\n    }\n    _mouseDown(evt) {\n        this._mouseAction(UIA.down, evt);\n        this._pressed = true;\n        return false;\n    }\n    _mouseUp(evt) {\n        this._mouseAction(UIA.up, evt);\n        if (this._dragged)\n            this._mouseAction(UIA.down, evt);\n        this._pressed = false;\n        this._dragged = false;\n        return false;\n    }\n    _mouseMove(evt) {\n        this._mouseAction(UIA.move, evt);\n        if (this._pressed) {\n            this._dragged = true;\n            this._mouseAction(UIA.drag, evt);\n        }\n        return false;\n    }\n    _mouseOver(evt) {\n        this._mouseAction(UIA.over, evt);\n        return false;\n    }\n    _mouseOut(evt) {\n        this._mouseAction(UIA.out, evt);\n        if (this._dragged)\n            this._mouseAction(UIA.drop, evt);\n        this._dragged = false;\n        return false;\n    }\n    _touchMove(evt) {\n        this._mouseMove(evt);\n        evt.preventDefault();\n        return false;\n    }\n}\n//# sourceMappingURL=Space.js.map","import { Util } from \"./Util\";\nexport class Form {\n    constructor() {\n        this._ready = false;\n    }\n    get ready() { return this._ready; }\n    static _checkSize(pts, required = 2) {\n        if (pts.length < required) {\n            Util.warn(\"Requires 2 or more Pts in this Group.\");\n            return false;\n        }\n        return true;\n    }\n}\nexport class VisualForm extends Form {\n    constructor() {\n        super(...arguments);\n        this._filled = true;\n        this._stroked = true;\n        this._font = new Font(14, \"sans-serif\");\n    }\n    get filled() { return this._filled; }\n    set filled(b) { this._filled = b; }\n    get stroked() { return this._stroked; }\n    set stroked(b) { this._stroked = b; }\n    get currentFont() { return this._font; }\n    _multiple(groups, shape, ...rest) {\n        if (!groups)\n            return this;\n        for (let i = 0, len = groups.length; i < len; i++) {\n            this[shape](groups[i], ...rest);\n        }\n        return this;\n    }\n    fill(c) {\n        return this;\n    }\n    fillOnly(c) {\n        this.stroke(false);\n        return this.fill(c);\n    }\n    stroke(c, width, linejoin, linecap) {\n        return this;\n    }\n    strokeOnly(c, width, linejoin, linecap) {\n        this.fill(false);\n        return this.stroke(c, width, linejoin, linecap);\n    }\n    points(pts, radius, shape) {\n        if (!pts)\n            return;\n        for (let i = 0, len = pts.length; i < len; i++) {\n            this.point(pts[i], radius, shape);\n        }\n        return this;\n    }\n    circles(groups) {\n        return this._multiple(groups, \"circle\");\n    }\n    squares(groups) {\n        return this._multiple(groups, \"square\");\n    }\n    lines(groups) {\n        return this._multiple(groups, \"line\");\n    }\n    polygons(groups) {\n        return this._multiple(groups, \"polygon\");\n    }\n    rects(groups) {\n        return this._multiple(groups, \"rect\");\n    }\n}\nexport class Font {\n    constructor(size = 12, face = \"sans-serif\", weight = \"\", style = \"\", lineHeight = 1.5) {\n        this.size = size;\n        this.face = face;\n        this.style = style;\n        this.weight = weight;\n        this.lineHeight = lineHeight;\n    }\n    get value() { return `${this.style} ${this.weight} ${this.size}px/${this.lineHeight} ${this.face}`; }\n    toString() { return this.value; }\n}\n//# sourceMappingURL=Form.js.map","import { Pt } from \"./Pt\";\nexport class Typography {\n    static textWidthEstimator(fn, samples = [\"M\", \"n\", \".\"], distribution = [0.06, 0.8, 0.14]) {\n        let m = samples.map(fn);\n        let avg = new Pt(distribution).dot(m);\n        return (str) => str.length * avg;\n    }\n    static truncate(fn, str, width, tail = \"\") {\n        let trim = Math.floor(str.length * Math.min(1, width / fn(str)));\n        if (trim < str.length) {\n            trim = Math.max(0, trim - tail.length);\n            return [str.substr(0, trim) + tail, trim];\n        }\n        else {\n            return [str, str.length];\n        }\n    }\n    static fontSizeToBox(box, ratio = 1, byHeight = true) {\n        let i = byHeight ? 1 : 0;\n        let h = (box[1][i] - box[0][i]);\n        let f = ratio * h;\n        return function (b) {\n            let nh = (b[1][i] - b[0][i]) / h;\n            return f * nh;\n        };\n    }\n    static fontSizeToThreshold(threshold, direction = 0) {\n        return function (defaultSize, val) {\n            let d = defaultSize * val / threshold;\n            if (direction < 0)\n                return Math.min(d, defaultSize);\n            if (direction > 0)\n                return Math.max(d, defaultSize);\n            return d;\n        };\n    }\n}\n//# sourceMappingURL=Typography.js.map","import { MultiTouchSpace } from './Space';\nimport { VisualForm, Font } from \"./Form\";\nimport { Pt, Group, Bound } from \"./Pt\";\nimport { Const } from \"./Util\";\nimport { Typography as Typo } from \"./Typography\";\nimport { Rectangle } from './Op';\nexport class CanvasSpace extends MultiTouchSpace {\n    constructor(elem, callback) {\n        super();\n        this._pixelScale = 1;\n        this._autoResize = true;\n        this._bgcolor = \"#e1e9f0\";\n        this._offscreen = false;\n        this._initialResize = false;\n        var _selector = null;\n        var _existed = false;\n        this.id = \"pt\";\n        if (elem instanceof Element) {\n            _selector = elem;\n            this.id = \"pts_existing_space\";\n        }\n        else {\n            let id = elem;\n            id = (elem[0] === \"#\" || elem[0] === \".\") ? elem : \"#\" + elem;\n            _selector = document.querySelector(id);\n            _existed = true;\n            this.id = id.substr(1);\n        }\n        if (!_selector) {\n            this._container = this._createElement(\"div\", this.id + \"_container\");\n            this._canvas = this._createElement(\"canvas\", this.id);\n            this._container.appendChild(this._canvas);\n            document.body.appendChild(this._container);\n            _existed = false;\n        }\n        else if (_selector.nodeName.toLowerCase() != \"canvas\") {\n            this._container = _selector;\n            this._canvas = this._createElement(\"canvas\", this.id + \"_canvas\");\n            this._container.appendChild(this._canvas);\n            this._initialResize = true;\n        }\n        else {\n            this._canvas = _selector;\n            this._container = _selector.parentElement;\n            this._autoResize = false;\n        }\n        setTimeout(this._ready.bind(this, callback), 100);\n        this._ctx = this._canvas.getContext('2d');\n    }\n    _createElement(elem = \"div\", id) {\n        let d = document.createElement(elem);\n        d.setAttribute(\"id\", id);\n        return d;\n    }\n    _ready(callback) {\n        if (!this._container)\n            throw new Error(`Cannot initiate #${this.id} element`);\n        this._isReady = true;\n        this._resizeHandler(null);\n        this.clear(this._bgcolor);\n        this._canvas.dispatchEvent(new Event(\"ready\"));\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                if (this.players[k].start)\n                    this.players[k].start(this.bound.clone(), this);\n            }\n        }\n        this._pointer = this.center;\n        this._initialResize = false;\n        if (callback)\n            callback(this.bound, this._canvas);\n    }\n    setup(opt) {\n        if (opt.bgcolor)\n            this._bgcolor = opt.bgcolor;\n        this.autoResize = (opt.resize != undefined) ? opt.resize : false;\n        if (opt.retina !== false) {\n            let r1 = window.devicePixelRatio || 1;\n            let r2 = this._ctx.webkitBackingStorePixelRatio || this._ctx.mozBackingStorePixelRatio || this._ctx.msBackingStorePixelRatio || this._ctx.oBackingStorePixelRatio || this._ctx.backingStorePixelRatio || 1;\n            this._pixelScale = Math.max(1, r1 / r2);\n        }\n        if (opt.offscreen) {\n            this._offscreen = true;\n            this._offCanvas = this._createElement(\"canvas\", this.id + \"_offscreen\");\n            this._offCtx = this._offCanvas.getContext('2d');\n        }\n        else {\n            this._offscreen = false;\n        }\n        return this;\n    }\n    set autoResize(auto) {\n        this._autoResize = auto;\n        if (auto) {\n            window.addEventListener('resize', this._resizeHandler.bind(this));\n        }\n        else {\n            window.removeEventListener('resize', this._resizeHandler.bind(this));\n        }\n    }\n    get autoResize() { return this._autoResize; }\n    resize(b, evt) {\n        this.bound = b;\n        this._canvas.width = this.bound.size.x * this._pixelScale;\n        this._canvas.height = this.bound.size.y * this._pixelScale;\n        this._canvas.style.width = Math.floor(this.bound.size.x) + \"px\";\n        this._canvas.style.height = Math.floor(this.bound.size.y) + \"px\";\n        if (this._offscreen) {\n            this._offCanvas.width = this.bound.size.x * this._pixelScale;\n            this._offCanvas.height = this.bound.size.y * this._pixelScale;\n        }\n        if (this._pixelScale != 1) {\n            this._ctx.scale(this._pixelScale, this._pixelScale);\n            this._ctx.translate(0.5, 0.5);\n            if (this._offscreen) {\n                this._offCtx.scale(this._pixelScale, this._pixelScale);\n                this._offCtx.translate(0.5, 0.5);\n            }\n        }\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                let p = this.players[k];\n                if (p.resize)\n                    p.resize(this.bound, evt);\n            }\n        }\n        this.render(this._ctx);\n        if (evt && !this.isPlaying)\n            this.playOnce(0);\n        return this;\n    }\n    _resizeHandler(evt) {\n        let b = (this._autoResize || this._initialResize) ? this._container.getBoundingClientRect() : this._canvas.getBoundingClientRect();\n        if (b) {\n            let box = Bound.fromBoundingRect(b);\n            box.center = box.center.add(window.pageXOffset, window.pageYOffset);\n            this.resize(box, evt);\n        }\n    }\n    set background(bg) { this._bgcolor = bg; }\n    get background() { return this._bgcolor; }\n    get pixelScale() {\n        return this._pixelScale;\n    }\n    get hasOffscreen() {\n        return this._offscreen;\n    }\n    get offscreenCtx() { return this._offCtx; }\n    get offscreenCanvas() { return this._offCanvas; }\n    getForm() { return new CanvasForm(this); }\n    get element() {\n        return this._canvas;\n    }\n    get parent() {\n        return this._container;\n    }\n    get ready() {\n        return this._isReady;\n    }\n    get ctx() { return this._ctx; }\n    clear(bg) {\n        if (bg)\n            this._bgcolor = bg;\n        let lastColor = this._ctx.fillStyle;\n        if (this._bgcolor && this._bgcolor != \"transparent\") {\n            this._ctx.fillStyle = this._bgcolor;\n            this._ctx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n        }\n        else {\n            this._ctx.clearRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n        }\n        this._ctx.fillStyle = lastColor;\n        return this;\n    }\n    clearOffscreen(bg) {\n        if (this._offscreen) {\n            if (bg) {\n                this._offCtx.fillStyle = bg;\n                this._offCtx.fillRect(-1, -1, this._canvas.width + 1, this._canvas.height + 1);\n            }\n            else {\n                this._offCtx.clearRect(-1, -1, this._offCanvas.width + 1, this._offCanvas.height + 1);\n            }\n        }\n        return this;\n    }\n    playItems(time) {\n        if (this._isReady) {\n            this._ctx.save();\n            if (this._offscreen)\n                this._offCtx.save();\n            super.playItems(time);\n            this._ctx.restore();\n            if (this._offscreen)\n                this._offCtx.restore();\n            this.render(this._ctx);\n        }\n    }\n}\nexport class CanvasForm extends VisualForm {\n    constructor(space) {\n        super();\n        this._style = {\n            fillStyle: \"#f03\", strokeStyle: \"#fff\",\n            lineWidth: 1, lineJoin: \"bevel\", lineCap: \"butt\",\n        };\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx = this._space.ctx;\n                this._ctx.fillStyle = this._style.fillStyle;\n                this._ctx.strokeStyle = this._style.strokeStyle;\n                this._ctx.lineJoin = \"bevel\";\n                this._ctx.font = this._font.value;\n                this._ready = true;\n            } });\n    }\n    get space() { return this._space; }\n    useOffscreen(off = true, clear = false) {\n        if (clear)\n            this._space.clearOffscreen((typeof clear == \"string\") ? clear : null);\n        this._ctx = (this._space.hasOffscreen && off) ? this._space.offscreenCtx : this._space.ctx;\n        return this;\n    }\n    renderOffscreen(offset = [0, 0]) {\n        if (this._space.hasOffscreen) {\n            this._space.ctx.drawImage(this._space.offscreenCanvas, offset[0], offset[1], this._space.width, this._space.height);\n        }\n    }\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.filled = c;\n        }\n        else {\n            this.filled = true;\n            this._style.fillStyle = c;\n            this._ctx.fillStyle = c;\n        }\n        return this;\n    }\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.stroked = c;\n        }\n        else {\n            this.stroked = true;\n            this._style.strokeStyle = c;\n            this._ctx.strokeStyle = c;\n            if (width) {\n                this._ctx.lineWidth = width;\n                this._style.lineWidth = width;\n            }\n            if (linejoin) {\n                this._ctx.lineJoin = linejoin;\n                this._style.lineJoin = linejoin;\n            }\n            if (linecap) {\n                this._ctx.lineCap = linecap;\n                this._style.lineCap = linecap;\n            }\n        }\n        return this;\n    }\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n            this._ctx.font = this._font.value;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        if (this._estimateTextWidth)\n            this.fontWidthEstimate(true);\n        return this;\n    }\n    fontWidthEstimate(estimate = true) {\n        this._estimateTextWidth = (estimate) ? Typo.textWidthEstimator(((c) => this._ctx.measureText(c).width)) : undefined;\n        return this;\n    }\n    getTextWidth(c) {\n        return (!this._estimateTextWidth) ? this._ctx.measureText(c + \" .\").width : this._estimateTextWidth(c);\n    }\n    _textTruncate(str, width, tail = \"\") {\n        return Typo.truncate(this.getTextWidth.bind(this), str, width, tail);\n    }\n    _textAlign(box, vertical, offset, center) {\n        if (!center)\n            center = Rectangle.center(box);\n        var px = box[0][0];\n        if (this._ctx.textAlign == \"end\" || this._ctx.textAlign == \"right\") {\n            px = box[1][0];\n        }\n        else if (this._ctx.textAlign == \"center\" || this._ctx.textAlign == \"middle\") {\n            px = center[0];\n        }\n        var py = center[1];\n        if (vertical == \"top\" || vertical == \"start\") {\n            py = box[0][1];\n        }\n        else if (vertical == \"end\" || vertical == \"bottom\") {\n            py = box[1][1];\n        }\n        return (offset) ? new Pt(px + offset[0], py + offset[1]) : new Pt(px, py);\n    }\n    reset() {\n        for (let k in this._style) {\n            if (this._style.hasOwnProperty(k)) {\n                this._ctx[k] = this._style[k];\n            }\n        }\n        this._font = new Font();\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    _paint() {\n        if (this._filled)\n            this._ctx.fill();\n        if (this._stroked)\n            this._ctx.stroke();\n    }\n    point(p, radius = 5, shape = \"square\") {\n        if (!p)\n            return;\n        if (!CanvasForm[shape])\n            throw new Error(`${shape} is not a static function of CanvasForm`);\n        CanvasForm[shape](this._ctx, p, radius);\n        this._paint();\n        return this;\n    }\n    static circle(ctx, pt, radius = 10) {\n        if (!pt)\n            return;\n        ctx.beginPath();\n        ctx.arc(pt[0], pt[1], radius, 0, Const.two_pi, false);\n        ctx.closePath();\n    }\n    circle(pts) {\n        CanvasForm.circle(this._ctx, pts[0], pts[1][0]);\n        this._paint();\n        return this;\n    }\n    static arc(ctx, pt, radius, startAngle, endAngle, cc) {\n        if (!pt)\n            return;\n        ctx.beginPath();\n        ctx.arc(pt[0], pt[1], radius, startAngle, endAngle, cc);\n    }\n    arc(pt, radius, startAngle, endAngle, cc) {\n        CanvasForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n        this._paint();\n        return this;\n    }\n    static square(ctx, pt, halfsize) {\n        if (!pt)\n            return;\n        let x1 = pt[0] - halfsize;\n        let y1 = pt[1] - halfsize;\n        let x2 = pt[0] + halfsize;\n        let y2 = pt[1] + halfsize;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x1, y2);\n        ctx.lineTo(x2, y2);\n        ctx.lineTo(x2, y1);\n        ctx.closePath();\n    }\n    square(pt, halfsize) {\n        CanvasForm.square(this._ctx, pt, halfsize);\n        this._paint();\n        return this;\n    }\n    static line(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            if (pts[i])\n                ctx.lineTo(pts[i][0], pts[i][1]);\n        }\n    }\n    line(pts) {\n        CanvasForm.line(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    static polygon(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        for (let i = 1, len = pts.length; i < len; i++) {\n            if (pts[i])\n                ctx.lineTo(pts[i][0], pts[i][1]);\n        }\n        ctx.closePath();\n    }\n    polygon(pts) {\n        CanvasForm.polygon(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    static rect(ctx, pts) {\n        if (pts.length < 2)\n            return;\n        ctx.beginPath();\n        ctx.moveTo(pts[0][0], pts[0][1]);\n        ctx.lineTo(pts[0][0], pts[1][1]);\n        ctx.lineTo(pts[1][0], pts[1][1]);\n        ctx.lineTo(pts[1][0], pts[0][1]);\n        ctx.closePath();\n    }\n    rect(pts) {\n        CanvasForm.rect(this._ctx, pts);\n        this._paint();\n        return this;\n    }\n    static image(ctx, img, target = new Pt(), orig) {\n        if (typeof target[0] === \"number\") {\n            ctx.drawImage(img, target[0], target[1]);\n        }\n        else {\n            let t = target;\n            if (orig) {\n                ctx.drawImage(img, orig[0][0], orig[0][1], orig[1][0] - orig[0][0], orig[1][1] - orig[0][1], t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]);\n            }\n            else {\n                ctx.drawImage(img, t[0][0], t[0][1], t[1][0] - t[0][0], t[1][1] - t[0][1]);\n            }\n        }\n    }\n    image(img, target, original) {\n        CanvasForm.image(this._ctx, img, target, original);\n        return this;\n    }\n    static text(ctx, pt, txt, maxWidth) {\n        if (!pt)\n            return;\n        ctx.fillText(txt, pt[0], pt[1], maxWidth);\n    }\n    text(pt, txt, maxWidth) {\n        CanvasForm.text(this._ctx, pt, txt, maxWidth);\n        return this;\n    }\n    textBox(box, txt, verticalAlign = \"middle\", tail = \"\", overrideBaseline = true) {\n        if (overrideBaseline)\n            this._ctx.textBaseline = verticalAlign;\n        let size = Rectangle.size(box);\n        let t = this._textTruncate(txt, size[0], tail);\n        this.text(this._textAlign(box, verticalAlign), t[0]);\n        return this;\n    }\n    paragraphBox(box, txt, lineHeight = 1.2, verticalAlign = \"top\", crop = true) {\n        let size = Rectangle.size(box);\n        this._ctx.textBaseline = \"top\";\n        let lstep = this._font.size * lineHeight;\n        let nextLine = (sub, buffer = [], cc = 0) => {\n            if (!sub)\n                return buffer;\n            if (crop && cc * lstep > size[1] - lstep * 2)\n                return buffer;\n            if (cc > 10000)\n                throw new Error(\"max recursion reached (10000)\");\n            let t = this._textTruncate(sub, size[0], \"\");\n            let newln = t[0].indexOf(\"\\n\");\n            if (newln >= 0) {\n                buffer.push(t[0].substr(0, newln));\n                return nextLine(sub.substr(newln + 1), buffer, cc + 1);\n            }\n            let dt = t[0].lastIndexOf(\" \") + 1;\n            if (dt <= 0 || t[1] === sub.length)\n                dt = undefined;\n            let line = t[0].substr(0, dt);\n            buffer.push(line);\n            return (t[1] <= 0 || t[1] === sub.length) ? buffer : nextLine(sub.substr((dt || t[1])), buffer, cc + 1);\n        };\n        let lines = nextLine(txt);\n        let lsize = lines.length * lstep;\n        let lbox = box;\n        if (verticalAlign == \"middle\" || verticalAlign == \"center\") {\n            let lpad = (size[1] - lsize) / 2;\n            if (crop)\n                lpad = Math.max(0, lpad);\n            lbox = new Group(box[0].$add(0, lpad), box[1].$subtract(0, lpad));\n        }\n        else if (verticalAlign == \"bottom\") {\n            lbox = new Group(box[0].$add(0, size[1] - lsize), box[1]);\n        }\n        else {\n            lbox = new Group(box[0], box[0].$add(size[0], lsize));\n        }\n        let center = Rectangle.center(lbox);\n        for (let i = 0, len = lines.length; i < len; i++) {\n            this.text(this._textAlign(lbox, \"top\", [0, i * lstep], center), lines[i]);\n        }\n        return this;\n    }\n    alignText(alignment = \"left\", baseline = \"alphabetic\") {\n        if (baseline == \"center\")\n            baseline = \"middle\";\n        if (baseline == \"baseline\")\n            baseline = \"alphabetic\";\n        this._ctx.textAlign = alignment;\n        this._ctx.textBaseline = baseline;\n        return this;\n    }\n    log(txt) {\n        let w = this._ctx.measureText(txt).width + 20;\n        this.stroke(false).fill(\"rgba(0,0,0,.4)\").rect([[0, 0], [w, 20]]);\n        this.fill(\"#fff\").text([10, 14], txt);\n        return this;\n    }\n}\n//# sourceMappingURL=Canvas.js.map","import { Pt, Group } from \"./Pt\";\nimport { Line, Triangle } from \"./Op\";\nimport { Const } from \"./Util\";\nimport { Num, Geom } from \"./Num\";\nimport { Vec } from \"./LinearAlgebra\";\nexport class Create {\n    static distributeRandom(bound, count, dimensions = 2) {\n        let pts = new Group();\n        for (let i = 0; i < count; i++) {\n            let p = [bound.x + Math.random() * bound.width];\n            if (dimensions > 1)\n                p.push(bound.y + Math.random() * bound.height);\n            if (dimensions > 2)\n                p.push(bound.z + Math.random() * bound.depth);\n            pts.push(new Pt(p));\n        }\n        return pts;\n    }\n    static distributeLinear(line, count) {\n        let ln = Line.subpoints(line, count - 2);\n        ln.unshift(line[0]);\n        ln.push(line[line.length - 1]);\n        return ln;\n    }\n    static gridPts(bound, columns, rows, orientation = [0.5, 0.5]) {\n        if (columns === 0 || rows === 0)\n            throw new Error(\"grid columns and rows cannot be 0\");\n        let unit = bound.size.$subtract(1).$divide(columns, rows);\n        let offset = unit.$multiply(orientation);\n        let g = new Group();\n        for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < columns; c++) {\n                g.push(bound.topLeft.$add(unit.$multiply(c, r)).add(offset));\n            }\n        }\n        return g;\n    }\n    static gridCells(bound, columns, rows) {\n        if (columns === 0 || rows === 0)\n            throw new Error(\"grid columns and rows cannot be 0\");\n        let unit = bound.size.$subtract(1).divide(columns, rows);\n        let g = [];\n        for (let r = 0; r < rows; r++) {\n            for (let c = 0; c < columns; c++) {\n                g.push(new Group(bound.topLeft.$add(unit.$multiply(c, r)), bound.topLeft.$add(unit.$multiply(c, r).add(unit))));\n            }\n        }\n        return g;\n    }\n    static radialPts(center, radius, count) {\n        let g = new Group();\n        let a = Const.two_pi / count;\n        for (let i = 0; i < count; i++) {\n            g.push(new Pt(center).toAngle(a * i - Const.half_pi, radius, true));\n        }\n        return g;\n    }\n    static noisePts(pts, dx = 0.01, dy = 0.01, rows = 0, columns = 0) {\n        let seed = Math.random();\n        let g = new Group();\n        for (let i = 0, len = pts.length; i < len; i++) {\n            let np = new Noise(pts[i]);\n            let r = (rows && rows > 0) ? Math.floor(i / rows) : i;\n            let c = (columns && columns > 0) ? i % columns : i;\n            np.initNoise(dx * c, dy * r);\n            np.seed(seed);\n            g.push(np);\n        }\n        return g;\n    }\n    static delaunay(pts) {\n        return Delaunay.from(pts);\n    }\n}\nconst grad3 = [\n    [1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],\n    [1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],\n    [0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]\n];\nconst permTable = [151, 160, 137, 91, 90, 15,\n    131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,\n    190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,\n    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,\n    77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,\n    102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,\n    135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,\n    5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,\n    223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,\n    129, 22, 39, 253, 9, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,\n    251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,\n    49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,\n    138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180\n];\nexport class Noise extends Pt {\n    constructor(...args) {\n        super(...args);\n        this.perm = [];\n        this._n = new Pt(0.01, 0.01);\n        this.perm = permTable.concat(permTable);\n    }\n    initNoise(...args) {\n        this._n = new Pt(...args);\n    }\n    step(x = 0, y = 0) {\n        this._n.add(x, y);\n    }\n    seed(s) {\n        if (s > 0 && s < 1)\n            s *= 65536;\n        s = Math.floor(s);\n        if (s < 256)\n            s |= s << 8;\n        for (let i = 0; i < 255; i++) {\n            let v = (i & 1) ? permTable[i] ^ (s & 255) : permTable[i] ^ ((s >> 8) & 255);\n            this.perm[i] = this.perm[i + 256] = v;\n        }\n    }\n    noise2D() {\n        let i = Math.max(0, Math.floor(this._n[0])) % 255;\n        let j = Math.max(0, Math.floor(this._n[1])) % 255;\n        let x = (this._n[0] % 255) - i;\n        let y = (this._n[1] % 255) - j;\n        let n00 = Vec.dot(grad3[(i + this.perm[j]) % 12], [x, y, 0]);\n        let n01 = Vec.dot(grad3[(i + this.perm[j + 1]) % 12], [x, y - 1, 0]);\n        let n10 = Vec.dot(grad3[(i + 1 + this.perm[j]) % 12], [x - 1, y, 0]);\n        let n11 = Vec.dot(grad3[(i + 1 + this.perm[j + 1]) % 12], [x - 1, y - 1, 0]);\n        let _fade = (f) => f * f * f * (f * (f * 6 - 15) + 10);\n        let tx = _fade(x);\n        return Num.lerp(Num.lerp(n00, n10, tx), Num.lerp(n01, n11, tx), _fade(y));\n    }\n}\nexport class Delaunay extends Group {\n    constructor() {\n        super(...arguments);\n        this._mesh = [];\n    }\n    delaunay(triangleOnly = true) {\n        if (this.length < 3)\n            return [];\n        this._mesh = [];\n        let n = this.length;\n        let indices = [];\n        for (let i = 0; i < n; i++)\n            indices[i] = i;\n        indices.sort((i, j) => this[j][0] - this[i][0]);\n        let pts = this.slice();\n        let st = this._superTriangle();\n        pts = pts.concat(st);\n        let opened = [this._circum(n, n + 1, n + 2, st)];\n        let closed = [];\n        let tris = [];\n        for (let i = 0, len = indices.length; i < len; i++) {\n            let c = indices[i];\n            let edges = [];\n            let j = opened.length;\n            if (!this._mesh[c])\n                this._mesh[c] = {};\n            while (j--) {\n                let circum = opened[j];\n                let radius = circum.circle[1][0];\n                let d = pts[c].$subtract(circum.circle[0]);\n                if (d[0] > 0 && d[0] * d[0] > radius * radius) {\n                    closed.push(circum);\n                    tris.push(circum.triangle);\n                    opened.splice(j, 1);\n                    continue;\n                }\n                if (d[0] * d[0] + d[1] * d[1] - radius * radius > Const.epsilon) {\n                    continue;\n                }\n                edges.push(circum.i, circum.j, circum.j, circum.k, circum.k, circum.i);\n                opened.splice(j, 1);\n            }\n            Delaunay._dedupe(edges);\n            j = edges.length;\n            while (j > 1) {\n                opened.push(this._circum(edges[--j], edges[--j], c, false, pts));\n            }\n        }\n        for (let i = 0, len = opened.length; i < len; i++) {\n            let o = opened[i];\n            if (o.i < n && o.j < n && o.k < n) {\n                closed.push(o);\n                tris.push(o.triangle);\n                this._cache(o);\n            }\n        }\n        return (triangleOnly) ? tris : closed;\n    }\n    voronoi() {\n        let vs = [];\n        let n = this._mesh;\n        for (let i = 0, len = n.length; i < len; i++) {\n            vs.push(this.neighborPts(i, true));\n        }\n        return vs;\n    }\n    mesh() {\n        return this._mesh;\n    }\n    neighborPts(i, sort = false) {\n        let cs = new Group();\n        let n = this._mesh;\n        for (let k in n[i]) {\n            if (n[i].hasOwnProperty(k))\n                cs.push(n[i][k].circle[0]);\n        }\n        return (sort) ? Geom.sortEdges(cs) : cs;\n    }\n    neighbors(i) {\n        let cs = [];\n        let n = this._mesh;\n        for (let k in n[i]) {\n            if (n[i].hasOwnProperty(k))\n                cs.push(n[i][k]);\n        }\n        return cs;\n    }\n    _cache(o) {\n        this._mesh[o.i][`${Math.min(o.j, o.k)}-${Math.max(o.j, o.k)}`] = o;\n        this._mesh[o.j][`${Math.min(o.i, o.k)}-${Math.max(o.i, o.k)}`] = o;\n        this._mesh[o.k][`${Math.min(o.i, o.j)}-${Math.max(o.i, o.j)}`] = o;\n    }\n    _superTriangle() {\n        let minPt = this[0];\n        let maxPt = this[0];\n        for (let i = 1, len = this.length; i < len; i++) {\n            minPt = minPt.$min(this[i]);\n            maxPt = maxPt.$max(this[i]);\n        }\n        let d = maxPt.$subtract(minPt);\n        let mid = minPt.$add(maxPt).divide(2);\n        let dmax = Math.max(d[0], d[1]);\n        return new Group(mid.$subtract(20 * dmax, dmax), mid.$add(0, 20 * dmax), mid.$add(20 * dmax, -dmax));\n    }\n    _triangle(i, j, k, pts = this) {\n        return new Group(pts[i], pts[j], pts[k]);\n    }\n    _circum(i, j, k, tri, pts = this) {\n        let t = tri || this._triangle(i, j, k, pts);\n        return {\n            i: i,\n            j: j,\n            k: k,\n            triangle: t,\n            circle: Triangle.circumcircle(t)\n        };\n    }\n    static _dedupe(edges) {\n        let j = edges.length;\n        while (j > 1) {\n            let b = edges[--j];\n            let a = edges[--j];\n            let i = j;\n            while (i > 1) {\n                let n = edges[--i];\n                let m = edges[--i];\n                if ((a == m && b == n) || (a == n && b == m)) {\n                    edges.splice(j, 2);\n                    edges.splice(i, 2);\n                    break;\n                }\n            }\n        }\n        return edges;\n    }\n}\n//# sourceMappingURL=Create.js.map","import { Pt, Group } from \"./Pt\";\nimport { Util } from \"./Util\";\nimport { Num, Geom } from \"./Num\";\nexport class Color extends Pt {\n    constructor(...args) {\n        super(...args);\n        this._mode = \"rgb\";\n        this._isNorm = false;\n    }\n    static from(...args) {\n        let p = [1, 1, 1, 1];\n        let c = Util.getArgs(args);\n        for (let i = 0, len = p.length; i < len; i++) {\n            if (i < c.length)\n                p[i] = c[i];\n        }\n        return new Color(p);\n    }\n    static fromHex(hex) {\n        if (hex[0] == \"#\")\n            hex = hex.substr(1);\n        if (hex.length <= 3) {\n            let fn = (i) => hex[i] || \"F\";\n            hex = `${fn(0)}${fn(0)}${fn(1)}${fn(1)}${fn(2)}${fn(2)}`;\n        }\n        let alpha = 1;\n        if (hex.length === 8) {\n            alpha = hex.substr(6) && 0xFF / 255;\n            hex = hex.substring(0, 6);\n        }\n        let hexVal = parseInt(hex, 16);\n        return new Color(hexVal >> 16, hexVal >> 8 & 0xFF, hexVal & 0xFF, alpha);\n    }\n    static rgb(...args) { return Color.from(...args).toMode(\"rgb\"); }\n    static hsl(...args) { return Color.from(...args).toMode(\"hsl\"); }\n    static hsb(...args) { return Color.from(...args).toMode(\"hsb\"); }\n    static lab(...args) { return Color.from(...args).toMode(\"lab\"); }\n    static lch(...args) { return Color.from(...args).toMode(\"lch\"); }\n    static luv(...args) { return Color.from(...args).toMode(\"luv\"); }\n    static xyz(...args) { return Color.from(...args).toMode(\"xyz\"); }\n    static maxValues(mode) { return Color.ranges[mode].zipSlice(1).$take([0, 1, 2]); }\n    get hex() { return this.toString(\"hex\"); }\n    get rgb() { return this.toString(\"rgb\"); }\n    get rgba() { return this.toString(\"rgba\"); }\n    clone() {\n        let c = new Color(this);\n        c.toMode(this._mode);\n        return c;\n    }\n    toMode(mode, convert = false) {\n        if (convert) {\n            let fname = this._mode.toUpperCase() + \"to\" + mode.toUpperCase();\n            if (Color[fname]) {\n                this.to(Color[fname](this, this._isNorm, this._isNorm));\n            }\n            else {\n                throw new Error(\"Cannot convert color with \" + fname);\n            }\n        }\n        this._mode = mode;\n        return this;\n    }\n    get mode() { return this._mode; }\n    get r() { return this[0]; }\n    set r(n) { this[0] = n; }\n    get g() { return this[1]; }\n    set g(n) { this[1] = n; }\n    get b() { return this[2]; }\n    set b(n) { this[2] = n; }\n    get h() { return (this._mode == \"lch\") ? this[2] : this[0]; }\n    set h(n) {\n        let i = (this._mode == \"lch\") ? 2 : 0;\n        this[i] = n;\n    }\n    get s() { return this[1]; }\n    set s(n) { this[1] = n; }\n    get l() { return (this._mode == \"hsl\") ? this[2] : this[0]; }\n    set l(n) {\n        let i = (this._mode == \"hsl\") ? 2 : 0;\n        this[i] = n;\n    }\n    get a() { return this[1]; }\n    set a(n) { this[1] = n; }\n    get c() { return this[1]; }\n    set c(n) { this[1] = n; }\n    get u() { return this[1]; }\n    set u(n) { this[1] = n; }\n    get v() { return this[2]; }\n    set v(n) { this[2] = n; }\n    get alpha() { return (this.length > 3) ? this[3] : 1; }\n    get normalized() { return this._isNorm; }\n    set normalized(b) { this._isNorm = b; }\n    normalize(toNorm = true) {\n        if (this._isNorm == toNorm)\n            return this;\n        let ranges = Color.ranges[this._mode];\n        for (let i = 0; i < 3; i++) {\n            this[i] = (!toNorm)\n                ? Num.mapToRange(this[i], 0, 1, ranges[i][0], ranges[i][1])\n                : Num.mapToRange(this[i], ranges[i][0], ranges[i][1], 0, 1);\n        }\n        this._isNorm = toNorm;\n        return this;\n    }\n    $normalize(toNorm = true) { return this.clone().normalize(toNorm); }\n    toString(format = \"mode\") {\n        if (format == \"hex\") {\n            let _hex = (n) => {\n                let s = Math.floor(n).toString(16);\n                return (s.length < 2) ? '0' + s : s;\n            };\n            return `#${_hex(this[0])}${_hex(this[1])}${_hex(this[2])}`;\n        }\n        else if (format == \"rgba\") {\n            return `rgba(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])},${this.alpha}`;\n        }\n        else if (format == \"rgb\") {\n            return `rgb(${Math.floor(this[0])},${Math.floor(this[1])},${Math.floor(this[2])}`;\n        }\n        else {\n            return `${this._mode}(${this[0]},${this[1]},${this[2]},${this.alpha})`;\n        }\n    }\n    static RGBtoHSL(rgb, normalizedInput = false, normalizedOutput = false) {\n        let [r, g, b] = (!normalizedInput) ? rgb.$normalize() : rgb;\n        let max = Math.max(r, g, b);\n        let min = Math.min(r, g, b);\n        let h = (max + min) / 2;\n        let s = h;\n        let l = h;\n        if (max == min) {\n            h = 0;\n            s = 0;\n        }\n        else {\n            let d = max - min;\n            s = (l > 0.5) ? d / (2 - max - min) : d / (max + min);\n            h = 0;\n            if (max === r) {\n                h = (g - b) / d + ((g < b) ? 6 : 0);\n            }\n            else if (max === g) {\n                h = (b - r) / d + 2;\n            }\n            else if (max === b) {\n                h = (r - g) / d + 4;\n            }\n        }\n        return Color.hsl(((normalizedOutput) ? h / 60 : h * 60), s, l, rgb.alpha);\n    }\n    static HSLtoRGB(hsl, normalizedInput = false, normalizedOutput = false) {\n        let [h, s, l] = hsl;\n        if (!normalizedInput)\n            h = h / 360;\n        if (s == 0)\n            return Color.rgb(l * 255, l * 255, l * 255, hsl.alpha);\n        let q = (l <= 0.5) ? l * (1 + s) : l + s - (l * s);\n        let p = 2 * l - q;\n        let convert = (t) => {\n            t = (t < 0) ? t + 1 : (t > 1) ? t - 1 : t;\n            if (t * 6 < 1) {\n                return p + (q - p) * t * 6;\n            }\n            else if (t * 2 < 1) {\n                return q;\n            }\n            else if (t * 3 < 2) {\n                return p + (q - p) * ((2 / 3) - t) * 6;\n            }\n            else {\n                return p;\n            }\n        };\n        let sc = (normalizedOutput) ? 1 : 255;\n        return Color.rgb(sc * convert((h + 1 / 3)), sc * convert(h), sc * convert((h - 1 / 3)), hsl.alpha);\n    }\n    static RGBtoHSB(rgb, normalizedInput = false, normalizedOutput = false) {\n        let [r, g, b] = (!normalizedInput) ? rgb.$normalize() : rgb;\n        let max = Math.max(r, g, b);\n        let min = Math.min(r, g, b);\n        let d = max - min;\n        let h = 0;\n        let s = (max === 0) ? 0 : d / max;\n        let v = max;\n        if (max != min) {\n            if (max === r) {\n                h = (g - b) / d + ((g < b) ? 6 : 0);\n            }\n            else if (max === g) {\n                h = (b - r) / d + 2;\n            }\n            else if (max === b) {\n                h = (r - g) / d + 4;\n            }\n        }\n        return Color.hsb(((normalizedOutput) ? h / 60 : h * 60), s, v, rgb.alpha);\n    }\n    static HSBtoRGB(hsb, normalizedInput = false, normalizedOutput = false) {\n        let [h, s, v] = hsb;\n        if (!normalizedInput)\n            h = h / 360;\n        let i = Math.floor(h * 6);\n        let f = h * 6 - i;\n        let p = v * (1 - s);\n        let q = v * (1 - f * s);\n        let t = v * (1 - (1 - f) * s);\n        let pick = [\n            [v, t, p], [q, v, p], [p, v, t],\n            [p, q, v], [t, p, v], [v, p, q]\n        ];\n        let c = pick[i % 6];\n        let sc = (normalizedOutput) ? 1 : 255;\n        return Color.rgb(sc * c[0], sc * c[1], sc * c[2], hsb.alpha);\n    }\n    static RGBtoLAB(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.XYZtoLAB(Color.RGBtoXYZ(c), false, normalizedOutput);\n    }\n    static LABtoRGB(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        return Color.XYZtoRGB(Color.LABtoXYZ(c), false, normalizedOutput);\n    }\n    static RGBtoLCH(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.LABtoLCH(Color.RGBtoLAB(c), false, normalizedOutput);\n    }\n    static LCHtoRGB(lch, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lch.$normalize(false) : lch;\n        return Color.LABtoRGB(Color.LCHtoLAB(c), false, normalizedOutput);\n    }\n    static RGBtoLUV(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? rgb.$normalize(false) : rgb;\n        return Color.XYZtoLUV(Color.RGBtoXYZ(c), false, normalizedOutput);\n    }\n    static LUVtoRGB(luv, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? luv.$normalize(false) : luv;\n        return Color.XYZtoRGB(Color.LUVtoXYZ(c), false, normalizedOutput);\n    }\n    static RGBtoXYZ(rgb, normalizedInput = false, normalizedOutput = false) {\n        let c = (!normalizedInput) ? rgb.$normalize() : rgb.clone();\n        for (let i = 0; i < 3; i++) {\n            c[i] = (c[i] > 0.04045) ? Math.pow((c[i] + 0.055) / 1.055, 2.4) : c[i] / 12.92;\n            if (!normalizedOutput)\n                c[i] = c[i] * 100;\n        }\n        let cc = Color.xyz(c[0] * 0.4124564 + c[1] * 0.3575761 + c[2] * 0.1804375, c[0] * 0.2126729 + c[1] * 0.7151522 + c[2] * 0.0721750, c[0] * 0.0193339 + c[1] * 0.1191920 + c[2] * 0.9503041, rgb.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static XYZtoRGB(xyz, normalizedInput = false, normalizedOutput = false) {\n        let [x, y, z] = (!normalizedInput) ? xyz.$normalize() : xyz;\n        let rgb = [\n            x * 3.2404542 + y * -1.5371385 + z * -0.4985314,\n            x * -0.9692660 + y * 1.8760108 + z * 0.0415560,\n            x * 0.0556434 + y * -0.2040259 + z * 1.0572252\n        ];\n        for (let i = 0; i < 3; i++) {\n            rgb[i] = (rgb[i] < 0) ? 0 : (rgb[i] > 0.0031308) ? (1.055 * Math.pow(rgb[i], 1 / 2.4) - 0.055) : (12.92 * rgb[i]);\n            rgb[i] = Math.max(0, Math.min(1, rgb[i]));\n            if (!normalizedOutput)\n                rgb[i] = Math.round(rgb[i] * 255);\n        }\n        let cc = Color.rgb(rgb[0], rgb[1], rgb[2], xyz.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static XYZtoLAB(xyz, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? xyz.$normalize(false) : xyz.clone();\n        c.divide(Color.D65);\n        let fn = (n) => (n > 0.008856) ? Math.pow(n, 1 / 3) : (7.787 * n) + 16 / 116;\n        let cy = fn(c[1]);\n        let cc = Color.lab((116 * cy) - 16, 500 * (fn(c[0]) - cy), 200 * (cy - fn(c[2])), xyz.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static LABtoXYZ(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        let y = (c[0] + 16) / 116;\n        let x = (c[1] / 500) + y;\n        let z = y - c[2] / 200;\n        let fn = (n) => {\n            let nnn = n * n * n;\n            return (nnn > 0.008856) ? nnn : (n - 16 / 116) / 7.787;\n        };\n        let d = Color.D65;\n        let cc = Color.xyz(Math.max(0, d[0] * fn(x)), Math.max(0, d[1] * fn(y)), Math.max(0, d[2] * fn(z)), lab.alpha);\n        return (normalizedOutput) ? cc.normalize() : cc;\n    }\n    static XYZtoLUV(xyz, normalizedInput = false, normalizedOutput = false) {\n        let [x, y, z] = (normalizedInput) ? xyz.$normalize(false) : xyz;\n        let u = (4 * x) / (x + (15 * y) + (3 * z));\n        let v = (9 * y) / (x + (15 * y) + (3 * z));\n        y = y / 100;\n        y = (y > 0.008856) ? Math.pow(y, 1 / 3) : (7.787 * y + 16 / 116);\n        let refU = (4 * Color.D65[0]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let refV = (9 * Color.D65[1]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let L = (116 * y) - 16;\n        return Color.luv(L, 13 * L * (u - refU), 13 * L * (v - refV), xyz.alpha);\n    }\n    static LUVtoXYZ(luv, normalizedInput = false, normalizedOutput = false) {\n        let [l, u, v] = (normalizedInput) ? luv.$normalize(false) : luv;\n        let y = (l + 16) / 116;\n        let cubeY = y * y * y;\n        y = (cubeY > 0.008856) ? cubeY : (y - 16 / 116) / 7.787;\n        let refU = (4 * Color.D65[0]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        let refV = (9 * Color.D65[1]) / (Color.D65[0] + (15 * Color.D65[1]) + (3 * Color.D65[2]));\n        u = u / (13 * l) + refU;\n        v = v / (13 * l) + refV;\n        y = y * 100;\n        let x = -1 * (9 * y * u) / ((u - 4) * v - u * v);\n        let z = (9 * y - (15 * v * y) - (v * x)) / (3 * v);\n        return Color.xyz(x, y, z, luv.alpha);\n    }\n    static LABtoLCH(lab, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lab.$normalize(false) : lab;\n        let h = Geom.toDegree(Geom.boundRadian(Math.atan2(c[2], c[1])));\n        return Color.lch(c[0], Math.sqrt(c[1] * c[1] + c[2] * c[2]), h, lab.alpha);\n    }\n    static LCHtoLAB(lch, normalizedInput = false, normalizedOutput = false) {\n        let c = (normalizedInput) ? lch.$normalize(false) : lch;\n        let rad = Geom.toRadian(c[2]);\n        return Color.lab(c[0], Math.cos(rad) * c[1], Math.sin(rad) * c[1], lch.alpha);\n    }\n}\nColor.D65 = new Pt(95.047, 100, 108.883, 1);\nColor.ranges = {\n    rgb: new Group(new Pt(0, 255), new Pt(0, 255), new Pt(0, 255)),\n    hsl: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n    hsb: new Group(new Pt(0, 360), new Pt(0, 1), new Pt(0, 1)),\n    lab: new Group(new Pt(0, 100), new Pt(-128, 127), new Pt(-128, 127)),\n    lch: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 360)),\n    luv: new Group(new Pt(0, 100), new Pt(-134, 220), new Pt(-140, 122)),\n    xyz: new Group(new Pt(0, 100), new Pt(0, 100), new Pt(0, 100))\n};\n//# sourceMappingURL=Color.js.map","import { MultiTouchSpace } from './Space';\nimport { VisualForm, Font } from \"./Form\";\nimport { Util } from './Util';\nimport { Pt, Bound } from './Pt';\nexport class DOMSpace extends MultiTouchSpace {\n    constructor(elem, callback) {\n        super();\n        this.id = \"domspace\";\n        this._autoResize = true;\n        this._bgcolor = \"#e1e9f0\";\n        this._css = {};\n        var _selector = null;\n        var _existed = false;\n        this.id = \"pts\";\n        if (elem instanceof Element) {\n            _selector = elem;\n            this.id = \"pts_existing_space\";\n        }\n        else {\n            _selector = document.querySelector(elem);\n            _existed = true;\n            this.id = elem.substr(1);\n        }\n        if (!_selector) {\n            this._container = DOMSpace.createElement(\"div\", \"pts_container\");\n            this._canvas = DOMSpace.createElement(\"div\", \"pts_element\");\n            this._container.appendChild(this._canvas);\n            document.body.appendChild(this._container);\n            _existed = false;\n        }\n        else {\n            this._canvas = _selector;\n            this._container = _selector.parentElement;\n        }\n        setTimeout(this._ready.bind(this, callback), 50);\n    }\n    static createElement(elem = \"div\", id, appendTo) {\n        let d = document.createElement(elem);\n        if (id)\n            d.setAttribute(\"id\", id);\n        if (appendTo && appendTo.appendChild)\n            appendTo.appendChild(d);\n        return d;\n    }\n    _ready(callback) {\n        if (!this._container)\n            throw new Error(`Cannot initiate #${this.id} element`);\n        this._isReady = true;\n        this._resizeHandler(null);\n        this.clear(this._bgcolor);\n        this._canvas.dispatchEvent(new Event(\"ready\"));\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                if (this.players[k].start)\n                    this.players[k].start(this.bound.clone(), this);\n            }\n        }\n        this._pointer = this.center;\n        this.refresh(false);\n        if (callback)\n            callback(this.bound, this._canvas);\n    }\n    setup(opt) {\n        if (opt.bgcolor) {\n            this._bgcolor = opt.bgcolor;\n        }\n        this.autoResize = (opt.resize != undefined) ? opt.resize : false;\n        return this;\n    }\n    getForm() {\n        return null;\n    }\n    set autoResize(auto) {\n        this._autoResize = auto;\n        if (auto) {\n            window.addEventListener('resize', this._resizeHandler.bind(this));\n        }\n        else {\n            delete this._css['width'];\n            delete this._css['height'];\n            window.removeEventListener('resize', this._resizeHandler.bind(this));\n        }\n    }\n    get autoResize() { return this._autoResize; }\n    resize(b, evt) {\n        this.bound = b;\n        this.styles({ width: `${b.width}px`, height: `${b.height}px` }, true);\n        for (let k in this.players) {\n            if (this.players.hasOwnProperty(k)) {\n                let p = this.players[k];\n                if (p.resize)\n                    p.resize(this.bound, evt);\n            }\n        }\n        return this;\n    }\n    _resizeHandler(evt) {\n        let b = Bound.fromBoundingRect(this._container.getBoundingClientRect());\n        if (this._autoResize) {\n            this.styles({ width: \"100%\", height: \"100%\" }, true);\n        }\n        else {\n            this.styles({ width: `${b.width}px`, height: `${b.height}px` }, true);\n        }\n        this.resize(b, evt);\n    }\n    get element() {\n        return this._canvas;\n    }\n    get parent() {\n        return this._container;\n    }\n    get ready() { return this._isReady; }\n    clear(bg) {\n        if (bg)\n            this.background = bg;\n        this._canvas.innerHTML = \"\";\n        return this;\n    }\n    set background(bg) {\n        this._bgcolor = bg;\n        this._container.style.backgroundColor = this._bgcolor;\n    }\n    get background() { return this._bgcolor; }\n    style(key, val, update = false) {\n        this._css[key] = val;\n        if (update)\n            this._canvas.style[key] = val;\n        return this;\n    }\n    styles(styles, update = false) {\n        for (let k in styles) {\n            if (styles.hasOwnProperty(k))\n                this.style(k, styles[k], update);\n        }\n        return this;\n    }\n    static setAttr(elem, data) {\n        for (let k in data) {\n            if (data.hasOwnProperty(k)) {\n                elem.setAttribute(k, data[k]);\n            }\n        }\n        return elem;\n    }\n    static getInlineStyles(data) {\n        let str = \"\";\n        for (let k in data) {\n            if (data.hasOwnProperty(k)) {\n                if (data[k])\n                    str += `${k}: ${data[k]}; `;\n            }\n        }\n        return str;\n    }\n}\nexport class HTMLSpace extends DOMSpace {\n    getForm() {\n        return new HTMLForm(this);\n    }\n    static htmlElement(parent, name, id, autoClass = true) {\n        if (!parent || !parent.appendChild)\n            throw new Error(\"parent is not a valid DOM element\");\n        let elem = document.querySelector(`#${id}`);\n        if (!elem) {\n            elem = document.createElement(name);\n            elem.setAttribute(\"id\", id);\n            if (autoClass)\n                elem.setAttribute(\"class\", id.substring(0, id.indexOf(\"-\")));\n            parent.appendChild(elem);\n        }\n        return elem;\n    }\n    remove(player) {\n        let temp = this._container.querySelectorAll(\".\" + HTMLForm.scopeID(player));\n        temp.forEach((el) => {\n            el.parentNode.removeChild(el);\n        });\n        return super.remove(player);\n    }\n    removeAll() {\n        this._container.innerHTML = \"\";\n        return super.removeAll();\n    }\n}\nexport class HTMLForm extends VisualForm {\n    constructor(space) {\n        super();\n        this._ctx = {\n            group: null,\n            groupID: \"pts\",\n            groupCount: 0,\n            currentID: \"pts0\",\n            currentClass: \"\",\n            style: {\n                \"filled\": true,\n                \"stroked\": true,\n                \"background\": \"#f03\",\n                \"border-color\": \"#fff\",\n                \"color\": \"#000\",\n                \"border-width\": \"1px\",\n                \"border-radius\": \"0\",\n                \"border-style\": \"solid\",\n                \"position\": \"absolute\",\n                \"top\": 0,\n                \"left\": 0,\n                \"width\": 0,\n                \"height\": 0\n            },\n            font: \"11px sans-serif\",\n            fontSize: 11,\n            fontFamily: \"sans-serif\"\n        };\n        this._ready = false;\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx.group = this._space.element;\n                this._ctx.groupID = \"pts_dom_\" + (HTMLForm.groupID++);\n                this._ready = true;\n            } });\n    }\n    get space() { return this._space; }\n    styleTo(k, v, unit = '') {\n        if (this._ctx.style[k] === undefined)\n            throw new Error(`${k} style property doesn't exist`);\n        this._ctx.style[k] = `${v}${unit}`;\n    }\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"filled\", c);\n            if (!c)\n                this.styleTo(\"background\", \"transparent\");\n        }\n        else {\n            this.styleTo(\"filled\", true);\n            this.styleTo(\"background\", c);\n        }\n        return this;\n    }\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"stroked\", c);\n            if (!c)\n                this.styleTo(\"border-width\", 0);\n        }\n        else {\n            this.styleTo(\"stroked\", true);\n            this.styleTo(\"border-color\", c);\n            this.styleTo(\"border-width\", (width || 1) + \"px\");\n        }\n        return this;\n    }\n    fillText(c) {\n        this.styleTo(\"color\", c);\n        return this;\n    }\n    cls(c) {\n        if (typeof c == \"boolean\") {\n            this._ctx.currentClass = \"\";\n        }\n        else {\n            this._ctx.currentClass = c;\n        }\n        return this;\n    }\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n            this._ctx.font = this._font.value;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        return this;\n    }\n    reset() {\n        this._ctx.style = {\n            \"filled\": true, \"stroked\": true,\n            \"background\": \"#f03\", \"border-color\": \"#fff\",\n            \"border-width\": \"1px\"\n        };\n        this._font = new Font(14, \"sans-serif\");\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    updateScope(group_id, group) {\n        this._ctx.group = group;\n        this._ctx.groupID = group_id;\n        this._ctx.groupCount = 0;\n        this.nextID();\n        return this._ctx;\n    }\n    scope(item) {\n        if (!item || item.animateID == null)\n            throw new Error(\"item not defined or not yet added to Space\");\n        return this.updateScope(HTMLForm.scopeID(item), this.space.element);\n    }\n    nextID() {\n        this._ctx.groupCount++;\n        this._ctx.currentID = `${this._ctx.groupID}-${this._ctx.groupCount}`;\n        return this._ctx.currentID;\n    }\n    static getID(ctx) {\n        return ctx.currentID || `p-${HTMLForm.domID++}`;\n    }\n    static scopeID(item) {\n        return `item-${item.animateID}`;\n    }\n    static style(elem, styles) {\n        let st = [];\n        if (!styles[\"filled\"])\n            st.push(\"background: none\");\n        if (!styles[\"stroked\"])\n            st.push(\"border: none\");\n        for (let k in styles) {\n            if (styles.hasOwnProperty(k) && k != \"filled\" && k != \"stroked\") {\n                let v = styles[k];\n                if (v) {\n                    if (!styles[\"filled\"] && k.indexOf('background') === 0) {\n                        continue;\n                    }\n                    else if (!styles[\"stroked\"] && k.indexOf('border-width') === 0) {\n                        continue;\n                    }\n                    else {\n                        st.push(`${k}: ${v}`);\n                    }\n                }\n            }\n        }\n        return HTMLSpace.setAttr(elem, { style: st.join(\";\") });\n    }\n    static rectStyle(ctx, pt, size) {\n        ctx.style[\"left\"] = pt[0] + \"px\";\n        ctx.style[\"top\"] = pt[1] + \"px\";\n        ctx.style[\"width\"] = size[0] + \"px\";\n        ctx.style[\"height\"] = size[1] + \"px\";\n        return ctx;\n    }\n    static point(ctx, pt, radius = 5, shape = \"square\") {\n        if (shape === \"circle\") {\n            return HTMLForm.circle(ctx, pt, radius);\n        }\n        else {\n            return HTMLForm.square(ctx, pt, radius);\n        }\n    }\n    point(pt, radius = 5, shape = \"square\") {\n        this.nextID();\n        if (shape == \"circle\")\n            this.styleTo(\"border-radius\", \"100%\");\n        HTMLForm.point(this._ctx, pt, radius, shape);\n        return this;\n    }\n    static circle(ctx, pt, radius = 10) {\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, { class: `pts-form pts-circle ${ctx.currentClass}` });\n        HTMLForm.rectStyle(ctx, new Pt(pt).$subtract(radius), new Pt(radius * 2, radius * 2));\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    circle(pts) {\n        this.nextID();\n        this.styleTo(\"border-radius\", \"100%\");\n        HTMLForm.circle(this._ctx, pts[0], pts[1][0]);\n        return this;\n    }\n    static square(ctx, pt, halfsize) {\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, { class: `pts-form pts-square ${ctx.currentClass}` });\n        HTMLForm.rectStyle(ctx, new Pt(pt).$subtract(halfsize), new Pt(halfsize * 2, halfsize * 2));\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    square(pt, halfsize) {\n        this.nextID();\n        HTMLForm.square(this._ctx, pt, halfsize);\n        return this;\n    }\n    static rect(ctx, pts) {\n        if (!this._checkSize(pts))\n            return;\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, { class: `pts-form pts-rect ${ctx.currentClass}` });\n        HTMLForm.rectStyle(ctx, pts[0], pts[1]);\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    rect(pts) {\n        this.nextID();\n        this.styleTo(\"border-radius\", \"0\");\n        HTMLForm.rect(this._ctx, pts);\n        return this;\n    }\n    static text(ctx, pt, txt) {\n        let elem = HTMLSpace.htmlElement(ctx.group, \"div\", HTMLForm.getID(ctx));\n        HTMLSpace.setAttr(elem, {\n            position: 'absolute',\n            class: `pts-form pts-text ${ctx.currentClass}`,\n            left: pt[0],\n            top: pt[1],\n        });\n        elem.textContent = txt;\n        HTMLForm.style(elem, ctx.style);\n        return elem;\n    }\n    text(pt, txt) {\n        this.nextID();\n        HTMLForm.text(this._ctx, pt, txt);\n        return this;\n    }\n    log(txt) {\n        this.fill(\"#000\").stroke(\"#fff\", 0.5).text([10, 14], txt);\n        return this;\n    }\n    arc(pt, radius, startAngle, endAngle, cc) {\n        Util.warn(\"arc is not implemented in HTMLForm\");\n        return this;\n    }\n    line(pts) {\n        Util.warn(\"line is not implemented in HTMLForm\");\n        return this;\n    }\n    polygon(pts) {\n        Util.warn(\"polygon is not implemented in HTMLForm\");\n        return this;\n    }\n}\nHTMLForm.groupID = 0;\nHTMLForm.domID = 0;\n//# sourceMappingURL=Dom.js.map","import { VisualForm, Font } from \"./Form\";\nimport { Geom } from './Num';\nimport { Const } from './Util';\nimport { Pt, Group } from './Pt';\nimport { Rectangle } from \"./Op\";\nimport { DOMSpace } from \"./Dom\";\nexport class SVGSpace extends DOMSpace {\n    constructor(elem, callback) {\n        super(elem, callback);\n        this.id = \"svgspace\";\n        this._bgcolor = \"#999\";\n        if (this._canvas.nodeName.toLowerCase() != \"svg\") {\n            let s = SVGSpace.svgElement(this._canvas, \"svg\", `${this.id}_svg`);\n            this._container = this._canvas;\n            this._canvas = s;\n        }\n    }\n    getForm() { return new SVGForm(this); }\n    get element() {\n        return this._canvas;\n    }\n    resize(b, evt) {\n        super.resize(b, evt);\n        SVGSpace.setAttr(this.element, {\n            \"viewBox\": `0 0 ${this.bound.width} ${this.bound.height}`,\n            \"width\": `${this.bound.width}`,\n            \"height\": `${this.bound.height}`,\n            \"xmlns\": \"http://www.w3.org/2000/svg\",\n            \"version\": \"1.1\"\n        });\n        return this;\n    }\n    static svgElement(parent, name, id) {\n        if (!parent || !parent.appendChild)\n            throw new Error(\"parent is not a valid DOM element\");\n        let elem = document.querySelector(`#${id}`);\n        if (!elem) {\n            elem = document.createElementNS(\"http://www.w3.org/2000/svg\", name);\n            elem.setAttribute(\"id\", id);\n            parent.appendChild(elem);\n        }\n        return elem;\n    }\n    remove(player) {\n        let temp = this._container.querySelectorAll(\".\" + SVGForm.scopeID(player));\n        temp.forEach((el) => {\n            el.parentNode.removeChild(el);\n        });\n        return super.remove(player);\n    }\n    removeAll() {\n        this._container.innerHTML = \"\";\n        return super.removeAll();\n    }\n}\nexport class SVGForm extends VisualForm {\n    constructor(space) {\n        super();\n        this._ctx = {\n            group: null,\n            groupID: \"pts\",\n            groupCount: 0,\n            currentID: \"pts0\",\n            currentClass: \"\",\n            style: {\n                \"filled\": true,\n                \"stroked\": true,\n                \"fill\": \"#f03\",\n                \"stroke\": \"#fff\",\n                \"stroke-width\": 1,\n                \"stroke-linejoin\": \"bevel\",\n                \"stroke-linecap\": \"sqaure\"\n            },\n            font: \"11px sans-serif\",\n            fontSize: 11,\n            fontFamily: \"sans-serif\"\n        };\n        this._ready = false;\n        this._space = space;\n        this._space.add({ start: () => {\n                this._ctx.group = this._space.element;\n                this._ctx.groupID = \"pts_svg_\" + (SVGForm.groupID++);\n                this._ready = true;\n            } });\n    }\n    get space() { return this._space; }\n    styleTo(k, v) {\n        if (this._ctx.style[k] === undefined)\n            throw new Error(`${k} style property doesn't exist`);\n        this._ctx.style[k] = v;\n    }\n    fill(c) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"filled\", c);\n        }\n        else {\n            this.styleTo(\"filled\", true);\n            this.styleTo(\"fill\", c);\n        }\n        return this;\n    }\n    stroke(c, width, linejoin, linecap) {\n        if (typeof c == \"boolean\") {\n            this.styleTo(\"stroked\", c);\n        }\n        else {\n            this.styleTo(\"stroked\", true);\n            this.styleTo(\"stroke\", c);\n            if (width)\n                this.styleTo(\"stroke-width\", width);\n            if (linejoin)\n                this.styleTo(\"stroke-linejoin\", linejoin);\n            if (linecap)\n                this.styleTo(\"stroke-linecap\", linecap);\n        }\n        return this;\n    }\n    cls(c) {\n        if (typeof c == \"boolean\") {\n            this._ctx.currentClass = \"\";\n        }\n        else {\n            this._ctx.currentClass = c;\n        }\n        return this;\n    }\n    font(sizeOrFont, weight, style, lineHeight, family) {\n        if (typeof sizeOrFont == \"number\") {\n            this._font.size = sizeOrFont;\n            if (family)\n                this._font.face = family;\n            if (weight)\n                this._font.weight = weight;\n            if (style)\n                this._font.style = style;\n            if (lineHeight)\n                this._font.lineHeight = lineHeight;\n            this._ctx.font = this._font.value;\n        }\n        else {\n            this._font = sizeOrFont;\n        }\n        return this;\n    }\n    reset() {\n        this._ctx.style = {\n            \"filled\": true, \"stroked\": true,\n            \"fill\": \"#f03\", \"stroke\": \"#fff\",\n            \"stroke-width\": 1,\n            \"stroke-linejoin\": \"bevel\",\n            \"stroke-linecap\": \"sqaure\"\n        };\n        this._font = new Font(14, \"sans-serif\");\n        this._ctx.font = this._font.value;\n        return this;\n    }\n    updateScope(group_id, group) {\n        this._ctx.group = group;\n        this._ctx.groupID = group_id;\n        this._ctx.groupCount = 0;\n        this.nextID();\n        return this._ctx;\n    }\n    scope(item) {\n        if (!item || item.animateID == null)\n            throw new Error(\"item not defined or not yet added to Space\");\n        return this.updateScope(SVGForm.scopeID(item), this.space.element);\n    }\n    nextID() {\n        this._ctx.groupCount++;\n        this._ctx.currentID = `${this._ctx.groupID}-${this._ctx.groupCount}`;\n        return this._ctx.currentID;\n    }\n    static getID(ctx) {\n        return ctx.currentID || `p-${SVGForm.domID++}`;\n    }\n    static scopeID(item) {\n        return `item-${item.animateID}`;\n    }\n    static style(elem, styles) {\n        let st = [];\n        if (!styles[\"filled\"])\n            st.push(\"fill: none\");\n        if (!styles[\"stroked\"])\n            st.push(\"stroke: none\");\n        for (let k in styles) {\n            if (styles.hasOwnProperty(k) && k != \"filled\" && k != \"stroked\") {\n                let v = styles[k];\n                if (v) {\n                    if (!styles[\"filled\"] && k.indexOf('fill') === 0) {\n                        continue;\n                    }\n                    else if (!styles[\"stroked\"] && k.indexOf('stroke') === 0) {\n                        continue;\n                    }\n                    else {\n                        st.push(`${k}: ${v}`);\n                    }\n                }\n            }\n        }\n        return DOMSpace.setAttr(elem, { style: st.join(\";\") });\n    }\n    static point(ctx, pt, radius = 5, shape = \"square\") {\n        if (shape === \"circle\") {\n            return SVGForm.circle(ctx, pt, radius);\n        }\n        else {\n            return SVGForm.square(ctx, pt, radius);\n        }\n    }\n    point(pt, radius = 5, shape = \"square\") {\n        this.nextID();\n        SVGForm.point(this._ctx, pt, radius, shape);\n        return this;\n    }\n    static circle(ctx, pt, radius = 10) {\n        let elem = SVGSpace.svgElement(ctx.group, \"circle\", SVGForm.getID(ctx));\n        DOMSpace.setAttr(elem, {\n            cx: pt[0],\n            cy: pt[1],\n            r: radius,\n            'class': `pts-svgform pts-circle ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    circle(pts) {\n        this.nextID();\n        SVGForm.circle(this._ctx, pts[0], pts[1][0]);\n        return this;\n    }\n    static arc(ctx, pt, radius, startAngle, endAngle, cc) {\n        let elem = SVGSpace.svgElement(ctx.group, \"path\", SVGForm.getID(ctx));\n        const start = new Pt(pt).toAngle(startAngle, radius, true);\n        const end = new Pt(pt).toAngle(endAngle, radius, true);\n        const diff = Geom.boundAngle(endAngle) - Geom.boundAngle(startAngle);\n        let largeArc = (diff > Const.pi) ? true : false;\n        if (cc)\n            largeArc = !largeArc;\n        const sweep = (cc) ? \"0\" : \"1\";\n        const d = `M ${start[0]} ${start[1]} A ${radius} ${radius} 0 ${largeArc ? \"1\" : \"0\"} ${sweep} ${end[0]} ${end[1]}`;\n        DOMSpace.setAttr(elem, {\n            d: d,\n            'class': `pts-svgform pts-arc ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    arc(pt, radius, startAngle, endAngle, cc) {\n        this.nextID();\n        SVGForm.arc(this._ctx, pt, radius, startAngle, endAngle, cc);\n        return this;\n    }\n    static square(ctx, pt, halfsize) {\n        let elem = SVGSpace.svgElement(ctx.group, \"rect\", SVGForm.getID(ctx));\n        DOMSpace.setAttr(elem, {\n            x: pt[0] - halfsize,\n            y: pt[1] - halfsize,\n            width: halfsize * 2,\n            height: halfsize * 2,\n            'class': `pts-svgform pts-square ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    square(pt, halfsize) {\n        this.nextID();\n        SVGForm.square(this._ctx, pt, halfsize);\n        return this;\n    }\n    static line(ctx, pts) {\n        if (!this._checkSize(pts))\n            return;\n        if (pts.length > 2)\n            return SVGForm._poly(ctx, pts, false);\n        let elem = SVGSpace.svgElement(ctx.group, \"line\", SVGForm.getID(ctx));\n        DOMSpace.setAttr(elem, {\n            x1: pts[0][0],\n            y1: pts[0][1],\n            x2: pts[1][0],\n            y2: pts[1][1],\n            'class': `pts-svgform pts-line ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    line(pts) {\n        this.nextID();\n        SVGForm.line(this._ctx, pts);\n        return this;\n    }\n    static _poly(ctx, pts, closePath = true) {\n        if (!this._checkSize(pts))\n            return;\n        let elem = SVGSpace.svgElement(ctx.group, ((closePath) ? \"polygon\" : \"polyline\"), SVGForm.getID(ctx));\n        let points = pts.reduce((a, p) => a + `${p[0]},${p[1]} `, \"\");\n        DOMSpace.setAttr(elem, {\n            points: points,\n            'class': `pts-svgform pts-polygon ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    static polygon(ctx, pts) {\n        return SVGForm._poly(ctx, pts, true);\n    }\n    polygon(pts) {\n        this.nextID();\n        SVGForm.polygon(this._ctx, pts);\n        return this;\n    }\n    static rect(ctx, pts) {\n        if (!this._checkSize(pts))\n            return;\n        let elem = SVGSpace.svgElement(ctx.group, \"rect\", SVGForm.getID(ctx));\n        let bound = Group.fromArray(pts).boundingBox();\n        let size = Rectangle.size(bound);\n        DOMSpace.setAttr(elem, {\n            x: bound[0][0],\n            y: bound[0][1],\n            width: size[0],\n            height: size[1],\n            'class': `pts-svgform pts-rect ${ctx.currentClass}`,\n        });\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    rect(pts) {\n        this.nextID();\n        SVGForm.rect(this._ctx, pts);\n        return this;\n    }\n    static text(ctx, pt, txt) {\n        let elem = SVGSpace.svgElement(ctx.group, \"text\", SVGForm.getID(ctx));\n        DOMSpace.setAttr(elem, {\n            \"pointer-events\": \"none\",\n            x: pt[0],\n            y: pt[1],\n            dx: 0, dy: 0,\n            'class': `pts-svgform pts-text ${ctx.currentClass}`,\n        });\n        elem.textContent = txt;\n        SVGForm.style(elem, ctx.style);\n        return elem;\n    }\n    text(pt, txt) {\n        this.nextID();\n        SVGForm.text(this._ctx, pt, txt);\n        return this;\n    }\n    log(txt) {\n        this.fill(\"#000\").stroke(\"#fff\", 0.5).text([10, 14], txt);\n        return this;\n    }\n}\nSVGForm.groupID = 0;\nSVGForm.domID = 0;\n//# sourceMappingURL=Svg.js.map","import { Pt, Group, Bound } from \"./Pt\";\nimport { Polygon, Circle } from \"./Op\";\nexport class World {\n    constructor(bound, friction = 1, gravity = 0) {\n        this._lastTime = null;\n        this._gravity = new Pt();\n        this._friction = 1;\n        this._damping = 0.75;\n        this._particles = [];\n        this._bodies = [];\n        this._names = { p: {}, b: {} };\n        this._bound = Bound.fromGroup(bound);\n        this._friction = friction;\n        this._gravity = (typeof gravity === \"number\") ? new Pt(0, gravity) : new Pt(gravity);\n        return this;\n    }\n    get gravity() { return this._gravity; }\n    set gravity(g) { this._gravity = g; }\n    get friction() { return this._friction; }\n    set friction(f) { this._friction = f; }\n    get damping() { return this._damping; }\n    set damping(f) { this._damping = f; }\n    get bodyCount() { return this._bodies.length; }\n    get particleCount() { return this._particles.length; }\n    body(id) { return this._bodies[(typeof id === \"string\") ? this._names.b[id] : id]; }\n    particle(id) { return this._particles[(typeof id === \"string\") ? this._names.p[id] : id]; }\n    update(ms) {\n        let dt = ms / 1000;\n        this._updateParticles(dt);\n        this._updateBodies(dt);\n    }\n    drawParticles(fn) {\n        this._drawParticles = fn;\n    }\n    drawBodies(fn) {\n        this._drawBodies = fn;\n    }\n    add(p, name) {\n        if (p instanceof Body) {\n            this._bodies.push(p);\n            if (name)\n                this._names.b[name] = this._bodies.length - 1;\n        }\n        else {\n            this._particles.push(p);\n            if (name)\n                this._names.p[name] = this._particles.length - 1;\n        }\n        return this;\n    }\n    remove(which, index, count = 1) {\n        let param = (index < 0) ? [index * -1 - 1, count] : [index, count];\n        if (which == \"body\") {\n            this._bodies.splice(param[0], param[1]);\n        }\n        else {\n            this._particles.splice(param[0], param[1]);\n        }\n        return this;\n    }\n    static edgeConstraint(p1, p2, dist, stiff = 1, precise = false) {\n        const m1 = 1 / (p1.mass || 1);\n        const m2 = 1 / (p2.mass || 1);\n        const mm = m1 + m2;\n        let delta = p2.$subtract(p1);\n        let distSq = dist * dist;\n        let d = (precise) ? (dist / delta.magnitude() - 1) : (distSq / (delta.dot(delta) + distSq) - 0.5);\n        let f = delta.$multiply(d * stiff);\n        p1.subtract(f.$multiply(m1 / mm));\n        p2.add(f.$multiply(m2 / mm));\n        return p1;\n    }\n    static boundConstraint(p, rect, damping = 0.75) {\n        let bound = rect.boundingBox();\n        let np = p.$min(bound[1].subtract(p.radius)).$max(bound[0].add(p.radius));\n        if (np[0] === bound[0][0] || np[0] === bound[1][0]) {\n            let c = p.changed.$multiply(damping);\n            p.previous = np.$subtract(new Pt(-c[0], c[1]));\n        }\n        else if (np[1] === bound[0][1] || np[1] === bound[1][1]) {\n            let c = p.changed.$multiply(damping);\n            p.previous = np.$subtract(new Pt(c[0], -c[1]));\n        }\n        p.to(np);\n    }\n    integrate(p, dt, prevDt) {\n        p.addForce(this._gravity);\n        p.verlet(dt, this._friction, prevDt);\n        return p;\n    }\n    _updateParticles(dt) {\n        for (let i = 0, len = this._particles.length; i < len; i++) {\n            let p = this._particles[i];\n            this.integrate(p, dt, this._lastTime);\n            World.boundConstraint(p, this._bound, this._damping);\n            for (let k = i + 1; k < len; k++) {\n                if (i !== k) {\n                    let p2 = this._particles[k];\n                    p.collide(p2, this._damping);\n                }\n            }\n            if (this._drawParticles)\n                this._drawParticles(p, i);\n        }\n        this._lastTime = dt;\n    }\n    _updateBodies(dt) {\n        for (let i = 0, len = this._bodies.length; i < len; i++) {\n            let b = this._bodies[i];\n            for (let k = 0, klen = b.length; k < klen; k++) {\n                let bk = b[k];\n                World.boundConstraint(bk, this._bound, this._damping);\n                this.integrate(bk, dt, this._lastTime);\n            }\n            for (let k = i + 1; k < len; k++) {\n                b.processBody(this._bodies[k]);\n            }\n            for (let m = 0, mlen = this._particles.length; m < mlen; m++) {\n                b.processParticle(this._particles[m]);\n            }\n            b.processEdges();\n            if (this._drawBodies)\n                this._drawBodies(b, i);\n        }\n    }\n}\nexport class Particle extends Pt {\n    constructor(...args) {\n        super(...args);\n        this._mass = 1;\n        this._radius = 0;\n        this._force = new Pt();\n        this._prev = new Pt();\n        this._lock = false;\n        this._prev = this.clone();\n    }\n    get mass() { return this._mass; }\n    set mass(m) { this._mass = m; }\n    get radius() { return this._radius; }\n    set radius(f) { this._radius = f; }\n    get previous() { return this._prev; }\n    set previous(p) { this._prev = p; }\n    get force() { return this._force; }\n    set force(g) { this._force = g; }\n    get body() { return this._body; }\n    set body(b) { this._body = b; }\n    get lock() { return this._lock; }\n    set lock(b) {\n        this._lock = b;\n        this._lockPt = new Pt(this);\n    }\n    get changed() { return this.$subtract(this._prev); }\n    set position(p) {\n        this.previous.to(this);\n        if (this._lock)\n            this._lockPt = p;\n        this.to(p);\n    }\n    size(r) {\n        this._mass = r;\n        this._radius = r;\n        return this;\n    }\n    addForce(...args) {\n        this._force.add(...args);\n        return this._force;\n    }\n    verlet(dt, friction, lastDt) {\n        if (this._lock) {\n            this.to(this._lockPt);\n        }\n        else {\n            let lt = (lastDt) ? lastDt : dt;\n            let a = this._force.multiply(dt * (dt + lt) / 2);\n            let v = this.changed.multiply(friction * dt / lt).add(a);\n            this._prev = this.clone();\n            this.add(v);\n            this._force = new Pt();\n        }\n        return this;\n    }\n    hit(...args) {\n        this._prev.subtract(new Pt(...args).$divide(Math.sqrt(this._mass)));\n        return this;\n    }\n    collide(p2, damp = 1) {\n        let p1 = this;\n        let dp = p1.$subtract(p2);\n        let distSq = dp.magnitudeSq();\n        let dr = p1.radius + p2.radius;\n        if (distSq < dr * dr) {\n            let c1 = p1.changed;\n            let c2 = p2.changed;\n            let dist = Math.sqrt(distSq);\n            let d = dp.$multiply(((dist - dr) / dist) / 2);\n            let np1 = p1.$subtract(d);\n            let np2 = p2.$add(d);\n            p1.to(np1);\n            p2.to(np2);\n            let f1 = damp * dp.dot(c1) / distSq;\n            let f2 = damp * dp.dot(c2) / distSq;\n            let dm1 = p1.mass / (p1.mass + p2.mass);\n            let dm2 = p2.mass / (p1.mass + p2.mass);\n            c1.add(new Pt(f2 * dp[0] - f1 * dp[0], f2 * dp[1] - f1 * dp[1]).$multiply(dm2));\n            c2.add(new Pt(f1 * dp[0] - f2 * dp[0], f1 * dp[1] - f2 * dp[1]).$multiply(dm1));\n            p1.previous = p1.$subtract(c1);\n            p2.previous = p2.$subtract(c2);\n        }\n    }\n    toString() {\n        return `Particle: ${this[0]} ${this[1]} | previous ${this._prev[0]} ${this._prev[1]} | mass ${this._mass}`;\n    }\n}\nexport class Body extends Group {\n    constructor() {\n        super();\n        this._cs = [];\n        this._stiff = 1;\n        this._locks = {};\n        this._mass = 1;\n    }\n    static fromGroup(list, stiff = 1, autoLink = true, autoMass = true) {\n        let b = new Body().init(list);\n        if (autoLink)\n            b.linkAll(stiff);\n        if (autoMass)\n            b.autoMass();\n        return b;\n    }\n    init(list, stiff = 1) {\n        let c = new Pt();\n        for (let i = 0, len = list.length; i < len; i++) {\n            let p = new Particle(list[i]);\n            p.body = this;\n            c.add(list[i]);\n            this.push(p);\n        }\n        this._stiff = stiff;\n        return this;\n    }\n    get mass() { return this._mass; }\n    set mass(m) {\n        this._mass = m;\n        for (let i = 0, len = this.length; i < len; i++) {\n            this[i].mass = this._mass;\n        }\n    }\n    autoMass() {\n        this.mass = Math.sqrt(Polygon.area(this)) / 10;\n        return this;\n    }\n    link(index1, index2, stiff) {\n        if (index1 < 0 || index1 >= this.length)\n            throw new Error(\"index1 is not in the Group's indices\");\n        if (index2 < 0 || index2 >= this.length)\n            throw new Error(\"index1 is not in the Group's indices\");\n        let d = this[index1].$subtract(this[index2]).magnitude();\n        this._cs.push([index1, index2, d, stiff || this._stiff]);\n        return this;\n    }\n    linkAll(stiff) {\n        let half = this.length / 2;\n        for (let i = 0, len = this.length; i < len; i++) {\n            let n = (i >= len - 1) ? 0 : i + 1;\n            this.link(i, n, stiff);\n            if (len > 4) {\n                let nd = (Math.floor(half / 2)) + 1;\n                let n2 = (i >= len - nd) ? i % len : i + nd;\n                this.link(i, n2, stiff);\n            }\n            if (i <= half - 1) {\n                this.link(i, Math.min(this.length - 1, i + Math.floor(half)));\n            }\n        }\n    }\n    linksToLines() {\n        let gs = [];\n        for (let i = 0, len = this._cs.length; i < len; i++) {\n            let ln = this._cs[i];\n            gs.push(new Group(this[ln[0]], this[ln[1]]));\n        }\n        return gs;\n    }\n    processEdges() {\n        for (let i = 0, len = this._cs.length; i < len; i++) {\n            let [m, n, d, s] = this._cs[i];\n            World.edgeConstraint(this[m], this[n], d, s);\n        }\n    }\n    processBody(b) {\n        let b1 = this;\n        let b2 = b;\n        let hit = Polygon.hasIntersectPolygon(b1, b2);\n        if (hit) {\n            let cv = hit.normal.$multiply(hit.dist);\n            let t;\n            let eg = hit.edge;\n            if (Math.abs(eg[0][0] - eg[1][0]) > Math.abs(eg[0][1] - eg[1][1])) {\n                t = (hit.vertex[0] - cv[0] - eg[0][0]) / (eg[1][0] - eg[0][0]);\n            }\n            else {\n                t = (hit.vertex[1] - cv[1] - eg[0][1]) / (eg[1][1] - eg[0][1]);\n            }\n            let lambda = 1 / (t * t + (1 - t) * (1 - t));\n            let m0 = hit.vertex.body.mass || 1;\n            let m1 = hit.edge[0].body.mass || 1;\n            let mr0 = m0 / (m0 + m1);\n            let mr1 = m1 / (m0 + m1);\n            eg[0].subtract(cv.$multiply(mr0 * (1 - t) * lambda / 2));\n            eg[1].subtract(cv.$multiply(mr0 * t * lambda / 2));\n            hit.vertex.add(cv.$multiply(mr1));\n        }\n    }\n    processParticle(b) {\n        let b1 = this;\n        let b2 = b;\n        let hit = Polygon.hasIntersectCircle(b1, Circle.fromCenter(b, b.radius));\n        if (hit) {\n            let cv = hit.normal.$multiply(hit.dist);\n            let t;\n            let eg = hit.edge;\n            if (Math.abs(eg[0][0] - eg[1][0]) > Math.abs(eg[0][1] - eg[1][1])) {\n                t = (hit.vertex[0] - cv[0] - eg[0][0]) / (eg[1][0] - eg[0][0]);\n            }\n            else {\n                t = (hit.vertex[1] - cv[1] - eg[0][1]) / (eg[1][1] - eg[0][1]);\n            }\n            let lambda = 1 / (t * t + (1 - t) * (1 - t));\n            let m0 = hit.vertex.mass || b2.mass || 1;\n            let m1 = hit.edge[0].body.mass || 1;\n            let mr0 = m0 / (m0 + m1);\n            let mr1 = m1 / (m0 + m1);\n            eg[0].subtract(cv.$multiply(mr0 * (1 - t) * lambda / 2));\n            eg[1].subtract(cv.$multiply(mr0 * t * lambda / 2));\n            let c1 = b.changed.add(cv.$multiply(mr1));\n            b.previous = b.$subtract(c1);\n        }\n    }\n}\n//# sourceMappingURL=Physics.js.map","export * from \"./Canvas\";\nexport * from \"./Create\";\nexport * from \"./Form\";\nexport * from \"./LinearAlgebra\";\nexport * from \"./Num\";\nexport * from \"./Op\";\nexport * from \"./Pt\";\nexport * from \"./Space\";\nexport * from \"./Color\";\nexport * from \"./Util\";\nexport * from \"./Dom\";\nexport * from \"./Svg\";\nexport * from \"./Typography\";\nexport * from \"./Physics\";\n//# sourceMappingURL=_module.js.map"],"sourceRoot":""}